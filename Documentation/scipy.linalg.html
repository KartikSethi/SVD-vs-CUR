
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: package scipy.linalg</title>
<meta charset="utf-8">
</head><body bgcolor="#f0f0f8">

<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="#7799ee">
<td valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial">&nbsp;<br><big><big><strong><a href="scipy.html"><font color="#ffffff">scipy</font></a>.linalg</strong></big></big> (version 0.4.9)</font></td
><td align=right valign=bottom
><font color="#ffffff" face="helvetica, arial"><a href=".">index</a><br><a href="file:/usr/local/lib/python2.7/dist-packages/scipy/linalg/__init__.py">/usr/local/lib/python2.7/dist-packages/scipy/linalg/__init__.py</a></font></td></tr></table>
    <p><tt>====================================<br>
Linear&nbsp;algebra&nbsp;(:mod:`scipy.linalg`)<br>
====================================<br>
&nbsp;<br>
..&nbsp;currentmodule::&nbsp;scipy.linalg<br>
&nbsp;<br>
Linear&nbsp;algebra&nbsp;functions.<br>
&nbsp;<br>
..&nbsp;seealso::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;`numpy.linalg`&nbsp;for&nbsp;more&nbsp;linear&nbsp;algebra&nbsp;functions.&nbsp;&nbsp;Note&nbsp;that<br>
&nbsp;&nbsp;&nbsp;although&nbsp;`scipy.linalg`&nbsp;imports&nbsp;most&nbsp;of&nbsp;them,&nbsp;identically&nbsp;named<br>
&nbsp;&nbsp;&nbsp;functions&nbsp;from&nbsp;`scipy.linalg`&nbsp;may&nbsp;offer&nbsp;more&nbsp;or&nbsp;slightly&nbsp;differing<br>
&nbsp;&nbsp;&nbsp;functionality.<br>
&nbsp;<br>
&nbsp;<br>
Basics<br>
======<br>
&nbsp;<br>
..&nbsp;autosummary::<br>
&nbsp;&nbsp;&nbsp;:toctree:&nbsp;generated/<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;inv&nbsp;-&nbsp;Find&nbsp;the&nbsp;inverse&nbsp;of&nbsp;a&nbsp;square&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;solve&nbsp;-&nbsp;Solve&nbsp;a&nbsp;linear&nbsp;system&nbsp;of&nbsp;equations<br>
&nbsp;&nbsp;&nbsp;solve_banded&nbsp;-&nbsp;Solve&nbsp;a&nbsp;banded&nbsp;linear&nbsp;system<br>
&nbsp;&nbsp;&nbsp;solveh_banded&nbsp;-&nbsp;Solve&nbsp;a&nbsp;Hermitian&nbsp;or&nbsp;symmetric&nbsp;banded&nbsp;system<br>
&nbsp;&nbsp;&nbsp;solve_circulant&nbsp;-&nbsp;Solve&nbsp;a&nbsp;circulant&nbsp;system<br>
&nbsp;&nbsp;&nbsp;solve_triangular&nbsp;-&nbsp;Solve&nbsp;a&nbsp;triangular&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;solve_toeplitz&nbsp;-&nbsp;Solve&nbsp;a&nbsp;toeplitz&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;det&nbsp;-&nbsp;Find&nbsp;the&nbsp;determinant&nbsp;of&nbsp;a&nbsp;square&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;norm&nbsp;-&nbsp;Matrix&nbsp;and&nbsp;vector&nbsp;norm<br>
&nbsp;&nbsp;&nbsp;lstsq&nbsp;-&nbsp;Solve&nbsp;a&nbsp;linear&nbsp;least-squares&nbsp;problem<br>
&nbsp;&nbsp;&nbsp;pinv&nbsp;-&nbsp;Pseudo-inverse&nbsp;(Moore-Penrose)&nbsp;using&nbsp;lstsq<br>
&nbsp;&nbsp;&nbsp;pinv2&nbsp;-&nbsp;Pseudo-inverse&nbsp;using&nbsp;svd<br>
&nbsp;&nbsp;&nbsp;pinvh&nbsp;-&nbsp;Pseudo-inverse&nbsp;of&nbsp;hermitian&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;kron&nbsp;-&nbsp;Kronecker&nbsp;product&nbsp;of&nbsp;two&nbsp;arrays<br>
&nbsp;&nbsp;&nbsp;tril&nbsp;-&nbsp;Construct&nbsp;a&nbsp;lower-triangular&nbsp;matrix&nbsp;from&nbsp;a&nbsp;given&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;triu&nbsp;-&nbsp;Construct&nbsp;an&nbsp;upper-triangular&nbsp;matrix&nbsp;from&nbsp;a&nbsp;given&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;orthogonal_procrustes&nbsp;-&nbsp;Solve&nbsp;an&nbsp;orthogonal&nbsp;Procrustes&nbsp;problem<br>
&nbsp;&nbsp;&nbsp;<a href="#LinAlgError">LinAlgError</a><br>
&nbsp;<br>
Eigenvalue&nbsp;Problems<br>
===================<br>
&nbsp;<br>
..&nbsp;autosummary::<br>
&nbsp;&nbsp;&nbsp;:toctree:&nbsp;generated/<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;eig&nbsp;-&nbsp;Find&nbsp;the&nbsp;eigenvalues&nbsp;and&nbsp;eigenvectors&nbsp;of&nbsp;a&nbsp;square&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;eigvals&nbsp;-&nbsp;Find&nbsp;just&nbsp;the&nbsp;eigenvalues&nbsp;of&nbsp;a&nbsp;square&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;eigh&nbsp;-&nbsp;Find&nbsp;the&nbsp;e-vals&nbsp;and&nbsp;e-vectors&nbsp;of&nbsp;a&nbsp;Hermitian&nbsp;or&nbsp;symmetric&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;eigvalsh&nbsp;-&nbsp;Find&nbsp;just&nbsp;the&nbsp;eigenvalues&nbsp;of&nbsp;a&nbsp;Hermitian&nbsp;or&nbsp;symmetric&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;eig_banded&nbsp;-&nbsp;Find&nbsp;the&nbsp;eigenvalues&nbsp;and&nbsp;eigenvectors&nbsp;of&nbsp;a&nbsp;banded&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;eigvals_banded&nbsp;-&nbsp;Find&nbsp;just&nbsp;the&nbsp;eigenvalues&nbsp;of&nbsp;a&nbsp;banded&nbsp;matrix<br>
&nbsp;<br>
Decompositions<br>
==============<br>
&nbsp;<br>
..&nbsp;autosummary::<br>
&nbsp;&nbsp;&nbsp;:toctree:&nbsp;generated/<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;lu&nbsp;-&nbsp;LU&nbsp;decomposition&nbsp;of&nbsp;a&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;lu_factor&nbsp;-&nbsp;LU&nbsp;decomposition&nbsp;returning&nbsp;unordered&nbsp;matrix&nbsp;and&nbsp;pivots<br>
&nbsp;&nbsp;&nbsp;lu_solve&nbsp;-&nbsp;Solve&nbsp;Ax=b&nbsp;using&nbsp;back&nbsp;substitution&nbsp;with&nbsp;output&nbsp;of&nbsp;lu_factor<br>
&nbsp;&nbsp;&nbsp;svd&nbsp;-&nbsp;Singular&nbsp;value&nbsp;decomposition&nbsp;of&nbsp;a&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;svdvals&nbsp;-&nbsp;Singular&nbsp;values&nbsp;of&nbsp;a&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;diagsvd&nbsp;-&nbsp;Construct&nbsp;matrix&nbsp;of&nbsp;singular&nbsp;values&nbsp;from&nbsp;output&nbsp;of&nbsp;svd<br>
&nbsp;&nbsp;&nbsp;orth&nbsp;-&nbsp;Construct&nbsp;orthonormal&nbsp;basis&nbsp;for&nbsp;the&nbsp;range&nbsp;of&nbsp;A&nbsp;using&nbsp;svd<br>
&nbsp;&nbsp;&nbsp;cholesky&nbsp;-&nbsp;Cholesky&nbsp;decomposition&nbsp;of&nbsp;a&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;cholesky_banded&nbsp;-&nbsp;Cholesky&nbsp;decomp.&nbsp;of&nbsp;a&nbsp;sym.&nbsp;or&nbsp;Hermitian&nbsp;banded&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;cho_factor&nbsp;-&nbsp;Cholesky&nbsp;decomposition&nbsp;for&nbsp;use&nbsp;in&nbsp;solving&nbsp;a&nbsp;linear&nbsp;system<br>
&nbsp;&nbsp;&nbsp;cho_solve&nbsp;-&nbsp;Solve&nbsp;previously&nbsp;factored&nbsp;linear&nbsp;system<br>
&nbsp;&nbsp;&nbsp;cho_solve_banded&nbsp;-&nbsp;Solve&nbsp;previously&nbsp;factored&nbsp;banded&nbsp;linear&nbsp;system<br>
&nbsp;&nbsp;&nbsp;polar&nbsp;-&nbsp;Compute&nbsp;the&nbsp;polar&nbsp;decomposition.<br>
&nbsp;&nbsp;&nbsp;qr&nbsp;-&nbsp;QR&nbsp;decomposition&nbsp;of&nbsp;a&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;qr_multiply&nbsp;-&nbsp;QR&nbsp;decomposition&nbsp;and&nbsp;multiplication&nbsp;by&nbsp;Q<br>
&nbsp;&nbsp;&nbsp;qr_update&nbsp;-&nbsp;Rank&nbsp;k&nbsp;QR&nbsp;update<br>
&nbsp;&nbsp;&nbsp;qr_delete&nbsp;-&nbsp;QR&nbsp;downdate&nbsp;on&nbsp;row&nbsp;or&nbsp;column&nbsp;deletion<br>
&nbsp;&nbsp;&nbsp;qr_insert&nbsp;-&nbsp;QR&nbsp;update&nbsp;on&nbsp;row&nbsp;or&nbsp;column&nbsp;insertion<br>
&nbsp;&nbsp;&nbsp;rq&nbsp;-&nbsp;RQ&nbsp;decomposition&nbsp;of&nbsp;a&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;qz&nbsp;-&nbsp;QZ&nbsp;decomposition&nbsp;of&nbsp;a&nbsp;pair&nbsp;of&nbsp;matrices<br>
&nbsp;&nbsp;&nbsp;ordqz&nbsp;-&nbsp;QZ&nbsp;decomposition&nbsp;of&nbsp;a&nbsp;pair&nbsp;of&nbsp;matrices&nbsp;with&nbsp;reordering<br>
&nbsp;&nbsp;&nbsp;schur&nbsp;-&nbsp;Schur&nbsp;decomposition&nbsp;of&nbsp;a&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;rsf2csf&nbsp;-&nbsp;Real&nbsp;to&nbsp;complex&nbsp;Schur&nbsp;form<br>
&nbsp;&nbsp;&nbsp;hessenberg&nbsp;-&nbsp;Hessenberg&nbsp;form&nbsp;of&nbsp;a&nbsp;matrix<br>
&nbsp;<br>
..&nbsp;seealso::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;`scipy.linalg.interpolative`&nbsp;--&nbsp;Interpolative&nbsp;matrix&nbsp;decompositions<br>
&nbsp;<br>
&nbsp;<br>
Matrix&nbsp;Functions<br>
================<br>
&nbsp;<br>
..&nbsp;autosummary::<br>
&nbsp;&nbsp;&nbsp;:toctree:&nbsp;generated/<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;expm&nbsp;-&nbsp;Matrix&nbsp;exponential<br>
&nbsp;&nbsp;&nbsp;logm&nbsp;-&nbsp;Matrix&nbsp;logarithm<br>
&nbsp;&nbsp;&nbsp;cosm&nbsp;-&nbsp;Matrix&nbsp;cosine<br>
&nbsp;&nbsp;&nbsp;sinm&nbsp;-&nbsp;Matrix&nbsp;sine<br>
&nbsp;&nbsp;&nbsp;tanm&nbsp;-&nbsp;Matrix&nbsp;tangent<br>
&nbsp;&nbsp;&nbsp;coshm&nbsp;-&nbsp;Matrix&nbsp;hyperbolic&nbsp;cosine<br>
&nbsp;&nbsp;&nbsp;sinhm&nbsp;-&nbsp;Matrix&nbsp;hyperbolic&nbsp;sine<br>
&nbsp;&nbsp;&nbsp;tanhm&nbsp;-&nbsp;Matrix&nbsp;hyperbolic&nbsp;tangent<br>
&nbsp;&nbsp;&nbsp;signm&nbsp;-&nbsp;Matrix&nbsp;sign<br>
&nbsp;&nbsp;&nbsp;sqrtm&nbsp;-&nbsp;Matrix&nbsp;square&nbsp;root<br>
&nbsp;&nbsp;&nbsp;funm&nbsp;-&nbsp;Evaluating&nbsp;an&nbsp;arbitrary&nbsp;matrix&nbsp;function<br>
&nbsp;&nbsp;&nbsp;expm_frechet&nbsp;-&nbsp;Frechet&nbsp;derivative&nbsp;of&nbsp;the&nbsp;matrix&nbsp;exponential<br>
&nbsp;&nbsp;&nbsp;expm_cond&nbsp;-&nbsp;Relative&nbsp;condition&nbsp;number&nbsp;of&nbsp;expm&nbsp;in&nbsp;the&nbsp;Frobenius&nbsp;norm<br>
&nbsp;&nbsp;&nbsp;fractional_matrix_power&nbsp;-&nbsp;Fractional&nbsp;matrix&nbsp;power<br>
&nbsp;<br>
&nbsp;<br>
Matrix&nbsp;Equation&nbsp;Solvers<br>
=======================<br>
&nbsp;<br>
..&nbsp;autosummary::<br>
&nbsp;&nbsp;&nbsp;:toctree:&nbsp;generated/<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;solve_sylvester&nbsp;-&nbsp;Solve&nbsp;the&nbsp;Sylvester&nbsp;matrix&nbsp;equation<br>
&nbsp;&nbsp;&nbsp;solve_continuous_are&nbsp;-&nbsp;Solve&nbsp;the&nbsp;continuous-time&nbsp;algebraic&nbsp;Riccati&nbsp;equation<br>
&nbsp;&nbsp;&nbsp;solve_discrete_are&nbsp;-&nbsp;Solve&nbsp;the&nbsp;discrete-time&nbsp;algebraic&nbsp;Riccati&nbsp;equation<br>
&nbsp;&nbsp;&nbsp;solve_discrete_lyapunov&nbsp;-&nbsp;Solve&nbsp;the&nbsp;discrete-time&nbsp;Lyapunov&nbsp;equation<br>
&nbsp;&nbsp;&nbsp;solve_lyapunov&nbsp;-&nbsp;Solve&nbsp;the&nbsp;(continous-time)&nbsp;Lyapunov&nbsp;equation<br>
&nbsp;<br>
&nbsp;<br>
Special&nbsp;Matrices<br>
================<br>
&nbsp;<br>
..&nbsp;autosummary::<br>
&nbsp;&nbsp;&nbsp;:toctree:&nbsp;generated/<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;block_diag&nbsp;-&nbsp;Construct&nbsp;a&nbsp;block&nbsp;diagonal&nbsp;matrix&nbsp;from&nbsp;submatrices<br>
&nbsp;&nbsp;&nbsp;circulant&nbsp;-&nbsp;Circulant&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;companion&nbsp;-&nbsp;Companion&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;dft&nbsp;-&nbsp;Discrete&nbsp;Fourier&nbsp;transform&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;hadamard&nbsp;-&nbsp;Hadamard&nbsp;matrix&nbsp;of&nbsp;order&nbsp;2**n<br>
&nbsp;&nbsp;&nbsp;hankel&nbsp;-&nbsp;Hankel&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;helmert&nbsp;-&nbsp;Helmert&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;hilbert&nbsp;-&nbsp;Hilbert&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;invhilbert&nbsp;-&nbsp;Inverse&nbsp;Hilbert&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;leslie&nbsp;-&nbsp;Leslie&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;pascal&nbsp;-&nbsp;Pascal&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;invpascal&nbsp;-&nbsp;Inverse&nbsp;Pascal&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;toeplitz&nbsp;-&nbsp;Toeplitz&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;tri&nbsp;-&nbsp;Construct&nbsp;a&nbsp;matrix&nbsp;filled&nbsp;with&nbsp;ones&nbsp;at&nbsp;and&nbsp;below&nbsp;a&nbsp;given&nbsp;diagonal<br>
&nbsp;<br>
Low-level&nbsp;routines<br>
==================<br>
&nbsp;<br>
..&nbsp;autosummary::<br>
&nbsp;&nbsp;&nbsp;:toctree:&nbsp;generated/<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;get_blas_funcs<br>
&nbsp;&nbsp;&nbsp;get_lapack_funcs<br>
&nbsp;&nbsp;&nbsp;find_best_blas_type<br>
&nbsp;<br>
..&nbsp;seealso::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;`scipy.linalg.blas`&nbsp;--&nbsp;Low-level&nbsp;BLAS&nbsp;functions<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;`scipy.linalg.lapack`&nbsp;--&nbsp;Low-level&nbsp;LAPACK&nbsp;functions<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;`scipy.linalg.cython_blas`&nbsp;--&nbsp;Low-level&nbsp;BLAS&nbsp;functions&nbsp;for&nbsp;Cython<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;`scipy.linalg.cython_lapack`&nbsp;--&nbsp;Low-level&nbsp;LAPACK&nbsp;functions&nbsp;for&nbsp;Cython</tt></p>
<p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#aa55cc">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Package Contents</strong></big></font></td></tr>
    
<tr><td bgcolor="#aa55cc"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><table width="100%" summary="list"><tr><td width="25%" valign=top><a href="scipy.linalg._calc_lwork.html">_calc_lwork</a><br>
<a href="scipy.linalg._cython_signature_generator.html">_cython_signature_generator</a><br>
<a href="scipy.linalg._cython_wrapper_generators.html">_cython_wrapper_generators</a><br>
<a href="scipy.linalg._decomp_polar.html">_decomp_polar</a><br>
<a href="scipy.linalg._decomp_qz.html">_decomp_qz</a><br>
<a href="scipy.linalg._decomp_update.html">_decomp_update</a><br>
<a href="scipy.linalg._expm_frechet.html">_expm_frechet</a><br>
<a href="scipy.linalg._fblas.html">_fblas</a><br>
<a href="scipy.linalg._flapack.html">_flapack</a><br>
<a href="scipy.linalg._flinalg.html">_flinalg</a><br>
</td><td width="25%" valign=top><a href="scipy.linalg._interpolative.html">_interpolative</a><br>
<a href="scipy.linalg._interpolative_backend.html">_interpolative_backend</a><br>
<a href="scipy.linalg._matfuncs_inv_ssq.html">_matfuncs_inv_ssq</a><br>
<a href="scipy.linalg._matfuncs_sqrtm.html">_matfuncs_sqrtm</a><br>
<a href="scipy.linalg._procrustes.html">_procrustes</a><br>
<a href="scipy.linalg._solve_toeplitz.html">_solve_toeplitz</a><br>
<a href="scipy.linalg._solvers.html">_solvers</a><br>
<a href="scipy.linalg._testutils.html">_testutils</a><br>
<a href="scipy.linalg.basic.html">basic</a><br>
<a href="scipy.linalg.blas.html">blas</a><br>
</td><td width="25%" valign=top><a href="scipy.linalg.calc_lwork.html">calc_lwork</a><br>
<a href="scipy.linalg.cython_blas.html">cython_blas</a><br>
<a href="scipy.linalg.cython_lapack.html">cython_lapack</a><br>
<a href="scipy.linalg.decomp.html">decomp</a><br>
<a href="scipy.linalg.decomp_cholesky.html">decomp_cholesky</a><br>
<a href="scipy.linalg.decomp_lu.html">decomp_lu</a><br>
<a href="scipy.linalg.decomp_qr.html">decomp_qr</a><br>
<a href="scipy.linalg.decomp_schur.html">decomp_schur</a><br>
<a href="scipy.linalg.decomp_svd.html">decomp_svd</a><br>
<a href="scipy.linalg.flinalg.html">flinalg</a><br>
</td><td width="25%" valign=top><a href="scipy.linalg.interpolative.html">interpolative</a><br>
<a href="scipy.linalg.lapack.html">lapack</a><br>
<a href="scipy.linalg.linalg_version.html">linalg_version</a><br>
<a href="scipy.linalg.matfuncs.html">matfuncs</a><br>
<a href="scipy.linalg.misc.html">misc</a><br>
<a href="scipy.linalg.setup.html">setup</a><br>
<a href="scipy.linalg.special_matrices.html">special_matrices</a><br>
</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ee77aa">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Classes</strong></big></font></td></tr>
    
<tr><td bgcolor="#ee77aa"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl>
<dt><font face="helvetica, arial"><a href="exceptions.html#Exception">exceptions.Exception</a>(<a href="exceptions.html#BaseException">exceptions.BaseException</a>)
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="numpy.linalg.linalg.html#LinAlgError">numpy.linalg.linalg.LinAlgError</a>
</font></dt></dl>
</dd>
</dl>
 <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="LinAlgError">class <strong>LinAlgError</strong></a>(<a href="exceptions.html#Exception">exceptions.Exception</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Generic&nbsp;Python-exception-derived&nbsp;object&nbsp;raised&nbsp;by&nbsp;linalg&nbsp;functions.<br>
&nbsp;<br>
General&nbsp;purpose&nbsp;exception&nbsp;class,&nbsp;derived&nbsp;from&nbsp;Python's&nbsp;exception.<a href="exceptions.html#Exception">Exception</a><br>
class,&nbsp;programmatically&nbsp;raised&nbsp;in&nbsp;linalg&nbsp;functions&nbsp;when&nbsp;a&nbsp;Linear<br>
Algebra-related&nbsp;condition&nbsp;would&nbsp;prevent&nbsp;further&nbsp;correct&nbsp;execution&nbsp;of&nbsp;the<br>
function.<br>
&nbsp;<br>
Parameters<br>
----------<br>
None<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;numpy&nbsp;import&nbsp;linalg&nbsp;as&nbsp;LA<br>
&gt;&gt;&gt;&nbsp;LA.<a href="#-inv">inv</a>(np.zeros((2,2)))<br>
Traceback&nbsp;(most&nbsp;recent&nbsp;call&nbsp;last):<br>
&nbsp;&nbsp;File&nbsp;"&lt;stdin&gt;",&nbsp;line&nbsp;1,&nbsp;in&nbsp;&lt;module&gt;<br>
&nbsp;&nbsp;File&nbsp;"...linalg.py",&nbsp;line&nbsp;350,<br>
&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;inv&nbsp;return&nbsp;wrap(<a href="#-solve">solve</a>(a,&nbsp;identity(a.shape[0],&nbsp;dtype=a.dtype)))<br>
&nbsp;&nbsp;File&nbsp;"...linalg.py",&nbsp;line&nbsp;249,<br>
&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;solve<br>
&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;<a href="#LinAlgError">LinAlgError</a>('Singular&nbsp;matrix')<br>
numpy.linalg.<a href="#LinAlgError">LinAlgError</a>:&nbsp;Singular&nbsp;matrix<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="numpy.linalg.linalg.html#LinAlgError">LinAlgError</a></dd>
<dd><a href="exceptions.html#Exception">exceptions.Exception</a></dd>
<dd><a href="exceptions.html#BaseException">exceptions.BaseException</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Methods inherited from <a href="exceptions.html#Exception">exceptions.Exception</a>:<br>
<dl><dt><a name="LinAlgError-__init__"><strong>__init__</strong></a>(...)</dt><dd><tt>x.<a href="#LinAlgError-__init__">__init__</a>(...)&nbsp;initializes&nbsp;x;&nbsp;see&nbsp;help(type(x))&nbsp;for&nbsp;signature</tt></dd></dl>

<hr>
Data and other attributes inherited from <a href="exceptions.html#Exception">exceptions.Exception</a>:<br>
<dl><dt><strong>__new__</strong> = &lt;built-in method __new__ of type object&gt;<dd><tt>T.<a href="#LinAlgError-__new__">__new__</a>(S,&nbsp;...)&nbsp;-&gt;&nbsp;a&nbsp;new&nbsp;object&nbsp;with&nbsp;type&nbsp;S,&nbsp;a&nbsp;subtype&nbsp;of&nbsp;T</tt></dl>

<hr>
Methods inherited from <a href="exceptions.html#BaseException">exceptions.BaseException</a>:<br>
<dl><dt><a name="LinAlgError-__delattr__"><strong>__delattr__</strong></a>(...)</dt><dd><tt>x.<a href="#LinAlgError-__delattr__">__delattr__</a>('name')&nbsp;&lt;==&gt;&nbsp;del&nbsp;x.name</tt></dd></dl>

<dl><dt><a name="LinAlgError-__getattribute__"><strong>__getattribute__</strong></a>(...)</dt><dd><tt>x.<a href="#LinAlgError-__getattribute__">__getattribute__</a>('name')&nbsp;&lt;==&gt;&nbsp;x.name</tt></dd></dl>

<dl><dt><a name="LinAlgError-__getitem__"><strong>__getitem__</strong></a>(...)</dt><dd><tt>x.<a href="#LinAlgError-__getitem__">__getitem__</a>(y)&nbsp;&lt;==&gt;&nbsp;x[y]</tt></dd></dl>

<dl><dt><a name="LinAlgError-__getslice__"><strong>__getslice__</strong></a>(...)</dt><dd><tt>x.<a href="#LinAlgError-__getslice__">__getslice__</a>(i,&nbsp;j)&nbsp;&lt;==&gt;&nbsp;x[i:j]<br>
&nbsp;<br>
Use&nbsp;of&nbsp;negative&nbsp;indices&nbsp;is&nbsp;not&nbsp;supported.</tt></dd></dl>

<dl><dt><a name="LinAlgError-__reduce__"><strong>__reduce__</strong></a>(...)</dt></dl>

<dl><dt><a name="LinAlgError-__repr__"><strong>__repr__</strong></a>(...)</dt><dd><tt>x.<a href="#LinAlgError-__repr__">__repr__</a>()&nbsp;&lt;==&gt;&nbsp;repr(x)</tt></dd></dl>

<dl><dt><a name="LinAlgError-__setattr__"><strong>__setattr__</strong></a>(...)</dt><dd><tt>x.<a href="#LinAlgError-__setattr__">__setattr__</a>('name',&nbsp;value)&nbsp;&lt;==&gt;&nbsp;x.name&nbsp;=&nbsp;value</tt></dd></dl>

<dl><dt><a name="LinAlgError-__setstate__"><strong>__setstate__</strong></a>(...)</dt></dl>

<dl><dt><a name="LinAlgError-__str__"><strong>__str__</strong></a>(...)</dt><dd><tt>x.<a href="#LinAlgError-__str__">__str__</a>()&nbsp;&lt;==&gt;&nbsp;str(x)</tt></dd></dl>

<dl><dt><a name="LinAlgError-__unicode__"><strong>__unicode__</strong></a>(...)</dt></dl>

<hr>
Data descriptors inherited from <a href="exceptions.html#BaseException">exceptions.BaseException</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
</dl>
<dl><dt><strong>args</strong></dt>
</dl>
<dl><dt><strong>message</strong></dt>
</dl>
</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#eeaa77">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Functions</strong></big></font></td></tr>
    
<tr><td bgcolor="#eeaa77"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl><dt><a name="-block_diag"><strong>block_diag</strong></a>(*arrs)</dt><dd><tt>Create&nbsp;a&nbsp;block&nbsp;diagonal&nbsp;matrix&nbsp;from&nbsp;provided&nbsp;arrays.<br>
&nbsp;<br>
Given&nbsp;the&nbsp;inputs&nbsp;`A`,&nbsp;`B`&nbsp;and&nbsp;`C`,&nbsp;the&nbsp;output&nbsp;will&nbsp;have&nbsp;these<br>
arrays&nbsp;arranged&nbsp;on&nbsp;the&nbsp;diagonal::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[[A,&nbsp;0,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;B,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;C]]<br>
&nbsp;<br>
Parameters<br>
----------<br>
A,&nbsp;B,&nbsp;C,&nbsp;...&nbsp;:&nbsp;array_like,&nbsp;up&nbsp;to&nbsp;2-D<br>
&nbsp;&nbsp;&nbsp;&nbsp;Input&nbsp;arrays.&nbsp;&nbsp;A&nbsp;1-D&nbsp;array&nbsp;or&nbsp;array_like&nbsp;sequence&nbsp;of&nbsp;length&nbsp;`n`&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;treated&nbsp;as&nbsp;a&nbsp;2-D&nbsp;array&nbsp;with&nbsp;shape&nbsp;``(1,n)``.<br>
&nbsp;<br>
Returns<br>
-------<br>
D&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Array&nbsp;with&nbsp;`A`,&nbsp;`B`,&nbsp;`C`,&nbsp;...&nbsp;on&nbsp;the&nbsp;diagonal.&nbsp;&nbsp;`D`&nbsp;has&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;same&nbsp;dtype&nbsp;as&nbsp;`A`.<br>
&nbsp;<br>
Notes<br>
-----<br>
If&nbsp;all&nbsp;the&nbsp;input&nbsp;arrays&nbsp;are&nbsp;square,&nbsp;the&nbsp;output&nbsp;is&nbsp;known&nbsp;as&nbsp;a<br>
block&nbsp;diagonal&nbsp;matrix.<br>
&nbsp;<br>
Empty&nbsp;sequences&nbsp;(i.e.,&nbsp;array-likes&nbsp;of&nbsp;zero&nbsp;size)&nbsp;are&nbsp;ignored.<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;block_diag<br>
&gt;&gt;&gt;&nbsp;A&nbsp;=&nbsp;[[1,&nbsp;0],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;1]]<br>
&gt;&gt;&gt;&nbsp;B&nbsp;=&nbsp;[[3,&nbsp;4,&nbsp;5],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[6,&nbsp;7,&nbsp;8]]<br>
&gt;&gt;&gt;&nbsp;C&nbsp;=&nbsp;[[7]]<br>
&gt;&gt;&gt;&nbsp;<a href="#-block_diag">block_diag</a>(A,&nbsp;B,&nbsp;C)<br>
array([[1,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;1,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;7]])<br>
&gt;&gt;&gt;&nbsp;<a href="#-block_diag">block_diag</a>(1.0,&nbsp;[2,&nbsp;3],&nbsp;[[4,&nbsp;5],&nbsp;[6,&nbsp;7]])<br>
array([[&nbsp;1.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;2.,&nbsp;&nbsp;3.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;4.,&nbsp;&nbsp;5.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;6.,&nbsp;&nbsp;7.]])</tt></dd></dl>
 <dl><dt><a name="-cho_factor"><strong>cho_factor</strong></a>(a, lower<font color="#909090">=False</font>, overwrite_a<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Compute&nbsp;the&nbsp;Cholesky&nbsp;decomposition&nbsp;of&nbsp;a&nbsp;matrix,&nbsp;to&nbsp;use&nbsp;in&nbsp;cho_solve<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;matrix&nbsp;containing&nbsp;the&nbsp;Cholesky&nbsp;decomposition,<br>
``A&nbsp;=&nbsp;L&nbsp;L*``&nbsp;or&nbsp;``A&nbsp;=&nbsp;U*&nbsp;U``&nbsp;of&nbsp;a&nbsp;Hermitian&nbsp;positive-definite&nbsp;matrix&nbsp;`a`.<br>
The&nbsp;return&nbsp;value&nbsp;can&nbsp;be&nbsp;directly&nbsp;used&nbsp;as&nbsp;the&nbsp;first&nbsp;parameter&nbsp;to&nbsp;cho_solve.<br>
&nbsp;<br>
..&nbsp;warning::<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;returned&nbsp;matrix&nbsp;also&nbsp;contains&nbsp;random&nbsp;data&nbsp;in&nbsp;the&nbsp;entries&nbsp;not<br>
&nbsp;&nbsp;&nbsp;&nbsp;used&nbsp;by&nbsp;the&nbsp;Cholesky&nbsp;decomposition.&nbsp;If&nbsp;you&nbsp;need&nbsp;to&nbsp;zero&nbsp;these<br>
&nbsp;&nbsp;&nbsp;&nbsp;entries,&nbsp;use&nbsp;the&nbsp;function&nbsp;`cholesky`&nbsp;instead.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;to&nbsp;be&nbsp;decomposed<br>
lower&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;compute&nbsp;the&nbsp;upper&nbsp;or&nbsp;lower&nbsp;triangular&nbsp;Cholesky&nbsp;factorization<br>
&nbsp;&nbsp;&nbsp;&nbsp;(Default:&nbsp;upper-triangular)<br>
overwrite_a&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;overwrite&nbsp;data&nbsp;in&nbsp;a&nbsp;(may&nbsp;improve&nbsp;performance)<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
c&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;whose&nbsp;upper&nbsp;or&nbsp;lower&nbsp;triangle&nbsp;contains&nbsp;the&nbsp;Cholesky&nbsp;factor<br>
&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;`a`.&nbsp;Other&nbsp;parts&nbsp;of&nbsp;the&nbsp;matrix&nbsp;contain&nbsp;random&nbsp;data.<br>
lower&nbsp;:&nbsp;bool<br>
&nbsp;&nbsp;&nbsp;&nbsp;Flag&nbsp;indicating&nbsp;whether&nbsp;the&nbsp;factor&nbsp;is&nbsp;in&nbsp;the&nbsp;lower&nbsp;or&nbsp;upper&nbsp;triangle<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;Raised&nbsp;if&nbsp;decomposition&nbsp;fails.<br>
&nbsp;<br>
See&nbsp;also<br>
--------<br>
cho_solve&nbsp;:&nbsp;Solve&nbsp;a&nbsp;linear&nbsp;set&nbsp;equations&nbsp;using&nbsp;the&nbsp;Cholesky&nbsp;factorization<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;a&nbsp;matrix.</tt></dd></dl>
 <dl><dt><a name="-cho_solve"><strong>cho_solve</strong></a>(c_and_lower, b, overwrite_b<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Solve&nbsp;the&nbsp;linear&nbsp;equations&nbsp;A&nbsp;x&nbsp;=&nbsp;b,&nbsp;given&nbsp;the&nbsp;Cholesky&nbsp;factorization&nbsp;of&nbsp;A.<br>
&nbsp;<br>
Parameters<br>
----------<br>
(c,&nbsp;lower)&nbsp;:&nbsp;tuple,&nbsp;(array,&nbsp;bool)<br>
&nbsp;&nbsp;&nbsp;&nbsp;Cholesky&nbsp;factorization&nbsp;of&nbsp;a,&nbsp;as&nbsp;given&nbsp;by&nbsp;cho_factor<br>
b&nbsp;:&nbsp;array<br>
&nbsp;&nbsp;&nbsp;&nbsp;Right-hand&nbsp;side<br>
overwrite_b&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;overwrite&nbsp;data&nbsp;in&nbsp;b&nbsp;(may&nbsp;improve&nbsp;performance)<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrices&nbsp;contain&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
x&nbsp;:&nbsp;array<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;solution&nbsp;to&nbsp;the&nbsp;system&nbsp;A&nbsp;x&nbsp;=&nbsp;b<br>
&nbsp;<br>
See&nbsp;also<br>
--------<br>
cho_factor&nbsp;:&nbsp;Cholesky&nbsp;factorization&nbsp;of&nbsp;a&nbsp;matrix</tt></dd></dl>
 <dl><dt><a name="-cho_solve_banded"><strong>cho_solve_banded</strong></a>(cb_and_lower, b, overwrite_b<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Solve&nbsp;the&nbsp;linear&nbsp;equations&nbsp;A&nbsp;x&nbsp;=&nbsp;b,&nbsp;given&nbsp;the&nbsp;Cholesky&nbsp;factorization&nbsp;of&nbsp;A.<br>
&nbsp;<br>
Parameters<br>
----------<br>
(cb,&nbsp;lower)&nbsp;:&nbsp;tuple,&nbsp;(array,&nbsp;bool)<br>
&nbsp;&nbsp;&nbsp;&nbsp;`cb`&nbsp;is&nbsp;the&nbsp;Cholesky&nbsp;factorization&nbsp;of&nbsp;A,&nbsp;as&nbsp;given&nbsp;by&nbsp;cholesky_banded.<br>
&nbsp;&nbsp;&nbsp;&nbsp;`lower`&nbsp;must&nbsp;be&nbsp;the&nbsp;same&nbsp;value&nbsp;that&nbsp;was&nbsp;given&nbsp;to&nbsp;cholesky_banded.<br>
b&nbsp;:&nbsp;array<br>
&nbsp;&nbsp;&nbsp;&nbsp;Right-hand&nbsp;side<br>
overwrite_b&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;the&nbsp;function&nbsp;will&nbsp;overwrite&nbsp;the&nbsp;values&nbsp;in&nbsp;`b`.<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrices&nbsp;contain&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
x&nbsp;:&nbsp;array<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;solution&nbsp;to&nbsp;the&nbsp;system&nbsp;A&nbsp;x&nbsp;=&nbsp;b<br>
&nbsp;<br>
See&nbsp;also<br>
--------<br>
cholesky_banded&nbsp;:&nbsp;Cholesky&nbsp;factorization&nbsp;of&nbsp;a&nbsp;banded&nbsp;matrix<br>
&nbsp;<br>
Notes<br>
-----<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.8.0</tt></dd></dl>
 <dl><dt><a name="-cholesky"><strong>cholesky</strong></a>(a, lower<font color="#909090">=False</font>, overwrite_a<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Compute&nbsp;the&nbsp;Cholesky&nbsp;decomposition&nbsp;of&nbsp;a&nbsp;matrix.<br>
&nbsp;<br>
Returns&nbsp;the&nbsp;Cholesky&nbsp;decomposition,&nbsp;:math:`A&nbsp;=&nbsp;L&nbsp;L^*`&nbsp;or<br>
:math:`A&nbsp;=&nbsp;U^*&nbsp;U`&nbsp;of&nbsp;a&nbsp;Hermitian&nbsp;positive-definite&nbsp;matrix&nbsp;A.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;to&nbsp;be&nbsp;decomposed<br>
lower&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;compute&nbsp;the&nbsp;upper&nbsp;or&nbsp;lower&nbsp;triangular&nbsp;Cholesky<br>
&nbsp;&nbsp;&nbsp;&nbsp;factorization.&nbsp;&nbsp;Default&nbsp;is&nbsp;upper-triangular.<br>
overwrite_a&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;overwrite&nbsp;data&nbsp;in&nbsp;`a`&nbsp;(may&nbsp;improve&nbsp;performance).<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
c&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Upper-&nbsp;or&nbsp;lower-triangular&nbsp;Cholesky&nbsp;factor&nbsp;of&nbsp;`a`.<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a>&nbsp;:&nbsp;if&nbsp;decomposition&nbsp;fails.<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy&nbsp;import&nbsp;array,&nbsp;linalg,&nbsp;dot<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;array([[1,-2j],[2j,5]])<br>
&gt;&gt;&gt;&nbsp;L&nbsp;=&nbsp;linalg.<a href="#-cholesky">cholesky</a>(a,&nbsp;lower=True)<br>
&gt;&gt;&gt;&nbsp;L<br>
array([[&nbsp;1.+0.j,&nbsp;&nbsp;0.+0.j],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.+2.j,&nbsp;&nbsp;1.+0.j]])<br>
&gt;&gt;&gt;&nbsp;dot(L,&nbsp;L.T.conj())<br>
array([[&nbsp;1.+0.j,&nbsp;&nbsp;0.-2.j],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.+2.j,&nbsp;&nbsp;5.+0.j]])</tt></dd></dl>
 <dl><dt><a name="-cholesky_banded"><strong>cholesky_banded</strong></a>(ab, overwrite_ab<font color="#909090">=False</font>, lower<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Cholesky&nbsp;decompose&nbsp;a&nbsp;banded&nbsp;Hermitian&nbsp;positive-definite&nbsp;matrix<br>
&nbsp;<br>
The&nbsp;matrix&nbsp;a&nbsp;is&nbsp;stored&nbsp;in&nbsp;ab&nbsp;either&nbsp;in&nbsp;lower&nbsp;diagonal&nbsp;or&nbsp;upper<br>
diagonal&nbsp;ordered&nbsp;form::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;ab[u&nbsp;+&nbsp;i&nbsp;-&nbsp;j,&nbsp;j]&nbsp;==&nbsp;a[i,j]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;upper&nbsp;form;&nbsp;i&nbsp;&lt;=&nbsp;j)<br>
&nbsp;&nbsp;&nbsp;&nbsp;ab[&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;-&nbsp;j,&nbsp;j]&nbsp;==&nbsp;a[i,j]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;lower&nbsp;form;&nbsp;i&nbsp;&gt;=&nbsp;j)<br>
&nbsp;<br>
Example&nbsp;of&nbsp;ab&nbsp;(shape&nbsp;of&nbsp;a&nbsp;is&nbsp;(6,6),&nbsp;u=2)::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;upper&nbsp;form:<br>
&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;a02&nbsp;a13&nbsp;a24&nbsp;a35<br>
&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;a01&nbsp;a12&nbsp;a23&nbsp;a34&nbsp;a45<br>
&nbsp;&nbsp;&nbsp;&nbsp;a00&nbsp;a11&nbsp;a22&nbsp;a33&nbsp;a44&nbsp;a55<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;lower&nbsp;form:<br>
&nbsp;&nbsp;&nbsp;&nbsp;a00&nbsp;a11&nbsp;a22&nbsp;a33&nbsp;a44&nbsp;a55<br>
&nbsp;&nbsp;&nbsp;&nbsp;a10&nbsp;a21&nbsp;a32&nbsp;a43&nbsp;a54&nbsp;*<br>
&nbsp;&nbsp;&nbsp;&nbsp;a20&nbsp;a31&nbsp;a42&nbsp;a53&nbsp;*&nbsp;&nbsp;&nbsp;*<br>
&nbsp;<br>
Parameters<br>
----------<br>
ab&nbsp;:&nbsp;(u&nbsp;+&nbsp;1,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Banded&nbsp;matrix<br>
overwrite_ab&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Discard&nbsp;data&nbsp;in&nbsp;ab&nbsp;(may&nbsp;enhance&nbsp;performance)<br>
lower&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Is&nbsp;the&nbsp;matrix&nbsp;in&nbsp;the&nbsp;lower&nbsp;form.&nbsp;(Default&nbsp;is&nbsp;upper&nbsp;form)<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
c&nbsp;:&nbsp;(u&nbsp;+&nbsp;1,&nbsp;M)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Cholesky&nbsp;factorization&nbsp;of&nbsp;a,&nbsp;in&nbsp;the&nbsp;same&nbsp;banded&nbsp;format&nbsp;as&nbsp;ab</tt></dd></dl>
 <dl><dt><a name="-circulant"><strong>circulant</strong></a>(c)</dt><dd><tt>Construct&nbsp;a&nbsp;circulant&nbsp;matrix.<br>
&nbsp;<br>
Parameters<br>
----------<br>
c&nbsp;:&nbsp;(N,)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;1-D&nbsp;array,&nbsp;the&nbsp;first&nbsp;column&nbsp;of&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Returns<br>
-------<br>
A&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;circulant&nbsp;matrix&nbsp;whose&nbsp;first&nbsp;column&nbsp;is&nbsp;`c`.<br>
&nbsp;<br>
See&nbsp;also<br>
--------<br>
toeplitz&nbsp;:&nbsp;Toeplitz&nbsp;matrix<br>
hankel&nbsp;:&nbsp;Hankel&nbsp;matrix<br>
&nbsp;<br>
Notes<br>
-----<br>
..&nbsp;versionadded::&nbsp;0.8.0<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;circulant<br>
&gt;&gt;&gt;&nbsp;<a href="#-circulant">circulant</a>([1,&nbsp;2,&nbsp;3])<br>
array([[1,&nbsp;3,&nbsp;2],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[2,&nbsp;1,&nbsp;3],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,&nbsp;2,&nbsp;1]])</tt></dd></dl>
 <dl><dt><a name="-companion"><strong>companion</strong></a>(a)</dt><dd><tt>Create&nbsp;a&nbsp;companion&nbsp;matrix.<br>
&nbsp;<br>
Create&nbsp;the&nbsp;companion&nbsp;matrix&nbsp;[1]_&nbsp;associated&nbsp;with&nbsp;the&nbsp;polynomial&nbsp;whose<br>
coefficients&nbsp;are&nbsp;given&nbsp;in&nbsp;`a`.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(N,)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;1-D&nbsp;array&nbsp;of&nbsp;polynomial&nbsp;coefficients.&nbsp;&nbsp;The&nbsp;length&nbsp;of&nbsp;`a`&nbsp;must&nbsp;be<br>
&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;least&nbsp;two,&nbsp;and&nbsp;``a[0]``&nbsp;must&nbsp;not&nbsp;be&nbsp;zero.<br>
&nbsp;<br>
Returns<br>
-------<br>
c&nbsp;:&nbsp;(N-1,&nbsp;N-1)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;first&nbsp;row&nbsp;of&nbsp;`c`&nbsp;is&nbsp;``-a[1:]/a[0]``,&nbsp;and&nbsp;the&nbsp;first<br>
&nbsp;&nbsp;&nbsp;&nbsp;sub-diagonal&nbsp;is&nbsp;all&nbsp;ones.&nbsp;&nbsp;The&nbsp;data-type&nbsp;of&nbsp;the&nbsp;array&nbsp;is&nbsp;the&nbsp;same<br>
&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;the&nbsp;data-type&nbsp;of&nbsp;``1.0*a[0]``.<br>
&nbsp;<br>
Raises<br>
------<br>
ValueError<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;any&nbsp;of&nbsp;the&nbsp;following&nbsp;are&nbsp;true:&nbsp;a)&nbsp;``a.ndim&nbsp;!=&nbsp;1``;<br>
&nbsp;&nbsp;&nbsp;&nbsp;b)&nbsp;``a.size&nbsp;&lt;&nbsp;2``;&nbsp;c)&nbsp;``a[0]&nbsp;==&nbsp;0``.<br>
&nbsp;<br>
Notes<br>
-----<br>
..&nbsp;versionadded::&nbsp;0.8.0<br>
&nbsp;<br>
References<br>
----------<br>
..&nbsp;[1]&nbsp;R.&nbsp;A.&nbsp;Horn&nbsp;&amp;&nbsp;C.&nbsp;R.&nbsp;Johnson,&nbsp;*Matrix&nbsp;Analysis*.&nbsp;&nbsp;Cambridge,&nbsp;UK:<br>
&nbsp;&nbsp;&nbsp;&nbsp;Cambridge&nbsp;University&nbsp;Press,&nbsp;1999,&nbsp;pp.&nbsp;146-7.<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;companion<br>
&gt;&gt;&gt;&nbsp;<a href="#-companion">companion</a>([1,&nbsp;-10,&nbsp;31,&nbsp;-30])<br>
array([[&nbsp;10.,&nbsp;-31.,&nbsp;&nbsp;30.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;1.,&nbsp;&nbsp;&nbsp;0.,&nbsp;&nbsp;&nbsp;0.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.,&nbsp;&nbsp;&nbsp;1.,&nbsp;&nbsp;&nbsp;0.]])</tt></dd></dl>
 <dl><dt><a name="-coshm"><strong>coshm</strong></a>(A)</dt><dd><tt>Compute&nbsp;the&nbsp;hyperbolic&nbsp;matrix&nbsp;cosine.<br>
&nbsp;<br>
This&nbsp;routine&nbsp;uses&nbsp;expm&nbsp;to&nbsp;compute&nbsp;the&nbsp;matrix&nbsp;exponentials.<br>
&nbsp;<br>
Parameters<br>
----------<br>
A&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Input&nbsp;array.<br>
&nbsp;<br>
Returns<br>
-------<br>
coshm&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Hyperbolic&nbsp;matrix&nbsp;cosine&nbsp;of&nbsp;`A`<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;tanhm,&nbsp;sinhm,&nbsp;coshm<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([[1.0,&nbsp;3.0],&nbsp;[1.0,&nbsp;4.0]])<br>
&gt;&gt;&gt;&nbsp;c&nbsp;=&nbsp;<a href="#-coshm">coshm</a>(a)<br>
&gt;&gt;&gt;&nbsp;c<br>
array([[&nbsp;11.24592233,&nbsp;&nbsp;38.76236492],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;12.92078831,&nbsp;&nbsp;50.00828725]])<br>
&nbsp;<br>
Verify&nbsp;<a href="#-tanhm">tanhm</a>(a)&nbsp;=&nbsp;<a href="#-sinhm">sinhm</a>(a).dot(<a href="#-inv">inv</a>(<a href="#-coshm">coshm</a>(a)))<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;t&nbsp;=&nbsp;<a href="#-tanhm">tanhm</a>(a)<br>
&gt;&gt;&gt;&nbsp;s&nbsp;=&nbsp;<a href="#-sinhm">sinhm</a>(a)<br>
&gt;&gt;&gt;&nbsp;t&nbsp;-&nbsp;s.dot(np.linalg.<a href="#-inv">inv</a>(c))<br>
array([[&nbsp;&nbsp;2.72004641e-15,&nbsp;&nbsp;&nbsp;4.55191440e-15],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.00000000e+00,&nbsp;&nbsp;-5.55111512e-16]])</tt></dd></dl>
 <dl><dt><a name="-cosm"><strong>cosm</strong></a>(A)</dt><dd><tt>Compute&nbsp;the&nbsp;matrix&nbsp;cosine.<br>
&nbsp;<br>
This&nbsp;routine&nbsp;uses&nbsp;expm&nbsp;to&nbsp;compute&nbsp;the&nbsp;matrix&nbsp;exponentials.<br>
&nbsp;<br>
Parameters<br>
----------<br>
A&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Input&nbsp;array<br>
&nbsp;<br>
Returns<br>
-------<br>
cosm&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;cosine&nbsp;of&nbsp;A<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;expm,&nbsp;sinm,&nbsp;cosm<br>
&nbsp;<br>
Euler's&nbsp;identity&nbsp;(exp(i*theta)&nbsp;=&nbsp;cos(theta)&nbsp;+&nbsp;i*sin(theta))<br>
applied&nbsp;to&nbsp;a&nbsp;matrix:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([[1.0,&nbsp;2.0],&nbsp;[-1.0,&nbsp;3.0]])<br>
&gt;&gt;&gt;&nbsp;<a href="#-expm">expm</a>(1j*a)<br>
array([[&nbsp;0.42645930+1.89217551j,&nbsp;-2.13721484-0.97811252j],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.06860742+0.48905626j,&nbsp;-1.71075555+0.91406299j]])<br>
&gt;&gt;&gt;&nbsp;<a href="#-cosm">cosm</a>(a)&nbsp;+&nbsp;1j*<a href="#-sinm">sinm</a>(a)<br>
array([[&nbsp;0.42645930+1.89217551j,&nbsp;-2.13721484-0.97811252j],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.06860742+0.48905626j,&nbsp;-1.71075555+0.91406299j]])</tt></dd></dl>
 <dl><dt><a name="-det"><strong>det</strong></a>(a, overwrite_a<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Compute&nbsp;the&nbsp;determinant&nbsp;of&nbsp;a&nbsp;matrix<br>
&nbsp;<br>
The&nbsp;determinant&nbsp;of&nbsp;a&nbsp;square&nbsp;matrix&nbsp;is&nbsp;a&nbsp;value&nbsp;derived&nbsp;arithmetically<br>
from&nbsp;the&nbsp;coefficients&nbsp;of&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
The&nbsp;determinant&nbsp;for&nbsp;a&nbsp;3x3&nbsp;matrix,&nbsp;for&nbsp;example,&nbsp;is&nbsp;computed&nbsp;as&nbsp;follows::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;&nbsp;c<br>
&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;&nbsp;&nbsp;&nbsp;e&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;A<br>
&nbsp;&nbsp;&nbsp;&nbsp;g&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;&nbsp;&nbsp;&nbsp;i<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#-det">det</a>(A)&nbsp;=&nbsp;a*e*i&nbsp;+&nbsp;b*f*g&nbsp;+&nbsp;c*d*h&nbsp;-&nbsp;c*e*g&nbsp;-&nbsp;b*d*i&nbsp;-&nbsp;a*f*h<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;square&nbsp;matrix.<br>
overwrite_a&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Allow&nbsp;overwriting&nbsp;data&nbsp;in&nbsp;a&nbsp;(may&nbsp;enhance&nbsp;performance).<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
det&nbsp;:&nbsp;float&nbsp;or&nbsp;complex<br>
&nbsp;&nbsp;&nbsp;&nbsp;Determinant&nbsp;of&nbsp;`a`.<br>
&nbsp;<br>
Notes<br>
-----<br>
The&nbsp;determinant&nbsp;is&nbsp;computed&nbsp;via&nbsp;LU&nbsp;factorization,&nbsp;LAPACK&nbsp;routine&nbsp;z/dgetrf.<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy&nbsp;import&nbsp;linalg<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([[1,2,3],&nbsp;[4,5,6],&nbsp;[7,8,9]])<br>
&gt;&gt;&gt;&nbsp;linalg.<a href="#-det">det</a>(a)<br>
0.0<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([[0,2,3],&nbsp;[4,5,6],&nbsp;[7,8,9]])<br>
&gt;&gt;&gt;&nbsp;linalg.<a href="#-det">det</a>(a)<br>
3.0</tt></dd></dl>
 <dl><dt><a name="-dft"><strong>dft</strong></a>(n, scale<font color="#909090">=None</font>)</dt><dd><tt>Discrete&nbsp;Fourier&nbsp;transform&nbsp;matrix.<br>
&nbsp;<br>
Create&nbsp;the&nbsp;matrix&nbsp;that&nbsp;computes&nbsp;the&nbsp;discrete&nbsp;Fourier&nbsp;transform&nbsp;of&nbsp;a<br>
sequence&nbsp;[1]_.&nbsp;&nbsp;The&nbsp;n-th&nbsp;primitive&nbsp;root&nbsp;of&nbsp;unity&nbsp;used&nbsp;to&nbsp;generate&nbsp;the<br>
matrix&nbsp;is&nbsp;exp(-2*pi*i/n),&nbsp;where&nbsp;i&nbsp;=&nbsp;sqrt(-1).<br>
&nbsp;<br>
Parameters<br>
----------<br>
n&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;Size&nbsp;the&nbsp;matrix&nbsp;to&nbsp;create.<br>
scale&nbsp;:&nbsp;str,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Must&nbsp;be&nbsp;None,&nbsp;'sqrtn',&nbsp;or&nbsp;'n'.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;`scale`&nbsp;is&nbsp;'sqrtn',&nbsp;the&nbsp;matrix&nbsp;is&nbsp;divided&nbsp;by&nbsp;`sqrt(n)`.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;`scale`&nbsp;is&nbsp;'n',&nbsp;the&nbsp;matrix&nbsp;is&nbsp;divided&nbsp;by&nbsp;`n`.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;`scale`&nbsp;is&nbsp;None&nbsp;(the&nbsp;default),&nbsp;the&nbsp;matrix&nbsp;is&nbsp;not&nbsp;normalized,&nbsp;and&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;value&nbsp;is&nbsp;simply&nbsp;the&nbsp;Vandermonde&nbsp;matrix&nbsp;of&nbsp;the&nbsp;roots&nbsp;of&nbsp;unity.<br>
&nbsp;<br>
Returns<br>
-------<br>
m&nbsp;:&nbsp;(n,&nbsp;n)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;DFT&nbsp;matrix.<br>
&nbsp;<br>
Notes<br>
-----<br>
When&nbsp;`scale`&nbsp;is&nbsp;None,&nbsp;multiplying&nbsp;a&nbsp;vector&nbsp;by&nbsp;the&nbsp;matrix&nbsp;returned&nbsp;by<br>
`dft`&nbsp;is&nbsp;mathematically&nbsp;equivalent&nbsp;to&nbsp;(but&nbsp;much&nbsp;less&nbsp;efficient&nbsp;than)<br>
the&nbsp;calculation&nbsp;performed&nbsp;by&nbsp;`scipy.fftpack.fft`.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.14.0<br>
&nbsp;<br>
References<br>
----------<br>
..&nbsp;[1]&nbsp;"DFT&nbsp;matrix",&nbsp;<a href="http://en.wikipedia.org/wiki/DFT_matrix">http://en.wikipedia.org/wiki/DFT_matrix</a><br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;dft<br>
&gt;&gt;&gt;&nbsp;np.set_printoptions(precision=5,&nbsp;suppress=True)<br>
&gt;&gt;&gt;&nbsp;x&nbsp;=&nbsp;np.array([1,&nbsp;2,&nbsp;3,&nbsp;0,&nbsp;3,&nbsp;2,&nbsp;1,&nbsp;0])<br>
&gt;&gt;&gt;&nbsp;m&nbsp;=&nbsp;<a href="#-dft">dft</a>(8)<br>
&gt;&gt;&gt;&nbsp;m.dot(x)&nbsp;&nbsp;&nbsp;#&nbsp;Compute&nbsp;the&nbsp;DFT&nbsp;of&nbsp;x<br>
array([&nbsp;12.+0.j,&nbsp;&nbsp;-2.-2.j,&nbsp;&nbsp;&nbsp;0.-4.j,&nbsp;&nbsp;-2.+2.j,&nbsp;&nbsp;&nbsp;4.+0.j,&nbsp;&nbsp;-2.-2.j,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-0.+4.j,&nbsp;&nbsp;-2.+2.j])<br>
&nbsp;<br>
Verify&nbsp;that&nbsp;``m.dot(x)``&nbsp;is&nbsp;the&nbsp;same&nbsp;as&nbsp;``fft(x)``.<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.fftpack&nbsp;import&nbsp;fft<br>
&gt;&gt;&gt;&nbsp;fft(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Same&nbsp;result&nbsp;as&nbsp;m.dot(x)<br>
array([&nbsp;12.+0.j,&nbsp;&nbsp;-2.-2.j,&nbsp;&nbsp;&nbsp;0.-4.j,&nbsp;&nbsp;-2.+2.j,&nbsp;&nbsp;&nbsp;4.+0.j,&nbsp;&nbsp;-2.-2.j,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.+4.j,&nbsp;&nbsp;-2.+2.j])</tt></dd></dl>
 <dl><dt><a name="-diagsvd"><strong>diagsvd</strong></a>(s, M, N)</dt><dd><tt>Construct&nbsp;the&nbsp;sigma&nbsp;matrix&nbsp;in&nbsp;SVD&nbsp;from&nbsp;singular&nbsp;values&nbsp;and&nbsp;size&nbsp;M,&nbsp;N.<br>
&nbsp;<br>
Parameters<br>
----------<br>
s&nbsp;:&nbsp;(M,)&nbsp;or&nbsp;(N,)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Singular&nbsp;values<br>
M&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;Size&nbsp;of&nbsp;the&nbsp;matrix&nbsp;whose&nbsp;singular&nbsp;values&nbsp;are&nbsp;`s`.<br>
N&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;Size&nbsp;of&nbsp;the&nbsp;matrix&nbsp;whose&nbsp;singular&nbsp;values&nbsp;are&nbsp;`s`.<br>
&nbsp;<br>
Returns<br>
-------<br>
S&nbsp;:&nbsp;(M,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;S-matrix&nbsp;in&nbsp;the&nbsp;singular&nbsp;value&nbsp;decomposition</tt></dd></dl>
 <dl><dt><a name="-eig"><strong>eig</strong></a>(a, b<font color="#909090">=None</font>, left<font color="#909090">=False</font>, right<font color="#909090">=True</font>, overwrite_a<font color="#909090">=False</font>, overwrite_b<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Solve&nbsp;an&nbsp;ordinary&nbsp;or&nbsp;generalized&nbsp;eigenvalue&nbsp;problem&nbsp;of&nbsp;a&nbsp;square&nbsp;matrix.<br>
&nbsp;<br>
Find&nbsp;eigenvalues&nbsp;w&nbsp;and&nbsp;right&nbsp;or&nbsp;left&nbsp;eigenvectors&nbsp;of&nbsp;a&nbsp;general&nbsp;matrix::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;&nbsp;&nbsp;vr[:,i]&nbsp;=&nbsp;w[i]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;vr[:,i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;a.H&nbsp;vl[:,i]&nbsp;=&nbsp;w[i].conj()&nbsp;b.H&nbsp;vl[:,i]<br>
&nbsp;<br>
where&nbsp;``.H``&nbsp;is&nbsp;the&nbsp;Hermitian&nbsp;conjugation.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;complex&nbsp;or&nbsp;real&nbsp;matrix&nbsp;whose&nbsp;eigenvalues&nbsp;and&nbsp;eigenvectors<br>
&nbsp;&nbsp;&nbsp;&nbsp;will&nbsp;be&nbsp;computed.<br>
b&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Right-hand&nbsp;side&nbsp;matrix&nbsp;in&nbsp;a&nbsp;generalized&nbsp;eigenvalue&nbsp;problem.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Default&nbsp;is&nbsp;None,&nbsp;identity&nbsp;matrix&nbsp;is&nbsp;assumed.<br>
left&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;calculate&nbsp;and&nbsp;return&nbsp;left&nbsp;eigenvectors.&nbsp;&nbsp;Default&nbsp;is&nbsp;False.<br>
right&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;calculate&nbsp;and&nbsp;return&nbsp;right&nbsp;eigenvectors.&nbsp;&nbsp;Default&nbsp;is&nbsp;True.<br>
overwrite_a&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;overwrite&nbsp;`a`;&nbsp;may&nbsp;improve&nbsp;performance.&nbsp;&nbsp;Default&nbsp;is&nbsp;False.<br>
overwrite_b&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;overwrite&nbsp;`b`;&nbsp;may&nbsp;improve&nbsp;performance.&nbsp;&nbsp;Default&nbsp;is&nbsp;False.<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrices&nbsp;contain&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
w&nbsp;:&nbsp;(M,)&nbsp;double&nbsp;or&nbsp;complex&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;eigenvalues,&nbsp;each&nbsp;repeated&nbsp;according&nbsp;to&nbsp;its&nbsp;multiplicity.<br>
vl&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;double&nbsp;or&nbsp;complex&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;normalized&nbsp;left&nbsp;eigenvector&nbsp;corresponding&nbsp;to&nbsp;the&nbsp;eigenvalue<br>
&nbsp;&nbsp;&nbsp;&nbsp;``w[i]``&nbsp;is&nbsp;the&nbsp;column&nbsp;vl[:,i].&nbsp;Only&nbsp;returned&nbsp;if&nbsp;``left=True``.<br>
vr&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;double&nbsp;or&nbsp;complex&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;normalized&nbsp;right&nbsp;eigenvector&nbsp;corresponding&nbsp;to&nbsp;the&nbsp;eigenvalue<br>
&nbsp;&nbsp;&nbsp;&nbsp;``w[i]``&nbsp;is&nbsp;the&nbsp;column&nbsp;``vr[:,i]``.&nbsp;&nbsp;Only&nbsp;returned&nbsp;if&nbsp;``right=True``.<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;eigenvalue&nbsp;computation&nbsp;does&nbsp;not&nbsp;converge.<br>
&nbsp;<br>
See&nbsp;Also<br>
--------<br>
eigh&nbsp;:&nbsp;Eigenvalues&nbsp;and&nbsp;right&nbsp;eigenvectors&nbsp;for&nbsp;symmetric/Hermitian&nbsp;arrays.</tt></dd></dl>
 <dl><dt><a name="-eig_banded"><strong>eig_banded</strong></a>(a_band, lower<font color="#909090">=False</font>, eigvals_only<font color="#909090">=False</font>, overwrite_a_band<font color="#909090">=False</font>, select<font color="#909090">='a'</font>, select_range<font color="#909090">=None</font>, max_ev<font color="#909090">=0</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Solve&nbsp;real&nbsp;symmetric&nbsp;or&nbsp;complex&nbsp;hermitian&nbsp;band&nbsp;matrix&nbsp;eigenvalue&nbsp;problem.<br>
&nbsp;<br>
Find&nbsp;eigenvalues&nbsp;w&nbsp;and&nbsp;optionally&nbsp;right&nbsp;eigenvectors&nbsp;v&nbsp;of&nbsp;a::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;v[:,i]&nbsp;=&nbsp;w[i]&nbsp;v[:,i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;v.H&nbsp;v&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;identity<br>
&nbsp;<br>
The&nbsp;matrix&nbsp;a&nbsp;is&nbsp;stored&nbsp;in&nbsp;a_band&nbsp;either&nbsp;in&nbsp;lower&nbsp;diagonal&nbsp;or&nbsp;upper<br>
diagonal&nbsp;ordered&nbsp;form:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;a_band[u&nbsp;+&nbsp;i&nbsp;-&nbsp;j,&nbsp;j]&nbsp;==&nbsp;a[i,j]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;upper&nbsp;form;&nbsp;i&nbsp;&lt;=&nbsp;j)<br>
&nbsp;&nbsp;&nbsp;&nbsp;a_band[&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;-&nbsp;j,&nbsp;j]&nbsp;==&nbsp;a[i,j]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;lower&nbsp;form;&nbsp;i&nbsp;&gt;=&nbsp;j)<br>
&nbsp;<br>
where&nbsp;u&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;bands&nbsp;above&nbsp;the&nbsp;diagonal.<br>
&nbsp;<br>
Example&nbsp;of&nbsp;a_band&nbsp;(shape&nbsp;of&nbsp;a&nbsp;is&nbsp;(6,6),&nbsp;u=2)::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;upper&nbsp;form:<br>
&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;a02&nbsp;a13&nbsp;a24&nbsp;a35<br>
&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;a01&nbsp;a12&nbsp;a23&nbsp;a34&nbsp;a45<br>
&nbsp;&nbsp;&nbsp;&nbsp;a00&nbsp;a11&nbsp;a22&nbsp;a33&nbsp;a44&nbsp;a55<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;lower&nbsp;form:<br>
&nbsp;&nbsp;&nbsp;&nbsp;a00&nbsp;a11&nbsp;a22&nbsp;a33&nbsp;a44&nbsp;a55<br>
&nbsp;&nbsp;&nbsp;&nbsp;a10&nbsp;a21&nbsp;a32&nbsp;a43&nbsp;a54&nbsp;*<br>
&nbsp;&nbsp;&nbsp;&nbsp;a20&nbsp;a31&nbsp;a42&nbsp;a53&nbsp;*&nbsp;&nbsp;&nbsp;*<br>
&nbsp;<br>
Cells&nbsp;marked&nbsp;with&nbsp;*&nbsp;are&nbsp;not&nbsp;used.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a_band&nbsp;:&nbsp;(u+1,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;bands&nbsp;of&nbsp;the&nbsp;M&nbsp;by&nbsp;M&nbsp;matrix&nbsp;a.<br>
lower&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Is&nbsp;the&nbsp;matrix&nbsp;in&nbsp;the&nbsp;lower&nbsp;form.&nbsp;(Default&nbsp;is&nbsp;upper&nbsp;form)<br>
eigvals_only&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Compute&nbsp;only&nbsp;the&nbsp;eigenvalues&nbsp;and&nbsp;no&nbsp;eigenvectors.<br>
&nbsp;&nbsp;&nbsp;&nbsp;(Default:&nbsp;calculate&nbsp;also&nbsp;eigenvectors)<br>
overwrite_a_band&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Discard&nbsp;data&nbsp;in&nbsp;a_band&nbsp;(may&nbsp;enhance&nbsp;performance)<br>
select&nbsp;:&nbsp;{'a',&nbsp;'v',&nbsp;'i'},&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Which&nbsp;eigenvalues&nbsp;to&nbsp;calculate<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;======&nbsp;&nbsp;========================================<br>
&nbsp;&nbsp;&nbsp;&nbsp;select&nbsp;&nbsp;calculated<br>
&nbsp;&nbsp;&nbsp;&nbsp;======&nbsp;&nbsp;========================================<br>
&nbsp;&nbsp;&nbsp;&nbsp;'a'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;All&nbsp;eigenvalues<br>
&nbsp;&nbsp;&nbsp;&nbsp;'v'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Eigenvalues&nbsp;in&nbsp;the&nbsp;interval&nbsp;(min,&nbsp;max]<br>
&nbsp;&nbsp;&nbsp;&nbsp;'i'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Eigenvalues&nbsp;with&nbsp;indices&nbsp;min&nbsp;&lt;=&nbsp;i&nbsp;&lt;=&nbsp;max<br>
&nbsp;&nbsp;&nbsp;&nbsp;======&nbsp;&nbsp;========================================<br>
select_range&nbsp;:&nbsp;(min,&nbsp;max),&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Range&nbsp;of&nbsp;selected&nbsp;eigenvalues<br>
max_ev&nbsp;:&nbsp;int,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;For&nbsp;select=='v',&nbsp;maximum&nbsp;number&nbsp;of&nbsp;eigenvalues&nbsp;expected.<br>
&nbsp;&nbsp;&nbsp;&nbsp;For&nbsp;other&nbsp;values&nbsp;of&nbsp;select,&nbsp;has&nbsp;no&nbsp;meaning.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;In&nbsp;doubt,&nbsp;leave&nbsp;this&nbsp;parameter&nbsp;untouched.<br>
&nbsp;<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
w&nbsp;:&nbsp;(M,)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;eigenvalues,&nbsp;in&nbsp;ascending&nbsp;order,&nbsp;each&nbsp;repeated&nbsp;according&nbsp;to&nbsp;its<br>
&nbsp;&nbsp;&nbsp;&nbsp;multiplicity.<br>
v&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;float&nbsp;or&nbsp;complex&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;normalized&nbsp;eigenvector&nbsp;corresponding&nbsp;to&nbsp;the&nbsp;eigenvalue&nbsp;w[i]&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;column&nbsp;v[:,i].<br>
&nbsp;<br>
Raises&nbsp;<a href="#LinAlgError">LinAlgError</a>&nbsp;if&nbsp;eigenvalue&nbsp;computation&nbsp;does&nbsp;not&nbsp;converge</tt></dd></dl>
 <dl><dt><a name="-eigh"><strong>eigh</strong></a>(a, b<font color="#909090">=None</font>, lower<font color="#909090">=True</font>, eigvals_only<font color="#909090">=False</font>, overwrite_a<font color="#909090">=False</font>, overwrite_b<font color="#909090">=False</font>, turbo<font color="#909090">=True</font>, eigvals<font color="#909090">=None</font>, type<font color="#909090">=1</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Solve&nbsp;an&nbsp;ordinary&nbsp;or&nbsp;generalized&nbsp;eigenvalue&nbsp;problem&nbsp;for&nbsp;a&nbsp;complex<br>
Hermitian&nbsp;or&nbsp;real&nbsp;symmetric&nbsp;matrix.<br>
&nbsp;<br>
Find&nbsp;eigenvalues&nbsp;w&nbsp;and&nbsp;optionally&nbsp;eigenvectors&nbsp;v&nbsp;of&nbsp;matrix&nbsp;`a`,&nbsp;where<br>
`b`&nbsp;is&nbsp;positive&nbsp;definite::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;v[:,i]&nbsp;=&nbsp;w[i]&nbsp;b&nbsp;v[:,i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;v[i,:].conj()&nbsp;a&nbsp;v[:,i]&nbsp;=&nbsp;w[i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;v[i,:].conj()&nbsp;b&nbsp;v[:,i]&nbsp;=&nbsp;1<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;complex&nbsp;Hermitian&nbsp;or&nbsp;real&nbsp;symmetric&nbsp;matrix&nbsp;whose&nbsp;eigenvalues&nbsp;and<br>
&nbsp;&nbsp;&nbsp;&nbsp;eigenvectors&nbsp;will&nbsp;be&nbsp;computed.<br>
b&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;complex&nbsp;Hermitian&nbsp;or&nbsp;real&nbsp;symmetric&nbsp;definite&nbsp;positive&nbsp;matrix&nbsp;in.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;omitted,&nbsp;identity&nbsp;matrix&nbsp;is&nbsp;assumed.<br>
lower&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;the&nbsp;pertinent&nbsp;array&nbsp;data&nbsp;is&nbsp;taken&nbsp;from&nbsp;the&nbsp;lower&nbsp;or&nbsp;upper<br>
&nbsp;&nbsp;&nbsp;&nbsp;triangle&nbsp;of&nbsp;`a`.&nbsp;(Default:&nbsp;lower)<br>
eigvals_only&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;calculate&nbsp;only&nbsp;eigenvalues&nbsp;and&nbsp;no&nbsp;eigenvectors.<br>
&nbsp;&nbsp;&nbsp;&nbsp;(Default:&nbsp;both&nbsp;are&nbsp;calculated)<br>
turbo&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Use&nbsp;divide&nbsp;and&nbsp;conquer&nbsp;algorithm&nbsp;(faster&nbsp;but&nbsp;expensive&nbsp;in&nbsp;memory,<br>
&nbsp;&nbsp;&nbsp;&nbsp;only&nbsp;for&nbsp;generalized&nbsp;eigenvalue&nbsp;problem&nbsp;and&nbsp;if&nbsp;eigvals=None)<br>
eigvals&nbsp;:&nbsp;tuple&nbsp;(lo,&nbsp;hi),&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Indexes&nbsp;of&nbsp;the&nbsp;smallest&nbsp;and&nbsp;largest&nbsp;(in&nbsp;ascending&nbsp;order)&nbsp;eigenvalues<br>
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;corresponding&nbsp;eigenvectors&nbsp;to&nbsp;be&nbsp;returned:&nbsp;0&nbsp;&lt;=&nbsp;lo&nbsp;&lt;=&nbsp;hi&nbsp;&lt;=&nbsp;M-1.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;omitted,&nbsp;all&nbsp;eigenvalues&nbsp;and&nbsp;eigenvectors&nbsp;are&nbsp;returned.<br>
type&nbsp;:&nbsp;int,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Specifies&nbsp;the&nbsp;problem&nbsp;type&nbsp;to&nbsp;be&nbsp;solved:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;1:&nbsp;a&nbsp;&nbsp;&nbsp;v[:,i]&nbsp;=&nbsp;w[i]&nbsp;b&nbsp;v[:,i]<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;2:&nbsp;a&nbsp;b&nbsp;v[:,i]&nbsp;=&nbsp;w[i]&nbsp;&nbsp;&nbsp;v[:,i]<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;3:&nbsp;b&nbsp;a&nbsp;v[:,i]&nbsp;=&nbsp;w[i]&nbsp;&nbsp;&nbsp;v[:,i]<br>
overwrite_a&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;overwrite&nbsp;data&nbsp;in&nbsp;`a`&nbsp;(may&nbsp;improve&nbsp;performance)<br>
overwrite_b&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;overwrite&nbsp;data&nbsp;in&nbsp;`b`&nbsp;(may&nbsp;improve&nbsp;performance)<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrices&nbsp;contain&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
w&nbsp;:&nbsp;(N,)&nbsp;float&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;(1&lt;=N&lt;=M)&nbsp;selected&nbsp;eigenvalues,&nbsp;in&nbsp;ascending&nbsp;order,&nbsp;each<br>
&nbsp;&nbsp;&nbsp;&nbsp;repeated&nbsp;according&nbsp;to&nbsp;its&nbsp;multiplicity.<br>
v&nbsp;:&nbsp;(M,&nbsp;N)&nbsp;complex&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;eigvals_only&nbsp;==&nbsp;False)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;normalized&nbsp;selected&nbsp;eigenvector&nbsp;corresponding&nbsp;to&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;eigenvalue&nbsp;w[i]&nbsp;is&nbsp;the&nbsp;column&nbsp;v[:,i].<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Normalization:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;1&nbsp;and&nbsp;3:&nbsp;v.conj()&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;&nbsp;=&nbsp;w<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;2:&nbsp;<a href="#-inv">inv</a>(v).conj()&nbsp;a&nbsp;&nbsp;<a href="#-inv">inv</a>(v)&nbsp;=&nbsp;w<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;1&nbsp;or&nbsp;2:&nbsp;v.conj()&nbsp;b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;&nbsp;=&nbsp;I<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;3:&nbsp;v.conj()&nbsp;<a href="#-inv">inv</a>(b)&nbsp;v&nbsp;&nbsp;=&nbsp;I<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;eigenvalue&nbsp;computation&nbsp;does&nbsp;not&nbsp;converge,<br>
&nbsp;&nbsp;&nbsp;&nbsp;an&nbsp;error&nbsp;occurred,&nbsp;or&nbsp;b&nbsp;matrix&nbsp;is&nbsp;not&nbsp;definite&nbsp;positive.&nbsp;Note&nbsp;that<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;input&nbsp;matrices&nbsp;are&nbsp;not&nbsp;symmetric&nbsp;or&nbsp;hermitian,&nbsp;no&nbsp;error&nbsp;is&nbsp;reported<br>
&nbsp;&nbsp;&nbsp;&nbsp;but&nbsp;results&nbsp;will&nbsp;be&nbsp;wrong.<br>
&nbsp;<br>
See&nbsp;Also<br>
--------<br>
eig&nbsp;:&nbsp;eigenvalues&nbsp;and&nbsp;right&nbsp;eigenvectors&nbsp;for&nbsp;non-symmetric&nbsp;arrays</tt></dd></dl>
 <dl><dt><a name="-eigvals"><strong>eigvals</strong></a>(a, b<font color="#909090">=None</font>, overwrite_a<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Compute&nbsp;eigenvalues&nbsp;from&nbsp;an&nbsp;ordinary&nbsp;or&nbsp;generalized&nbsp;eigenvalue&nbsp;problem.<br>
&nbsp;<br>
Find&nbsp;eigenvalues&nbsp;of&nbsp;a&nbsp;general&nbsp;matrix::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;&nbsp;&nbsp;vr[:,i]&nbsp;=&nbsp;w[i]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;vr[:,i]<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;complex&nbsp;or&nbsp;real&nbsp;matrix&nbsp;whose&nbsp;eigenvalues&nbsp;and&nbsp;eigenvectors<br>
&nbsp;&nbsp;&nbsp;&nbsp;will&nbsp;be&nbsp;computed.<br>
b&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Right-hand&nbsp;side&nbsp;matrix&nbsp;in&nbsp;a&nbsp;generalized&nbsp;eigenvalue&nbsp;problem.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;omitted,&nbsp;identity&nbsp;matrix&nbsp;is&nbsp;assumed.<br>
overwrite_a&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;overwrite&nbsp;data&nbsp;in&nbsp;a&nbsp;(may&nbsp;improve&nbsp;performance)<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrices&nbsp;contain&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
w&nbsp;:&nbsp;(M,)&nbsp;double&nbsp;or&nbsp;complex&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;eigenvalues,&nbsp;each&nbsp;repeated&nbsp;according&nbsp;to&nbsp;its&nbsp;multiplicity,<br>
&nbsp;&nbsp;&nbsp;&nbsp;but&nbsp;not&nbsp;in&nbsp;any&nbsp;specific&nbsp;order.<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;eigenvalue&nbsp;computation&nbsp;does&nbsp;not&nbsp;converge<br>
&nbsp;<br>
See&nbsp;Also<br>
--------<br>
eigvalsh&nbsp;:&nbsp;eigenvalues&nbsp;of&nbsp;symmetric&nbsp;or&nbsp;Hermitian&nbsp;arrays,<br>
eig&nbsp;:&nbsp;eigenvalues&nbsp;and&nbsp;right&nbsp;eigenvectors&nbsp;of&nbsp;general&nbsp;arrays.<br>
eigh&nbsp;:&nbsp;eigenvalues&nbsp;and&nbsp;eigenvectors&nbsp;of&nbsp;symmetric/Hermitian&nbsp;arrays.</tt></dd></dl>
 <dl><dt><a name="-eigvals_banded"><strong>eigvals_banded</strong></a>(a_band, lower<font color="#909090">=False</font>, overwrite_a_band<font color="#909090">=False</font>, select<font color="#909090">='a'</font>, select_range<font color="#909090">=None</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Solve&nbsp;real&nbsp;symmetric&nbsp;or&nbsp;complex&nbsp;hermitian&nbsp;band&nbsp;matrix&nbsp;eigenvalue&nbsp;problem.<br>
&nbsp;<br>
Find&nbsp;eigenvalues&nbsp;w&nbsp;of&nbsp;a::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;v[:,i]&nbsp;=&nbsp;w[i]&nbsp;v[:,i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;v.H&nbsp;v&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;identity<br>
&nbsp;<br>
The&nbsp;matrix&nbsp;a&nbsp;is&nbsp;stored&nbsp;in&nbsp;a_band&nbsp;either&nbsp;in&nbsp;lower&nbsp;diagonal&nbsp;or&nbsp;upper<br>
diagonal&nbsp;ordered&nbsp;form:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;a_band[u&nbsp;+&nbsp;i&nbsp;-&nbsp;j,&nbsp;j]&nbsp;==&nbsp;a[i,j]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;upper&nbsp;form;&nbsp;i&nbsp;&lt;=&nbsp;j)<br>
&nbsp;&nbsp;&nbsp;&nbsp;a_band[&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;-&nbsp;j,&nbsp;j]&nbsp;==&nbsp;a[i,j]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;lower&nbsp;form;&nbsp;i&nbsp;&gt;=&nbsp;j)<br>
&nbsp;<br>
where&nbsp;u&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;bands&nbsp;above&nbsp;the&nbsp;diagonal.<br>
&nbsp;<br>
Example&nbsp;of&nbsp;a_band&nbsp;(shape&nbsp;of&nbsp;a&nbsp;is&nbsp;(6,6),&nbsp;u=2)::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;upper&nbsp;form:<br>
&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;a02&nbsp;a13&nbsp;a24&nbsp;a35<br>
&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;a01&nbsp;a12&nbsp;a23&nbsp;a34&nbsp;a45<br>
&nbsp;&nbsp;&nbsp;&nbsp;a00&nbsp;a11&nbsp;a22&nbsp;a33&nbsp;a44&nbsp;a55<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;lower&nbsp;form:<br>
&nbsp;&nbsp;&nbsp;&nbsp;a00&nbsp;a11&nbsp;a22&nbsp;a33&nbsp;a44&nbsp;a55<br>
&nbsp;&nbsp;&nbsp;&nbsp;a10&nbsp;a21&nbsp;a32&nbsp;a43&nbsp;a54&nbsp;*<br>
&nbsp;&nbsp;&nbsp;&nbsp;a20&nbsp;a31&nbsp;a42&nbsp;a53&nbsp;*&nbsp;&nbsp;&nbsp;*<br>
&nbsp;<br>
Cells&nbsp;marked&nbsp;with&nbsp;*&nbsp;are&nbsp;not&nbsp;used.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a_band&nbsp;:&nbsp;(u+1,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;bands&nbsp;of&nbsp;the&nbsp;M&nbsp;by&nbsp;M&nbsp;matrix&nbsp;a.<br>
lower&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Is&nbsp;the&nbsp;matrix&nbsp;in&nbsp;the&nbsp;lower&nbsp;form.&nbsp;(Default&nbsp;is&nbsp;upper&nbsp;form)<br>
overwrite_a_band&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Discard&nbsp;data&nbsp;in&nbsp;a_band&nbsp;(may&nbsp;enhance&nbsp;performance)<br>
select&nbsp;:&nbsp;{'a',&nbsp;'v',&nbsp;'i'},&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Which&nbsp;eigenvalues&nbsp;to&nbsp;calculate<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;======&nbsp;&nbsp;========================================<br>
&nbsp;&nbsp;&nbsp;&nbsp;select&nbsp;&nbsp;calculated<br>
&nbsp;&nbsp;&nbsp;&nbsp;======&nbsp;&nbsp;========================================<br>
&nbsp;&nbsp;&nbsp;&nbsp;'a'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;All&nbsp;eigenvalues<br>
&nbsp;&nbsp;&nbsp;&nbsp;'v'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Eigenvalues&nbsp;in&nbsp;the&nbsp;interval&nbsp;(min,&nbsp;max]<br>
&nbsp;&nbsp;&nbsp;&nbsp;'i'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Eigenvalues&nbsp;with&nbsp;indices&nbsp;min&nbsp;&lt;=&nbsp;i&nbsp;&lt;=&nbsp;max<br>
&nbsp;&nbsp;&nbsp;&nbsp;======&nbsp;&nbsp;========================================<br>
select_range&nbsp;:&nbsp;(min,&nbsp;max),&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Range&nbsp;of&nbsp;selected&nbsp;eigenvalues<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
w&nbsp;:&nbsp;(M,)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;eigenvalues,&nbsp;in&nbsp;ascending&nbsp;order,&nbsp;each&nbsp;repeated&nbsp;according&nbsp;to&nbsp;its<br>
&nbsp;&nbsp;&nbsp;&nbsp;multiplicity.<br>
&nbsp;<br>
Raises&nbsp;<a href="#LinAlgError">LinAlgError</a>&nbsp;if&nbsp;eigenvalue&nbsp;computation&nbsp;does&nbsp;not&nbsp;converge<br>
&nbsp;<br>
See&nbsp;Also<br>
--------<br>
eig_banded&nbsp;:&nbsp;eigenvalues&nbsp;and&nbsp;right&nbsp;eigenvectors&nbsp;for&nbsp;symmetric/Hermitian<br>
&nbsp;&nbsp;&nbsp;&nbsp;band&nbsp;matrices<br>
eigvals&nbsp;:&nbsp;eigenvalues&nbsp;of&nbsp;general&nbsp;arrays<br>
eigh&nbsp;:&nbsp;eigenvalues&nbsp;and&nbsp;right&nbsp;eigenvectors&nbsp;for&nbsp;symmetric/Hermitian&nbsp;arrays<br>
eig&nbsp;:&nbsp;eigenvalues&nbsp;and&nbsp;right&nbsp;eigenvectors&nbsp;for&nbsp;non-symmetric&nbsp;arrays</tt></dd></dl>
 <dl><dt><a name="-eigvalsh"><strong>eigvalsh</strong></a>(a, b<font color="#909090">=None</font>, lower<font color="#909090">=True</font>, overwrite_a<font color="#909090">=False</font>, overwrite_b<font color="#909090">=False</font>, turbo<font color="#909090">=True</font>, eigvals<font color="#909090">=None</font>, type<font color="#909090">=1</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Solve&nbsp;an&nbsp;ordinary&nbsp;or&nbsp;generalized&nbsp;eigenvalue&nbsp;problem&nbsp;for&nbsp;a&nbsp;complex<br>
Hermitian&nbsp;or&nbsp;real&nbsp;symmetric&nbsp;matrix.<br>
&nbsp;<br>
Find&nbsp;eigenvalues&nbsp;w&nbsp;of&nbsp;matrix&nbsp;a,&nbsp;where&nbsp;b&nbsp;is&nbsp;positive&nbsp;definite::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;v[:,i]&nbsp;=&nbsp;w[i]&nbsp;b&nbsp;v[:,i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;v[i,:].conj()&nbsp;a&nbsp;v[:,i]&nbsp;=&nbsp;w[i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;v[i,:].conj()&nbsp;b&nbsp;v[:,i]&nbsp;=&nbsp;1<br>
&nbsp;<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;complex&nbsp;Hermitian&nbsp;or&nbsp;real&nbsp;symmetric&nbsp;matrix&nbsp;whose&nbsp;eigenvalues&nbsp;and<br>
&nbsp;&nbsp;&nbsp;&nbsp;eigenvectors&nbsp;will&nbsp;be&nbsp;computed.<br>
b&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;complex&nbsp;Hermitian&nbsp;or&nbsp;real&nbsp;symmetric&nbsp;definite&nbsp;positive&nbsp;matrix&nbsp;in.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;omitted,&nbsp;identity&nbsp;matrix&nbsp;is&nbsp;assumed.<br>
lower&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;the&nbsp;pertinent&nbsp;array&nbsp;data&nbsp;is&nbsp;taken&nbsp;from&nbsp;the&nbsp;lower&nbsp;or&nbsp;upper<br>
&nbsp;&nbsp;&nbsp;&nbsp;triangle&nbsp;of&nbsp;`a`.&nbsp;(Default:&nbsp;lower)<br>
turbo&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Use&nbsp;divide&nbsp;and&nbsp;conquer&nbsp;algorithm&nbsp;(faster&nbsp;but&nbsp;expensive&nbsp;in&nbsp;memory,<br>
&nbsp;&nbsp;&nbsp;&nbsp;only&nbsp;for&nbsp;generalized&nbsp;eigenvalue&nbsp;problem&nbsp;and&nbsp;if&nbsp;eigvals=None)<br>
eigvals&nbsp;:&nbsp;tuple&nbsp;(lo,&nbsp;hi),&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Indexes&nbsp;of&nbsp;the&nbsp;smallest&nbsp;and&nbsp;largest&nbsp;(in&nbsp;ascending&nbsp;order)&nbsp;eigenvalues<br>
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;corresponding&nbsp;eigenvectors&nbsp;to&nbsp;be&nbsp;returned:&nbsp;0&nbsp;&lt;=&nbsp;lo&nbsp;&lt;&nbsp;hi&nbsp;&lt;=&nbsp;M-1.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;omitted,&nbsp;all&nbsp;eigenvalues&nbsp;and&nbsp;eigenvectors&nbsp;are&nbsp;returned.<br>
type&nbsp;:&nbsp;int,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Specifies&nbsp;the&nbsp;problem&nbsp;type&nbsp;to&nbsp;be&nbsp;solved:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;1:&nbsp;a&nbsp;&nbsp;&nbsp;v[:,i]&nbsp;=&nbsp;w[i]&nbsp;b&nbsp;v[:,i]<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;2:&nbsp;a&nbsp;b&nbsp;v[:,i]&nbsp;=&nbsp;w[i]&nbsp;&nbsp;&nbsp;v[:,i]<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;3:&nbsp;b&nbsp;a&nbsp;v[:,i]&nbsp;=&nbsp;w[i]&nbsp;&nbsp;&nbsp;v[:,i]<br>
overwrite_a&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;overwrite&nbsp;data&nbsp;in&nbsp;`a`&nbsp;(may&nbsp;improve&nbsp;performance)<br>
overwrite_b&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;overwrite&nbsp;data&nbsp;in&nbsp;`b`&nbsp;(may&nbsp;improve&nbsp;performance)<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrices&nbsp;contain&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
w&nbsp;:&nbsp;(N,)&nbsp;float&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;(1&lt;=N&lt;=M)&nbsp;selected&nbsp;eigenvalues,&nbsp;in&nbsp;ascending&nbsp;order,&nbsp;each<br>
&nbsp;&nbsp;&nbsp;&nbsp;repeated&nbsp;according&nbsp;to&nbsp;its&nbsp;multiplicity.<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;eigenvalue&nbsp;computation&nbsp;does&nbsp;not&nbsp;converge,<br>
&nbsp;&nbsp;&nbsp;&nbsp;an&nbsp;error&nbsp;occurred,&nbsp;or&nbsp;b&nbsp;matrix&nbsp;is&nbsp;not&nbsp;definite&nbsp;positive.&nbsp;Note&nbsp;that<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;input&nbsp;matrices&nbsp;are&nbsp;not&nbsp;symmetric&nbsp;or&nbsp;hermitian,&nbsp;no&nbsp;error&nbsp;is&nbsp;reported<br>
&nbsp;&nbsp;&nbsp;&nbsp;but&nbsp;results&nbsp;will&nbsp;be&nbsp;wrong.<br>
&nbsp;<br>
See&nbsp;Also<br>
--------<br>
eigvals&nbsp;:&nbsp;eigenvalues&nbsp;of&nbsp;general&nbsp;arrays<br>
eigh&nbsp;:&nbsp;eigenvalues&nbsp;and&nbsp;right&nbsp;eigenvectors&nbsp;for&nbsp;symmetric/Hermitian&nbsp;arrays<br>
eig&nbsp;:&nbsp;eigenvalues&nbsp;and&nbsp;right&nbsp;eigenvectors&nbsp;for&nbsp;non-symmetric&nbsp;arrays</tt></dd></dl>
 <dl><dt><a name="-expm"><strong>expm</strong></a>(A, q<font color="#909090">=None</font>)</dt><dd><tt>Compute&nbsp;the&nbsp;matrix&nbsp;exponential&nbsp;using&nbsp;Pade&nbsp;approximation.<br>
&nbsp;<br>
Parameters<br>
----------<br>
A&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like&nbsp;or&nbsp;sparse&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;to&nbsp;be&nbsp;exponentiated.<br>
&nbsp;<br>
Returns<br>
-------<br>
expm&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;exponential&nbsp;of&nbsp;`A`.<br>
&nbsp;<br>
References<br>
----------<br>
..&nbsp;[1]&nbsp;Awad&nbsp;H.&nbsp;Al-Mohy&nbsp;and&nbsp;Nicholas&nbsp;J.&nbsp;Higham&nbsp;(2009)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"A&nbsp;New&nbsp;Scaling&nbsp;and&nbsp;Squaring&nbsp;Algorithm&nbsp;for&nbsp;the&nbsp;Matrix&nbsp;Exponential."<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SIAM&nbsp;Journal&nbsp;on&nbsp;Matrix&nbsp;Analysis&nbsp;and&nbsp;Applications.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;31&nbsp;(3).&nbsp;pp.&nbsp;970-989.&nbsp;ISSN&nbsp;1095-7162<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;expm,&nbsp;sinm,&nbsp;cosm<br>
&nbsp;<br>
Matrix&nbsp;version&nbsp;of&nbsp;the&nbsp;formula&nbsp;exp(0)&nbsp;=&nbsp;1:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;<a href="#-expm">expm</a>(np.zeros((2,2)))<br>
array([[&nbsp;1.,&nbsp;&nbsp;0.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;1.]])<br>
&nbsp;<br>
Euler's&nbsp;identity&nbsp;(exp(i*theta)&nbsp;=&nbsp;cos(theta)&nbsp;+&nbsp;i*sin(theta))<br>
applied&nbsp;to&nbsp;a&nbsp;matrix:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([[1.0,&nbsp;2.0],&nbsp;[-1.0,&nbsp;3.0]])<br>
&gt;&gt;&gt;&nbsp;<a href="#-expm">expm</a>(1j*a)<br>
array([[&nbsp;0.42645930+1.89217551j,&nbsp;-2.13721484-0.97811252j],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.06860742+0.48905626j,&nbsp;-1.71075555+0.91406299j]])<br>
&gt;&gt;&gt;&nbsp;<a href="#-cosm">cosm</a>(a)&nbsp;+&nbsp;1j*<a href="#-sinm">sinm</a>(a)<br>
array([[&nbsp;0.42645930+1.89217551j,&nbsp;-2.13721484-0.97811252j],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.06860742+0.48905626j,&nbsp;-1.71075555+0.91406299j]])</tt></dd></dl>
 <dl><dt><a name="-expm2"><strong>expm2</strong></a>(*args, **kwds)</dt><dd><tt>`expm2`&nbsp;is&nbsp;deprecated,&nbsp;use&nbsp;`expm`&nbsp;instead!<br>
&nbsp;<br>
&nbsp;<br>
Compute&nbsp;the&nbsp;matrix&nbsp;exponential&nbsp;using&nbsp;eigenvalue&nbsp;decomposition.<br>
&nbsp;<br>
Parameters<br>
----------<br>
A&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;to&nbsp;be&nbsp;exponentiated<br>
&nbsp;<br>
Returns<br>
-------<br>
expm2&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;exponential&nbsp;of&nbsp;`A`</tt></dd></dl>
 <dl><dt><a name="-expm3"><strong>expm3</strong></a>(*args, **kwds)</dt><dd><tt>`expm3`&nbsp;is&nbsp;deprecated,&nbsp;use&nbsp;`expm`&nbsp;instead!<br>
&nbsp;<br>
&nbsp;<br>
Compute&nbsp;the&nbsp;matrix&nbsp;exponential&nbsp;using&nbsp;Taylor&nbsp;series.<br>
&nbsp;<br>
Parameters<br>
----------<br>
A&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;to&nbsp;be&nbsp;exponentiated<br>
q&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;Order&nbsp;of&nbsp;the&nbsp;Taylor&nbsp;series&nbsp;used&nbsp;is&nbsp;`q-1`<br>
&nbsp;<br>
Returns<br>
-------<br>
expm3&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;exponential&nbsp;of&nbsp;`A`</tt></dd></dl>
 <dl><dt><a name="-expm_cond"><strong>expm_cond</strong></a>(A, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Relative&nbsp;condition&nbsp;number&nbsp;of&nbsp;the&nbsp;matrix&nbsp;exponential&nbsp;in&nbsp;the&nbsp;Frobenius&nbsp;norm.<br>
&nbsp;<br>
Parameters<br>
----------<br>
A&nbsp;:&nbsp;2d&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Square&nbsp;input&nbsp;matrix&nbsp;with&nbsp;shape&nbsp;(N,&nbsp;N).<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
kappa&nbsp;:&nbsp;float<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;relative&nbsp;condition&nbsp;number&nbsp;of&nbsp;the&nbsp;matrix&nbsp;exponential<br>
&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;the&nbsp;Frobenius&nbsp;norm<br>
&nbsp;<br>
Notes<br>
-----<br>
A&nbsp;faster&nbsp;estimate&nbsp;for&nbsp;the&nbsp;condition&nbsp;number&nbsp;in&nbsp;the&nbsp;1-norm<br>
has&nbsp;been&nbsp;published&nbsp;but&nbsp;is&nbsp;not&nbsp;yet&nbsp;implemented&nbsp;in&nbsp;scipy.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.14.0<br>
&nbsp;<br>
See&nbsp;also<br>
--------<br>
expm&nbsp;:&nbsp;Compute&nbsp;the&nbsp;exponential&nbsp;of&nbsp;a&nbsp;matrix.<br>
expm_frechet&nbsp;:&nbsp;Compute&nbsp;the&nbsp;Frechet&nbsp;derivative&nbsp;of&nbsp;the&nbsp;matrix&nbsp;exponential.</tt></dd></dl>
 <dl><dt><a name="-expm_frechet"><strong>expm_frechet</strong></a>(A, E, method<font color="#909090">=None</font>, compute_expm<font color="#909090">=True</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Frechet&nbsp;derivative&nbsp;of&nbsp;the&nbsp;matrix&nbsp;exponential&nbsp;of&nbsp;A&nbsp;in&nbsp;the&nbsp;direction&nbsp;E.<br>
&nbsp;<br>
Parameters<br>
----------<br>
A&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;of&nbsp;which&nbsp;to&nbsp;take&nbsp;the&nbsp;matrix&nbsp;exponential.<br>
E&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;direction&nbsp;in&nbsp;which&nbsp;to&nbsp;take&nbsp;the&nbsp;Frechet&nbsp;derivative.<br>
method&nbsp;:&nbsp;str,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Choice&nbsp;of&nbsp;algorithm.&nbsp;&nbsp;Should&nbsp;be&nbsp;one&nbsp;of<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;`SPS`&nbsp;(default)<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;`blockEnlarge`<br>
&nbsp;<br>
compute_expm&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;compute&nbsp;also&nbsp;`expm_A`&nbsp;in&nbsp;addition&nbsp;to&nbsp;`expm_frechet_AE`.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Default&nbsp;is&nbsp;True.<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
expm_A&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;exponential&nbsp;of&nbsp;A.<br>
expm_frechet_AE&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Frechet&nbsp;derivative&nbsp;of&nbsp;the&nbsp;matrix&nbsp;exponential&nbsp;of&nbsp;A&nbsp;in&nbsp;the&nbsp;direction&nbsp;E.<br>
&nbsp;<br>
For&nbsp;``compute_expm&nbsp;=&nbsp;False``,&nbsp;only&nbsp;`expm_frechet_AE`&nbsp;is&nbsp;returned.<br>
&nbsp;<br>
See&nbsp;also<br>
--------<br>
expm&nbsp;:&nbsp;Compute&nbsp;the&nbsp;exponential&nbsp;of&nbsp;a&nbsp;matrix.<br>
&nbsp;<br>
Notes<br>
-----<br>
This&nbsp;section&nbsp;describes&nbsp;the&nbsp;available&nbsp;implementations&nbsp;that&nbsp;can&nbsp;be&nbsp;selected<br>
by&nbsp;the&nbsp;`method`&nbsp;parameter.&nbsp;The&nbsp;default&nbsp;method&nbsp;is&nbsp;*SPS*.<br>
&nbsp;<br>
Method&nbsp;*blockEnlarge*&nbsp;is&nbsp;a&nbsp;naive&nbsp;algorithm.<br>
&nbsp;<br>
Method&nbsp;*SPS*&nbsp;is&nbsp;Scaling-Pade-Squaring&nbsp;[1]_.<br>
It&nbsp;is&nbsp;a&nbsp;sophisticated&nbsp;implementation&nbsp;which&nbsp;should&nbsp;take<br>
only&nbsp;about&nbsp;3/8&nbsp;as&nbsp;much&nbsp;time&nbsp;as&nbsp;the&nbsp;naive&nbsp;implementation.<br>
The&nbsp;asymptotics&nbsp;are&nbsp;the&nbsp;same.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.13.0<br>
&nbsp;<br>
References<br>
----------<br>
..&nbsp;[1]&nbsp;Awad&nbsp;H.&nbsp;Al-Mohy&nbsp;and&nbsp;Nicholas&nbsp;J.&nbsp;Higham&nbsp;(2009)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing&nbsp;the&nbsp;Frechet&nbsp;Derivative&nbsp;of&nbsp;the&nbsp;Matrix&nbsp;Exponential,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;an&nbsp;application&nbsp;to&nbsp;Condition&nbsp;Number&nbsp;Estimation.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SIAM&nbsp;Journal&nbsp;On&nbsp;Matrix&nbsp;Analysis&nbsp;and&nbsp;Applications.,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;30&nbsp;(4).&nbsp;pp.&nbsp;1639-1657.&nbsp;ISSN&nbsp;1095-7162<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;import&nbsp;scipy.linalg<br>
&gt;&gt;&gt;&nbsp;A&nbsp;=&nbsp;np.random.randn(3,&nbsp;3)<br>
&gt;&gt;&gt;&nbsp;E&nbsp;=&nbsp;np.random.randn(3,&nbsp;3)<br>
&gt;&gt;&gt;&nbsp;expm_A,&nbsp;expm_frechet_AE&nbsp;=&nbsp;scipy.linalg.<a href="#-expm_frechet">expm_frechet</a>(A,&nbsp;E)<br>
&gt;&gt;&gt;&nbsp;expm_A.shape,&nbsp;expm_frechet_AE.shape<br>
((3,&nbsp;3),&nbsp;(3,&nbsp;3))<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;import&nbsp;scipy.linalg<br>
&gt;&gt;&gt;&nbsp;A&nbsp;=&nbsp;np.random.randn(3,&nbsp;3)<br>
&gt;&gt;&gt;&nbsp;E&nbsp;=&nbsp;np.random.randn(3,&nbsp;3)<br>
&gt;&gt;&gt;&nbsp;expm_A,&nbsp;expm_frechet_AE&nbsp;=&nbsp;scipy.linalg.<a href="#-expm_frechet">expm_frechet</a>(A,&nbsp;E)<br>
&gt;&gt;&gt;&nbsp;M&nbsp;=&nbsp;np.zeros((6,&nbsp;6))<br>
&gt;&gt;&gt;&nbsp;M[:3,&nbsp;:3]&nbsp;=&nbsp;A;&nbsp;M[:3,&nbsp;3:]&nbsp;=&nbsp;E;&nbsp;M[3:,&nbsp;3:]&nbsp;=&nbsp;A<br>
&gt;&gt;&gt;&nbsp;expm_M&nbsp;=&nbsp;scipy.linalg.<a href="#-expm">expm</a>(M)<br>
&gt;&gt;&gt;&nbsp;np.allclose(expm_A,&nbsp;expm_M[:3,&nbsp;:3])<br>
True<br>
&gt;&gt;&gt;&nbsp;np.allclose(expm_frechet_AE,&nbsp;expm_M[:3,&nbsp;3:])<br>
True</tt></dd></dl>
 <dl><dt><a name="-find_best_blas_type"><strong>find_best_blas_type</strong></a>(arrays<font color="#909090">=()</font>, dtype<font color="#909090">=None</font>)</dt><dd><tt>Find&nbsp;best-matching&nbsp;BLAS/LAPACK&nbsp;type.<br>
&nbsp;<br>
Arrays&nbsp;are&nbsp;used&nbsp;to&nbsp;determine&nbsp;the&nbsp;optimal&nbsp;prefix&nbsp;of&nbsp;BLAS&nbsp;routines.<br>
&nbsp;<br>
Parameters<br>
----------<br>
arrays&nbsp;:&nbsp;sequence&nbsp;of&nbsp;ndarrays,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Arrays&nbsp;can&nbsp;be&nbsp;given&nbsp;to&nbsp;determine&nbsp;optimal&nbsp;prefix&nbsp;of&nbsp;BLAS<br>
&nbsp;&nbsp;&nbsp;&nbsp;routines.&nbsp;If&nbsp;not&nbsp;given,&nbsp;double-precision&nbsp;routines&nbsp;will&nbsp;be<br>
&nbsp;&nbsp;&nbsp;&nbsp;used,&nbsp;otherwise&nbsp;the&nbsp;most&nbsp;generic&nbsp;type&nbsp;in&nbsp;arrays&nbsp;will&nbsp;be&nbsp;used.<br>
dtype&nbsp;:&nbsp;str&nbsp;or&nbsp;dtype,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Data-type&nbsp;specifier.&nbsp;Not&nbsp;used&nbsp;if&nbsp;`arrays`&nbsp;is&nbsp;non-empty.<br>
&nbsp;<br>
Returns<br>
-------<br>
prefix&nbsp;:&nbsp;str<br>
&nbsp;&nbsp;&nbsp;&nbsp;BLAS/LAPACK&nbsp;prefix&nbsp;character.<br>
dtype&nbsp;:&nbsp;dtype<br>
&nbsp;&nbsp;&nbsp;&nbsp;Inferred&nbsp;Numpy&nbsp;data&nbsp;type.<br>
prefer_fortran&nbsp;:&nbsp;bool<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;prefer&nbsp;Fortran&nbsp;order&nbsp;routines&nbsp;over&nbsp;C&nbsp;order.</tt></dd></dl>
 <dl><dt><a name="-fractional_matrix_power"><strong>fractional_matrix_power</strong></a>(A, t)</dt><dd><tt>Compute&nbsp;the&nbsp;fractional&nbsp;power&nbsp;of&nbsp;a&nbsp;matrix.<br>
&nbsp;<br>
Proceeds&nbsp;according&nbsp;to&nbsp;the&nbsp;discussion&nbsp;in&nbsp;section&nbsp;(6)&nbsp;of&nbsp;[1]_.<br>
&nbsp;<br>
Parameters<br>
----------<br>
A&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;whose&nbsp;fractional&nbsp;power&nbsp;to&nbsp;evaluate.<br>
t&nbsp;:&nbsp;float<br>
&nbsp;&nbsp;&nbsp;&nbsp;Fractional&nbsp;power.<br>
&nbsp;<br>
Returns<br>
-------<br>
X&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;fractional&nbsp;power&nbsp;of&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
References<br>
----------<br>
..&nbsp;[1]&nbsp;Nicholas&nbsp;J.&nbsp;Higham&nbsp;and&nbsp;Lijing&nbsp;lin&nbsp;(2011)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"A&nbsp;Schur-Pade&nbsp;Algorithm&nbsp;for&nbsp;Fractional&nbsp;Powers&nbsp;of&nbsp;a&nbsp;Matrix."<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SIAM&nbsp;Journal&nbsp;on&nbsp;Matrix&nbsp;Analysis&nbsp;and&nbsp;Applications,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32&nbsp;(3).&nbsp;pp.&nbsp;1056-1078.&nbsp;ISSN&nbsp;0895-4798<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;fractional_matrix_power<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([[1.0,&nbsp;3.0],&nbsp;[1.0,&nbsp;4.0]])<br>
&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;<a href="#-fractional_matrix_power">fractional_matrix_power</a>(a,&nbsp;0.5)<br>
&gt;&gt;&gt;&nbsp;b<br>
array([[&nbsp;0.75592895,&nbsp;&nbsp;1.13389342],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.37796447,&nbsp;&nbsp;1.88982237]])<br>
&gt;&gt;&gt;&nbsp;np.dot(b,&nbsp;b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Verify&nbsp;square&nbsp;root<br>
array([[&nbsp;1.,&nbsp;&nbsp;3.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.,&nbsp;&nbsp;4.]])</tt></dd></dl>
 <dl><dt><a name="-funm"><strong>funm</strong></a>(A, func, disp<font color="#909090">=True</font>)</dt><dd><tt>Evaluate&nbsp;a&nbsp;matrix&nbsp;function&nbsp;specified&nbsp;by&nbsp;a&nbsp;callable.<br>
&nbsp;<br>
Returns&nbsp;the&nbsp;value&nbsp;of&nbsp;matrix-valued&nbsp;function&nbsp;``f``&nbsp;at&nbsp;`A`.&nbsp;The<br>
function&nbsp;``f``&nbsp;is&nbsp;an&nbsp;extension&nbsp;of&nbsp;the&nbsp;scalar-valued&nbsp;function&nbsp;`func`<br>
to&nbsp;matrices.<br>
&nbsp;<br>
Parameters<br>
----------<br>
A&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;at&nbsp;which&nbsp;to&nbsp;evaluate&nbsp;the&nbsp;function<br>
func&nbsp;:&nbsp;callable<br>
&nbsp;&nbsp;&nbsp;&nbsp;Callable&nbsp;object&nbsp;that&nbsp;evaluates&nbsp;a&nbsp;scalar&nbsp;function&nbsp;f.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Must&nbsp;be&nbsp;vectorized&nbsp;(eg.&nbsp;using&nbsp;vectorize).<br>
disp&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Print&nbsp;warning&nbsp;if&nbsp;error&nbsp;in&nbsp;the&nbsp;result&nbsp;is&nbsp;estimated&nbsp;large<br>
&nbsp;&nbsp;&nbsp;&nbsp;instead&nbsp;of&nbsp;returning&nbsp;estimated&nbsp;error.&nbsp;(Default:&nbsp;True)<br>
&nbsp;<br>
Returns<br>
-------<br>
funm&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Value&nbsp;of&nbsp;the&nbsp;matrix&nbsp;function&nbsp;specified&nbsp;by&nbsp;func&nbsp;evaluated&nbsp;at&nbsp;`A`<br>
errest&nbsp;:&nbsp;float<br>
&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;disp&nbsp;==&nbsp;False)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;1-norm&nbsp;of&nbsp;the&nbsp;estimated&nbsp;error,&nbsp;||err||_1&nbsp;/&nbsp;||A||_1<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;funm<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([[1.0,&nbsp;3.0],&nbsp;[1.0,&nbsp;4.0]])<br>
&gt;&gt;&gt;&nbsp;<a href="#-funm">funm</a>(a,&nbsp;lambda&nbsp;x:&nbsp;x*x)<br>
array([[&nbsp;&nbsp;4.,&nbsp;&nbsp;15.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;5.,&nbsp;&nbsp;19.]])<br>
&gt;&gt;&gt;&nbsp;a.dot(a)<br>
array([[&nbsp;&nbsp;4.,&nbsp;&nbsp;15.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;5.,&nbsp;&nbsp;19.]])<br>
&nbsp;<br>
Notes<br>
-----<br>
This&nbsp;function&nbsp;implements&nbsp;the&nbsp;general&nbsp;algorithm&nbsp;based&nbsp;on&nbsp;Schur&nbsp;decomposition<br>
(Algorithm&nbsp;9.1.1.&nbsp;in&nbsp;[1]_).<br>
&nbsp;<br>
If&nbsp;the&nbsp;input&nbsp;matrix&nbsp;is&nbsp;known&nbsp;to&nbsp;be&nbsp;diagonalizable,&nbsp;then&nbsp;relying&nbsp;on&nbsp;the<br>
eigendecomposition&nbsp;is&nbsp;likely&nbsp;to&nbsp;be&nbsp;faster.&nbsp;For&nbsp;example,&nbsp;if&nbsp;your&nbsp;matrix&nbsp;is<br>
Hermitian,&nbsp;you&nbsp;can&nbsp;do<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;eigh<br>
&gt;&gt;&gt;&nbsp;def&nbsp;funm_herm(a,&nbsp;func,&nbsp;check_finite=False):<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w,&nbsp;v&nbsp;=&nbsp;<a href="#-eigh">eigh</a>(a,&nbsp;check_finite=check_finite)<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;##&nbsp;if&nbsp;you&nbsp;further&nbsp;know&nbsp;that&nbsp;your&nbsp;matrix&nbsp;is&nbsp;positive&nbsp;semidefinite,<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;##&nbsp;you&nbsp;can&nbsp;optionally&nbsp;guard&nbsp;against&nbsp;precision&nbsp;errors&nbsp;by&nbsp;doing<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;w&nbsp;=&nbsp;np.maximum(w,&nbsp;0)<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w&nbsp;=&nbsp;func(w)<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(v&nbsp;*&nbsp;w).dot(v.conj().T)<br>
&nbsp;<br>
References<br>
----------<br>
..&nbsp;[1]&nbsp;Gene&nbsp;H.&nbsp;Golub,&nbsp;Charles&nbsp;F.&nbsp;van&nbsp;Loan,&nbsp;Matrix&nbsp;Computations&nbsp;4th&nbsp;ed.</tt></dd></dl>
 <dl><dt><a name="-get_blas_funcs"><strong>get_blas_funcs</strong></a>(names, arrays<font color="#909090">=()</font>, dtype<font color="#909090">=None</font>)</dt><dd><tt>Return&nbsp;available&nbsp;BLAS&nbsp;function&nbsp;objects&nbsp;from&nbsp;names.<br>
&nbsp;<br>
Arrays&nbsp;are&nbsp;used&nbsp;to&nbsp;determine&nbsp;the&nbsp;optimal&nbsp;prefix&nbsp;of&nbsp;BLAS&nbsp;routines.<br>
&nbsp;<br>
Parameters<br>
----------<br>
names&nbsp;:&nbsp;str&nbsp;or&nbsp;sequence&nbsp;of&nbsp;str<br>
&nbsp;&nbsp;&nbsp;&nbsp;Name(s)&nbsp;of&nbsp;BLAS&nbsp;functions&nbsp;without&nbsp;type&nbsp;prefix.<br>
&nbsp;<br>
arrays&nbsp;:&nbsp;sequence&nbsp;of&nbsp;ndarrays,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Arrays&nbsp;can&nbsp;be&nbsp;given&nbsp;to&nbsp;determine&nbsp;optimal&nbsp;prefix&nbsp;of&nbsp;BLAS<br>
&nbsp;&nbsp;&nbsp;&nbsp;routines.&nbsp;If&nbsp;not&nbsp;given,&nbsp;double-precision&nbsp;routines&nbsp;will&nbsp;be<br>
&nbsp;&nbsp;&nbsp;&nbsp;used,&nbsp;otherwise&nbsp;the&nbsp;most&nbsp;generic&nbsp;type&nbsp;in&nbsp;arrays&nbsp;will&nbsp;be&nbsp;used.<br>
&nbsp;<br>
dtype&nbsp;:&nbsp;str&nbsp;or&nbsp;dtype,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Data-type&nbsp;specifier.&nbsp;Not&nbsp;used&nbsp;if&nbsp;`arrays`&nbsp;is&nbsp;non-empty.<br>
&nbsp;<br>
&nbsp;<br>
Returns<br>
-------<br>
funcs&nbsp;:&nbsp;list<br>
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;containing&nbsp;the&nbsp;found&nbsp;function(s).<br>
&nbsp;<br>
&nbsp;<br>
Notes<br>
-----<br>
This&nbsp;routine&nbsp;automatically&nbsp;chooses&nbsp;between&nbsp;Fortran/C<br>
interfaces.&nbsp;Fortran&nbsp;code&nbsp;is&nbsp;used&nbsp;whenever&nbsp;possible&nbsp;for&nbsp;arrays&nbsp;with<br>
column&nbsp;major&nbsp;order.&nbsp;In&nbsp;all&nbsp;other&nbsp;cases,&nbsp;C&nbsp;code&nbsp;is&nbsp;preferred.<br>
&nbsp;<br>
In&nbsp;BLAS,&nbsp;the&nbsp;naming&nbsp;convention&nbsp;is&nbsp;that&nbsp;all&nbsp;functions&nbsp;start&nbsp;with&nbsp;a<br>
type&nbsp;prefix,&nbsp;which&nbsp;depends&nbsp;on&nbsp;the&nbsp;type&nbsp;of&nbsp;the&nbsp;principal<br>
matrix.&nbsp;These&nbsp;can&nbsp;be&nbsp;one&nbsp;of&nbsp;{'s',&nbsp;'d',&nbsp;'c',&nbsp;'z'}&nbsp;for&nbsp;the&nbsp;numpy<br>
types&nbsp;{float32,&nbsp;float64,&nbsp;complex64,&nbsp;complex128}&nbsp;respectively.<br>
The&nbsp;code&nbsp;and&nbsp;the&nbsp;dtype&nbsp;are&nbsp;stored&nbsp;in&nbsp;attributes&nbsp;`typecode`&nbsp;and&nbsp;`dtype`<br>
of&nbsp;the&nbsp;returned&nbsp;functions.</tt></dd></dl>
 <dl><dt><a name="-get_lapack_funcs"><strong>get_lapack_funcs</strong></a>(names, arrays<font color="#909090">=()</font>, dtype<font color="#909090">=None</font>)</dt><dd><tt>Return&nbsp;available&nbsp;LAPACK&nbsp;function&nbsp;objects&nbsp;from&nbsp;names.<br>
&nbsp;<br>
Arrays&nbsp;are&nbsp;used&nbsp;to&nbsp;determine&nbsp;the&nbsp;optimal&nbsp;prefix&nbsp;of&nbsp;LAPACK&nbsp;routines.<br>
&nbsp;<br>
Parameters<br>
----------<br>
names&nbsp;:&nbsp;str&nbsp;or&nbsp;sequence&nbsp;of&nbsp;str<br>
&nbsp;&nbsp;&nbsp;&nbsp;Name(s)&nbsp;of&nbsp;LAPACK&nbsp;functions&nbsp;without&nbsp;type&nbsp;prefix.<br>
&nbsp;<br>
arrays&nbsp;:&nbsp;sequence&nbsp;of&nbsp;ndarrays,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Arrays&nbsp;can&nbsp;be&nbsp;given&nbsp;to&nbsp;determine&nbsp;optimal&nbsp;prefix&nbsp;of&nbsp;LAPACK<br>
&nbsp;&nbsp;&nbsp;&nbsp;routines.&nbsp;If&nbsp;not&nbsp;given,&nbsp;double-precision&nbsp;routines&nbsp;will&nbsp;be<br>
&nbsp;&nbsp;&nbsp;&nbsp;used,&nbsp;otherwise&nbsp;the&nbsp;most&nbsp;generic&nbsp;type&nbsp;in&nbsp;arrays&nbsp;will&nbsp;be&nbsp;used.<br>
&nbsp;<br>
dtype&nbsp;:&nbsp;str&nbsp;or&nbsp;dtype,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Data-type&nbsp;specifier.&nbsp;Not&nbsp;used&nbsp;if&nbsp;`arrays`&nbsp;is&nbsp;non-empty.<br>
&nbsp;<br>
&nbsp;<br>
Returns<br>
-------<br>
funcs&nbsp;:&nbsp;list<br>
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;containing&nbsp;the&nbsp;found&nbsp;function(s).<br>
&nbsp;<br>
&nbsp;<br>
Notes<br>
-----<br>
This&nbsp;routine&nbsp;automatically&nbsp;chooses&nbsp;between&nbsp;Fortran/C<br>
interfaces.&nbsp;Fortran&nbsp;code&nbsp;is&nbsp;used&nbsp;whenever&nbsp;possible&nbsp;for&nbsp;arrays&nbsp;with<br>
column&nbsp;major&nbsp;order.&nbsp;In&nbsp;all&nbsp;other&nbsp;cases,&nbsp;C&nbsp;code&nbsp;is&nbsp;preferred.<br>
&nbsp;<br>
In&nbsp;LAPACK,&nbsp;the&nbsp;naming&nbsp;convention&nbsp;is&nbsp;that&nbsp;all&nbsp;functions&nbsp;start&nbsp;with&nbsp;a<br>
type&nbsp;prefix,&nbsp;which&nbsp;depends&nbsp;on&nbsp;the&nbsp;type&nbsp;of&nbsp;the&nbsp;principal<br>
matrix.&nbsp;These&nbsp;can&nbsp;be&nbsp;one&nbsp;of&nbsp;{'s',&nbsp;'d',&nbsp;'c',&nbsp;'z'}&nbsp;for&nbsp;the&nbsp;numpy<br>
types&nbsp;{float32,&nbsp;float64,&nbsp;complex64,&nbsp;complex128}&nbsp;respectevely,&nbsp;and<br>
are&nbsp;stored&nbsp;in&nbsp;attribute&nbsp;`typecode`&nbsp;of&nbsp;the&nbsp;returned&nbsp;functions.</tt></dd></dl>
 <dl><dt><a name="-hadamard"><strong>hadamard</strong></a>(n, dtype<font color="#909090">=&lt;type 'int'&gt;</font>)</dt><dd><tt>Construct&nbsp;a&nbsp;Hadamard&nbsp;matrix.<br>
&nbsp;<br>
Constructs&nbsp;an&nbsp;n-by-n&nbsp;Hadamard&nbsp;matrix,&nbsp;using&nbsp;Sylvester's<br>
construction.&nbsp;&nbsp;`n`&nbsp;must&nbsp;be&nbsp;a&nbsp;power&nbsp;of&nbsp;2.<br>
&nbsp;<br>
Parameters<br>
----------<br>
n&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;order&nbsp;of&nbsp;the&nbsp;matrix.&nbsp;&nbsp;`n`&nbsp;must&nbsp;be&nbsp;a&nbsp;power&nbsp;of&nbsp;2.<br>
dtype&nbsp;:&nbsp;dtype,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;data&nbsp;type&nbsp;of&nbsp;the&nbsp;array&nbsp;to&nbsp;be&nbsp;constructed.<br>
&nbsp;<br>
Returns<br>
-------<br>
H&nbsp;:&nbsp;(n,&nbsp;n)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;Hadamard&nbsp;matrix.<br>
&nbsp;<br>
Notes<br>
-----<br>
..&nbsp;versionadded::&nbsp;0.8.0<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;hadamard<br>
&gt;&gt;&gt;&nbsp;<a href="#-hadamard">hadamard</a>(2,&nbsp;dtype=complex)<br>
array([[&nbsp;1.+0.j,&nbsp;&nbsp;1.+0.j],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.+0.j,&nbsp;-1.-0.j]])<br>
&gt;&gt;&gt;&nbsp;<a href="#-hadamard">hadamard</a>(4)<br>
array([[&nbsp;1,&nbsp;&nbsp;1,&nbsp;&nbsp;1,&nbsp;&nbsp;1],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1,&nbsp;-1,&nbsp;&nbsp;1,&nbsp;-1],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1,&nbsp;&nbsp;1,&nbsp;-1,&nbsp;-1],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1,&nbsp;-1,&nbsp;-1,&nbsp;&nbsp;1]])</tt></dd></dl>
 <dl><dt><a name="-hankel"><strong>hankel</strong></a>(c, r<font color="#909090">=None</font>)</dt><dd><tt>Construct&nbsp;a&nbsp;Hankel&nbsp;matrix.<br>
&nbsp;<br>
The&nbsp;Hankel&nbsp;matrix&nbsp;has&nbsp;constant&nbsp;anti-diagonals,&nbsp;with&nbsp;`c`&nbsp;as&nbsp;its<br>
first&nbsp;column&nbsp;and&nbsp;`r`&nbsp;as&nbsp;its&nbsp;last&nbsp;row.&nbsp;&nbsp;If&nbsp;`r`&nbsp;is&nbsp;not&nbsp;given,&nbsp;then<br>
`r&nbsp;=&nbsp;zeros_like(c)`&nbsp;is&nbsp;assumed.<br>
&nbsp;<br>
Parameters<br>
----------<br>
c&nbsp;:&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;First&nbsp;column&nbsp;of&nbsp;the&nbsp;matrix.&nbsp;&nbsp;Whatever&nbsp;the&nbsp;actual&nbsp;shape&nbsp;of&nbsp;`c`,&nbsp;it<br>
&nbsp;&nbsp;&nbsp;&nbsp;will&nbsp;be&nbsp;converted&nbsp;to&nbsp;a&nbsp;1-D&nbsp;array.<br>
r&nbsp;:&nbsp;array_like,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Last&nbsp;row&nbsp;of&nbsp;the&nbsp;matrix.&nbsp;If&nbsp;None,&nbsp;``r&nbsp;=&nbsp;zeros_like(c)``&nbsp;is&nbsp;assumed.<br>
&nbsp;&nbsp;&nbsp;&nbsp;r[0]&nbsp;is&nbsp;ignored;&nbsp;the&nbsp;last&nbsp;row&nbsp;of&nbsp;the&nbsp;returned&nbsp;matrix&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;``[c[-1],&nbsp;r[1:]]``.&nbsp;&nbsp;Whatever&nbsp;the&nbsp;actual&nbsp;shape&nbsp;of&nbsp;`r`,&nbsp;it&nbsp;will&nbsp;be<br>
&nbsp;&nbsp;&nbsp;&nbsp;converted&nbsp;to&nbsp;a&nbsp;1-D&nbsp;array.<br>
&nbsp;<br>
Returns<br>
-------<br>
A&nbsp;:&nbsp;(len(c),&nbsp;len(r))&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;Hankel&nbsp;matrix.&nbsp;Dtype&nbsp;is&nbsp;the&nbsp;same&nbsp;as&nbsp;``(c[0]&nbsp;+&nbsp;r[0]).dtype``.<br>
&nbsp;<br>
See&nbsp;also<br>
--------<br>
toeplitz&nbsp;:&nbsp;Toeplitz&nbsp;matrix<br>
circulant&nbsp;:&nbsp;circulant&nbsp;matrix<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;hankel<br>
&gt;&gt;&gt;&nbsp;<a href="#-hankel">hankel</a>([1,&nbsp;17,&nbsp;99])<br>
array([[&nbsp;1,&nbsp;17,&nbsp;99],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[17,&nbsp;99,&nbsp;&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[99,&nbsp;&nbsp;0,&nbsp;&nbsp;0]])<br>
&gt;&gt;&gt;&nbsp;<a href="#-hankel">hankel</a>([1,2,3,4],&nbsp;[4,7,7,8,9])<br>
array([[1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;7],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[2,&nbsp;3,&nbsp;4,&nbsp;7,&nbsp;7],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,&nbsp;4,&nbsp;7,&nbsp;7,&nbsp;8],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4,&nbsp;7,&nbsp;7,&nbsp;8,&nbsp;9]])</tt></dd></dl>
 <dl><dt><a name="-helmert"><strong>helmert</strong></a>(n, full<font color="#909090">=False</font>)</dt><dd><tt>Create&nbsp;a&nbsp;Helmert&nbsp;matrix&nbsp;of&nbsp;order&nbsp;`n`.<br>
&nbsp;<br>
This&nbsp;has&nbsp;applications&nbsp;in&nbsp;statistics,&nbsp;compositional&nbsp;or&nbsp;simplicial&nbsp;analysis,<br>
and&nbsp;in&nbsp;Aitchison&nbsp;geometry.<br>
&nbsp;<br>
Parameters<br>
----------<br>
n&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;size&nbsp;of&nbsp;the&nbsp;array&nbsp;to&nbsp;create.<br>
full&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True&nbsp;the&nbsp;(n,&nbsp;n)&nbsp;ndarray&nbsp;will&nbsp;be&nbsp;returned.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Otherwise&nbsp;the&nbsp;submatrix&nbsp;that&nbsp;does&nbsp;not&nbsp;include&nbsp;the&nbsp;first<br>
&nbsp;&nbsp;&nbsp;&nbsp;row&nbsp;will&nbsp;be&nbsp;returned.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Default:&nbsp;False.<br>
&nbsp;<br>
Returns<br>
-------<br>
M&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;Helmert&nbsp;matrix.<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;shape&nbsp;is&nbsp;(n,&nbsp;n)&nbsp;or&nbsp;(n-1,&nbsp;n)&nbsp;depending&nbsp;on&nbsp;the&nbsp;`full`&nbsp;argument.<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;helmert<br>
&gt;&gt;&gt;&nbsp;<a href="#-helmert">helmert</a>(5,&nbsp;full=True)<br>
array([[&nbsp;0.4472136&nbsp;,&nbsp;&nbsp;0.4472136&nbsp;,&nbsp;&nbsp;0.4472136&nbsp;,&nbsp;&nbsp;0.4472136&nbsp;,&nbsp;&nbsp;0.4472136&nbsp;],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.70710678,&nbsp;-0.70710678,&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.40824829,&nbsp;&nbsp;0.40824829,&nbsp;-0.81649658,&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.28867513,&nbsp;&nbsp;0.28867513,&nbsp;&nbsp;0.28867513,&nbsp;-0.8660254&nbsp;,&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.2236068&nbsp;,&nbsp;&nbsp;0.2236068&nbsp;,&nbsp;&nbsp;0.2236068&nbsp;,&nbsp;&nbsp;0.2236068&nbsp;,&nbsp;-0.89442719]])</tt></dd></dl>
 <dl><dt><a name="-hessenberg"><strong>hessenberg</strong></a>(a, calc_q<font color="#909090">=False</font>, overwrite_a<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Compute&nbsp;Hessenberg&nbsp;form&nbsp;of&nbsp;a&nbsp;matrix.<br>
&nbsp;<br>
The&nbsp;Hessenberg&nbsp;decomposition&nbsp;is::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;Q&nbsp;H&nbsp;Q^H<br>
&nbsp;<br>
where&nbsp;`Q`&nbsp;is&nbsp;unitary/orthogonal&nbsp;and&nbsp;`H`&nbsp;has&nbsp;only&nbsp;zero&nbsp;elements&nbsp;below<br>
the&nbsp;first&nbsp;sub-diagonal.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;to&nbsp;bring&nbsp;into&nbsp;Hessenberg&nbsp;form.<br>
calc_q&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;compute&nbsp;the&nbsp;transformation&nbsp;matrix.&nbsp;&nbsp;Default&nbsp;is&nbsp;False.<br>
overwrite_a&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;overwrite&nbsp;`a`;&nbsp;may&nbsp;improve&nbsp;performance.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Default&nbsp;is&nbsp;False.<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
H&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Hessenberg&nbsp;form&nbsp;of&nbsp;`a`.<br>
Q&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Unitary/orthogonal&nbsp;similarity&nbsp;transformation&nbsp;matrix&nbsp;``A&nbsp;=&nbsp;Q&nbsp;H&nbsp;Q^H``.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Only&nbsp;returned&nbsp;if&nbsp;``calc_q=True``.</tt></dd></dl>
 <dl><dt><a name="-hilbert"><strong>hilbert</strong></a>(n)</dt><dd><tt>Create&nbsp;a&nbsp;Hilbert&nbsp;matrix&nbsp;of&nbsp;order&nbsp;`n`.<br>
&nbsp;<br>
Returns&nbsp;the&nbsp;`n`&nbsp;by&nbsp;`n`&nbsp;array&nbsp;with&nbsp;entries&nbsp;`h[i,j]&nbsp;=&nbsp;1&nbsp;/&nbsp;(i&nbsp;+&nbsp;j&nbsp;+&nbsp;1)`.<br>
&nbsp;<br>
Parameters<br>
----------<br>
n&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;size&nbsp;of&nbsp;the&nbsp;array&nbsp;to&nbsp;create.<br>
&nbsp;<br>
Returns<br>
-------<br>
h&nbsp;:&nbsp;(n,&nbsp;n)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;Hilbert&nbsp;matrix.<br>
&nbsp;<br>
See&nbsp;Also<br>
--------<br>
invhilbert&nbsp;:&nbsp;Compute&nbsp;the&nbsp;inverse&nbsp;of&nbsp;a&nbsp;Hilbert&nbsp;matrix.<br>
&nbsp;<br>
Notes<br>
-----<br>
..&nbsp;versionadded::&nbsp;0.10.0<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;hilbert<br>
&gt;&gt;&gt;&nbsp;<a href="#-hilbert">hilbert</a>(3)<br>
array([[&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;0.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;0.33333333],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;0.33333333,&nbsp;&nbsp;0.25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.33333333,&nbsp;&nbsp;0.25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;0.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]])</tt></dd></dl>
 <dl><dt><a name="-inv"><strong>inv</strong></a>(a, overwrite_a<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Compute&nbsp;the&nbsp;inverse&nbsp;of&nbsp;a&nbsp;matrix.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Square&nbsp;matrix&nbsp;to&nbsp;be&nbsp;inverted.<br>
overwrite_a&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Discard&nbsp;data&nbsp;in&nbsp;`a`&nbsp;(may&nbsp;improve&nbsp;performance).&nbsp;Default&nbsp;is&nbsp;False.<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
ainv&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Inverse&nbsp;of&nbsp;the&nbsp;matrix&nbsp;`a`.<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;`a`&nbsp;is&nbsp;singular.<br>
ValueError<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;`a`&nbsp;is&nbsp;not&nbsp;square,&nbsp;or&nbsp;not&nbsp;2-dimensional.<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy&nbsp;import&nbsp;linalg<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([[1.,&nbsp;2.],&nbsp;[3.,&nbsp;4.]])<br>
&gt;&gt;&gt;&nbsp;linalg.<a href="#-inv">inv</a>(a)<br>
array([[-2.&nbsp;,&nbsp;&nbsp;1.&nbsp;],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.5,&nbsp;-0.5]])<br>
&gt;&gt;&gt;&nbsp;np.dot(a,&nbsp;linalg.<a href="#-inv">inv</a>(a))<br>
array([[&nbsp;1.,&nbsp;&nbsp;0.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;1.]])</tt></dd></dl>
 <dl><dt><a name="-invhilbert"><strong>invhilbert</strong></a>(n, exact<font color="#909090">=False</font>)</dt><dd><tt>Compute&nbsp;the&nbsp;inverse&nbsp;of&nbsp;the&nbsp;Hilbert&nbsp;matrix&nbsp;of&nbsp;order&nbsp;`n`.<br>
&nbsp;<br>
The&nbsp;entries&nbsp;in&nbsp;the&nbsp;inverse&nbsp;of&nbsp;a&nbsp;Hilbert&nbsp;matrix&nbsp;are&nbsp;integers.&nbsp;&nbsp;When&nbsp;`n`<br>
is&nbsp;greater&nbsp;than&nbsp;14,&nbsp;some&nbsp;entries&nbsp;in&nbsp;the&nbsp;inverse&nbsp;exceed&nbsp;the&nbsp;upper&nbsp;limit<br>
of&nbsp;64&nbsp;bit&nbsp;integers.&nbsp;&nbsp;The&nbsp;`exact`&nbsp;argument&nbsp;provides&nbsp;two&nbsp;options&nbsp;for<br>
dealing&nbsp;with&nbsp;these&nbsp;large&nbsp;integers.<br>
&nbsp;<br>
Parameters<br>
----------<br>
n&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;order&nbsp;of&nbsp;the&nbsp;Hilbert&nbsp;matrix.<br>
exact&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;False,&nbsp;the&nbsp;data&nbsp;type&nbsp;of&nbsp;the&nbsp;array&nbsp;that&nbsp;is&nbsp;returned&nbsp;is&nbsp;np.float64,<br>
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;the&nbsp;array&nbsp;is&nbsp;an&nbsp;approximation&nbsp;of&nbsp;the&nbsp;inverse.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;the&nbsp;array&nbsp;is&nbsp;the&nbsp;exact&nbsp;integer&nbsp;inverse&nbsp;array.&nbsp;&nbsp;To&nbsp;represent<br>
&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;exact&nbsp;inverse&nbsp;when&nbsp;n&nbsp;&gt;&nbsp;14,&nbsp;the&nbsp;returned&nbsp;array&nbsp;is&nbsp;an&nbsp;object&nbsp;array<br>
&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;long&nbsp;integers.&nbsp;&nbsp;For&nbsp;n&nbsp;&lt;=&nbsp;14,&nbsp;the&nbsp;exact&nbsp;inverse&nbsp;is&nbsp;returned&nbsp;as&nbsp;an<br>
&nbsp;&nbsp;&nbsp;&nbsp;array&nbsp;with&nbsp;data&nbsp;type&nbsp;np.int64.<br>
&nbsp;<br>
Returns<br>
-------<br>
invh&nbsp;:&nbsp;(n,&nbsp;n)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;data&nbsp;type&nbsp;of&nbsp;the&nbsp;array&nbsp;is&nbsp;np.float64&nbsp;if&nbsp;`exact`&nbsp;is&nbsp;False.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;`exact`&nbsp;is&nbsp;True,&nbsp;the&nbsp;data&nbsp;type&nbsp;is&nbsp;either&nbsp;np.int64&nbsp;(for&nbsp;n&nbsp;&lt;=&nbsp;14)<br>
&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;object&nbsp;(for&nbsp;n&nbsp;&gt;&nbsp;14).&nbsp;&nbsp;In&nbsp;the&nbsp;latter&nbsp;case,&nbsp;the&nbsp;objects&nbsp;in&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;array&nbsp;will&nbsp;be&nbsp;long&nbsp;integers.<br>
&nbsp;<br>
See&nbsp;Also<br>
--------<br>
hilbert&nbsp;:&nbsp;Create&nbsp;a&nbsp;Hilbert&nbsp;matrix.<br>
&nbsp;<br>
Notes<br>
-----<br>
..&nbsp;versionadded::&nbsp;0.10.0<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;invhilbert<br>
&gt;&gt;&gt;&nbsp;<a href="#-invhilbert">invhilbert</a>(4)<br>
array([[&nbsp;&nbsp;&nbsp;16.,&nbsp;&nbsp;-120.,&nbsp;&nbsp;&nbsp;240.,&nbsp;&nbsp;-140.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-120.,&nbsp;&nbsp;1200.,&nbsp;-2700.,&nbsp;&nbsp;1680.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;240.,&nbsp;-2700.,&nbsp;&nbsp;6480.,&nbsp;-4200.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-140.,&nbsp;&nbsp;1680.,&nbsp;-4200.,&nbsp;&nbsp;2800.]])<br>
&gt;&gt;&gt;&nbsp;<a href="#-invhilbert">invhilbert</a>(4,&nbsp;exact=True)<br>
array([[&nbsp;&nbsp;&nbsp;16,&nbsp;&nbsp;-120,&nbsp;&nbsp;&nbsp;240,&nbsp;&nbsp;-140],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-120,&nbsp;&nbsp;1200,&nbsp;-2700,&nbsp;&nbsp;1680],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;240,&nbsp;-2700,&nbsp;&nbsp;6480,&nbsp;-4200],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-140,&nbsp;&nbsp;1680,&nbsp;-4200,&nbsp;&nbsp;2800]],&nbsp;dtype=int64)<br>
&gt;&gt;&gt;&nbsp;<a href="#-invhilbert">invhilbert</a>(16)[7,7]<br>
4.2475099528537506e+19<br>
&gt;&gt;&gt;&nbsp;<a href="#-invhilbert">invhilbert</a>(16,&nbsp;exact=True)[7,7]<br>
42475099528537378560L</tt></dd></dl>
 <dl><dt><a name="-invpascal"><strong>invpascal</strong></a>(n, kind<font color="#909090">='symmetric'</font>, exact<font color="#909090">=True</font>)</dt><dd><tt>Returns&nbsp;the&nbsp;inverse&nbsp;of&nbsp;the&nbsp;n&nbsp;x&nbsp;n&nbsp;Pascal&nbsp;matrix.<br>
&nbsp;<br>
The&nbsp;Pascal&nbsp;matrix&nbsp;is&nbsp;a&nbsp;matrix&nbsp;containing&nbsp;the&nbsp;binomial&nbsp;coefficients&nbsp;as<br>
its&nbsp;elements.<br>
&nbsp;<br>
Parameters<br>
----------<br>
n&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;size&nbsp;of&nbsp;the&nbsp;matrix&nbsp;to&nbsp;create;&nbsp;that&nbsp;is,&nbsp;the&nbsp;result&nbsp;is&nbsp;an&nbsp;n&nbsp;x&nbsp;n<br>
&nbsp;&nbsp;&nbsp;&nbsp;matrix.<br>
kind&nbsp;:&nbsp;str,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Must&nbsp;be&nbsp;one&nbsp;of&nbsp;'symmetric',&nbsp;'lower',&nbsp;or&nbsp;'upper'.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Default&nbsp;is&nbsp;'symmetric'.<br>
exact&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;`exact`&nbsp;is&nbsp;True,&nbsp;the&nbsp;result&nbsp;is&nbsp;either&nbsp;an&nbsp;array&nbsp;of&nbsp;type<br>
&nbsp;&nbsp;&nbsp;&nbsp;`numpy.int64`&nbsp;(if&nbsp;`n`&nbsp;&lt;=&nbsp;35)&nbsp;or&nbsp;an&nbsp;object&nbsp;array&nbsp;of&nbsp;Python&nbsp;integers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;`exact`&nbsp;is&nbsp;False,&nbsp;the&nbsp;coefficients&nbsp;in&nbsp;the&nbsp;matrix&nbsp;are&nbsp;computed&nbsp;using<br>
&nbsp;&nbsp;&nbsp;&nbsp;`scipy.special.comb`&nbsp;with&nbsp;`exact=False`.&nbsp;&nbsp;The&nbsp;result&nbsp;will&nbsp;be&nbsp;a&nbsp;floating<br>
&nbsp;&nbsp;&nbsp;&nbsp;point&nbsp;array,&nbsp;and&nbsp;for&nbsp;large&nbsp;`n`,&nbsp;the&nbsp;values&nbsp;in&nbsp;the&nbsp;array&nbsp;will&nbsp;not&nbsp;be&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;exact&nbsp;coefficients.<br>
&nbsp;<br>
Returns<br>
-------<br>
invp&nbsp;:&nbsp;(n,&nbsp;n)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;inverse&nbsp;of&nbsp;the&nbsp;Pascal&nbsp;matrix.<br>
&nbsp;<br>
See&nbsp;Also<br>
--------<br>
pascal<br>
&nbsp;<br>
Notes<br>
-----<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.16.0<br>
&nbsp;<br>
References<br>
----------<br>
..&nbsp;[1]&nbsp;"Pascal&nbsp;matrix",&nbsp;&nbsp;<a href="http://en.wikipedia.org/wiki/Pascal_matrix">http://en.wikipedia.org/wiki/Pascal_matrix</a><br>
..&nbsp;[2]&nbsp;Cohen,&nbsp;A.&nbsp;M.,&nbsp;"The&nbsp;inverse&nbsp;of&nbsp;a&nbsp;Pascal&nbsp;matrix",&nbsp;Mathematical<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gazette,&nbsp;59(408),&nbsp;pp.&nbsp;111-112,&nbsp;1975.<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;invpascal,&nbsp;pascal<br>
&gt;&gt;&gt;&nbsp;invp&nbsp;=&nbsp;<a href="#-invpascal">invpascal</a>(5)<br>
&gt;&gt;&gt;&nbsp;invp<br>
array([[&nbsp;&nbsp;5,&nbsp;-10,&nbsp;&nbsp;10,&nbsp;&nbsp;-5,&nbsp;&nbsp;&nbsp;1],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-10,&nbsp;&nbsp;30,&nbsp;-35,&nbsp;&nbsp;19,&nbsp;&nbsp;-4],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;10,&nbsp;-35,&nbsp;&nbsp;46,&nbsp;-27,&nbsp;&nbsp;&nbsp;6],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-5,&nbsp;&nbsp;19,&nbsp;-27,&nbsp;&nbsp;17,&nbsp;&nbsp;-4],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;1,&nbsp;&nbsp;-4,&nbsp;&nbsp;&nbsp;6,&nbsp;&nbsp;-4,&nbsp;&nbsp;&nbsp;1]])<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;p&nbsp;=&nbsp;<a href="#-pascal">pascal</a>(5)<br>
&gt;&gt;&gt;&nbsp;p.dot(invp)<br>
array([[&nbsp;1.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;1.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;1.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;1.,&nbsp;&nbsp;0.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;0.,&nbsp;&nbsp;1.]])<br>
&nbsp;<br>
An&nbsp;example&nbsp;of&nbsp;the&nbsp;use&nbsp;of&nbsp;`kind`&nbsp;and&nbsp;`exact`:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;<a href="#-invpascal">invpascal</a>(5,&nbsp;kind='lower',&nbsp;exact=False)<br>
array([[&nbsp;1.,&nbsp;-0.,&nbsp;&nbsp;0.,&nbsp;-0.,&nbsp;&nbsp;0.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-1.,&nbsp;&nbsp;1.,&nbsp;-0.,&nbsp;&nbsp;0.,&nbsp;-0.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.,&nbsp;-2.,&nbsp;&nbsp;1.,&nbsp;-0.,&nbsp;&nbsp;0.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-1.,&nbsp;&nbsp;3.,&nbsp;-3.,&nbsp;&nbsp;1.,&nbsp;-0.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.,&nbsp;-4.,&nbsp;&nbsp;6.,&nbsp;-4.,&nbsp;&nbsp;1.]])</tt></dd></dl>
 <dl><dt><a name="-kron"><strong>kron</strong></a>(a, b)</dt><dd><tt>Kronecker&nbsp;product.<br>
&nbsp;<br>
The&nbsp;result&nbsp;is&nbsp;the&nbsp;block&nbsp;matrix::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;a[0,0]*b&nbsp;&nbsp;&nbsp;&nbsp;a[0,1]*b&nbsp;&nbsp;...&nbsp;a[0,-1]*b<br>
&nbsp;&nbsp;&nbsp;&nbsp;a[1,0]*b&nbsp;&nbsp;&nbsp;&nbsp;a[1,1]*b&nbsp;&nbsp;...&nbsp;a[1,-1]*b<br>
&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;a[-1,0]*b&nbsp;&nbsp;&nbsp;a[-1,1]*b&nbsp;...&nbsp;a[-1,-1]*b<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Input&nbsp;array<br>
b&nbsp;:&nbsp;(P,&nbsp;Q)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Input&nbsp;array<br>
&nbsp;<br>
Returns<br>
-------<br>
A&nbsp;:&nbsp;(M*P,&nbsp;N*Q)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Kronecker&nbsp;product&nbsp;of&nbsp;`a`&nbsp;and&nbsp;`b`.<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;numpy&nbsp;import&nbsp;array<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;kron<br>
&gt;&gt;&gt;&nbsp;<a href="#-kron">kron</a>(array([[1,2],[3,4]]),&nbsp;array([[1,1,1]]))<br>
array([[1,&nbsp;1,&nbsp;1,&nbsp;2,&nbsp;2,&nbsp;2],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,&nbsp;3,&nbsp;3,&nbsp;4,&nbsp;4,&nbsp;4]])</tt></dd></dl>
 <dl><dt><a name="-leslie"><strong>leslie</strong></a>(f, s)</dt><dd><tt>Create&nbsp;a&nbsp;Leslie&nbsp;matrix.<br>
&nbsp;<br>
Given&nbsp;the&nbsp;length&nbsp;n&nbsp;array&nbsp;of&nbsp;fecundity&nbsp;coefficients&nbsp;`f`&nbsp;and&nbsp;the&nbsp;length<br>
n-1&nbsp;array&nbsp;of&nbsp;survival&nbsp;coefficents&nbsp;`s`,&nbsp;return&nbsp;the&nbsp;associated&nbsp;Leslie&nbsp;matrix.<br>
&nbsp;<br>
Parameters<br>
----------<br>
f&nbsp;:&nbsp;(N,)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;"fecundity"&nbsp;coefficients.<br>
s&nbsp;:&nbsp;(N-1,)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;"survival"&nbsp;coefficients,&nbsp;has&nbsp;to&nbsp;be&nbsp;1-D.&nbsp;&nbsp;The&nbsp;length&nbsp;of&nbsp;`s`<br>
&nbsp;&nbsp;&nbsp;&nbsp;must&nbsp;be&nbsp;one&nbsp;less&nbsp;than&nbsp;the&nbsp;length&nbsp;of&nbsp;`f`,&nbsp;and&nbsp;it&nbsp;must&nbsp;be&nbsp;at&nbsp;least&nbsp;1.<br>
&nbsp;<br>
Returns<br>
-------<br>
L&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;array&nbsp;is&nbsp;zero&nbsp;except&nbsp;for&nbsp;the&nbsp;first&nbsp;row,<br>
&nbsp;&nbsp;&nbsp;&nbsp;which&nbsp;is&nbsp;`f`,&nbsp;and&nbsp;the&nbsp;first&nbsp;sub-diagonal,&nbsp;which&nbsp;is&nbsp;`s`.<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;data-type&nbsp;of&nbsp;the&nbsp;array&nbsp;will&nbsp;be&nbsp;the&nbsp;data-type&nbsp;of&nbsp;``f[0]+s[0]``.<br>
&nbsp;<br>
Notes<br>
-----<br>
..&nbsp;versionadded::&nbsp;0.8.0<br>
&nbsp;<br>
The&nbsp;Leslie&nbsp;matrix&nbsp;is&nbsp;used&nbsp;to&nbsp;model&nbsp;discrete-time,&nbsp;age-structured<br>
population&nbsp;growth&nbsp;[1]_&nbsp;[2]_.&nbsp;In&nbsp;a&nbsp;population&nbsp;with&nbsp;`n`&nbsp;age&nbsp;classes,&nbsp;two&nbsp;sets<br>
of&nbsp;parameters&nbsp;define&nbsp;a&nbsp;Leslie&nbsp;matrix:&nbsp;the&nbsp;`n`&nbsp;"fecundity&nbsp;coefficients",<br>
which&nbsp;give&nbsp;the&nbsp;number&nbsp;of&nbsp;offspring&nbsp;per-capita&nbsp;produced&nbsp;by&nbsp;each&nbsp;age<br>
class,&nbsp;and&nbsp;the&nbsp;`n`&nbsp;-&nbsp;1&nbsp;"survival&nbsp;coefficients",&nbsp;which&nbsp;give&nbsp;the<br>
per-capita&nbsp;survival&nbsp;rate&nbsp;of&nbsp;each&nbsp;age&nbsp;class.<br>
&nbsp;<br>
References<br>
----------<br>
..&nbsp;[1]&nbsp;P.&nbsp;H.&nbsp;Leslie,&nbsp;On&nbsp;the&nbsp;use&nbsp;of&nbsp;matrices&nbsp;in&nbsp;certain&nbsp;population<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mathematics,&nbsp;Biometrika,&nbsp;Vol.&nbsp;33,&nbsp;No.&nbsp;3,&nbsp;183--212&nbsp;(Nov.&nbsp;1945)<br>
..&nbsp;[2]&nbsp;P.&nbsp;H.&nbsp;Leslie,&nbsp;Some&nbsp;further&nbsp;notes&nbsp;on&nbsp;the&nbsp;use&nbsp;of&nbsp;matrices&nbsp;in<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;population&nbsp;mathematics,&nbsp;Biometrika,&nbsp;Vol.&nbsp;35,&nbsp;No.&nbsp;3/4,&nbsp;213--245<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Dec.&nbsp;1948)<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;leslie<br>
&gt;&gt;&gt;&nbsp;<a href="#-leslie">leslie</a>([0.1,&nbsp;2.0,&nbsp;1.0,&nbsp;0.1],&nbsp;[0.2,&nbsp;0.8,&nbsp;0.7])<br>
array([[&nbsp;0.1,&nbsp;&nbsp;2.&nbsp;,&nbsp;&nbsp;1.&nbsp;,&nbsp;&nbsp;0.1],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.2,&nbsp;&nbsp;0.&nbsp;,&nbsp;&nbsp;0.&nbsp;,&nbsp;&nbsp;0.&nbsp;],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.&nbsp;,&nbsp;&nbsp;0.8,&nbsp;&nbsp;0.&nbsp;,&nbsp;&nbsp;0.&nbsp;],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.&nbsp;,&nbsp;&nbsp;0.&nbsp;,&nbsp;&nbsp;0.7,&nbsp;&nbsp;0.&nbsp;]])</tt></dd></dl>
 <dl><dt><a name="-logm"><strong>logm</strong></a>(A, disp<font color="#909090">=True</font>)</dt><dd><tt>Compute&nbsp;matrix&nbsp;logarithm.<br>
&nbsp;<br>
The&nbsp;matrix&nbsp;logarithm&nbsp;is&nbsp;the&nbsp;inverse&nbsp;of<br>
expm:&nbsp;<a href="#-expm">expm</a>(<a href="#-logm">logm</a>(`A`))&nbsp;==&nbsp;`A`<br>
&nbsp;<br>
Parameters<br>
----------<br>
A&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;whose&nbsp;logarithm&nbsp;to&nbsp;evaluate<br>
disp&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Print&nbsp;warning&nbsp;if&nbsp;error&nbsp;in&nbsp;the&nbsp;result&nbsp;is&nbsp;estimated&nbsp;large<br>
&nbsp;&nbsp;&nbsp;&nbsp;instead&nbsp;of&nbsp;returning&nbsp;estimated&nbsp;error.&nbsp;(Default:&nbsp;True)<br>
&nbsp;<br>
Returns<br>
-------<br>
logm&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;logarithm&nbsp;of&nbsp;`A`<br>
errest&nbsp;:&nbsp;float<br>
&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;disp&nbsp;==&nbsp;False)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;1-norm&nbsp;of&nbsp;the&nbsp;estimated&nbsp;error,&nbsp;||err||_1&nbsp;/&nbsp;||A||_1<br>
&nbsp;<br>
References<br>
----------<br>
..&nbsp;[1]&nbsp;Awad&nbsp;H.&nbsp;Al-Mohy&nbsp;and&nbsp;Nicholas&nbsp;J.&nbsp;Higham&nbsp;(2012)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Improved&nbsp;Inverse&nbsp;Scaling&nbsp;and&nbsp;Squaring&nbsp;Algorithms<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;the&nbsp;Matrix&nbsp;Logarithm."<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SIAM&nbsp;Journal&nbsp;on&nbsp;Scientific&nbsp;Computing,&nbsp;34&nbsp;(4).&nbsp;C152-C169.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ISSN&nbsp;1095-7197<br>
&nbsp;<br>
..&nbsp;[2]&nbsp;Nicholas&nbsp;J.&nbsp;Higham&nbsp;(2008)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Functions&nbsp;of&nbsp;Matrices:&nbsp;Theory&nbsp;and&nbsp;Computation"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ISBN&nbsp;978-0-898716-46-7<br>
&nbsp;<br>
..&nbsp;[3]&nbsp;Nicholas&nbsp;J.&nbsp;Higham&nbsp;and&nbsp;Lijing&nbsp;lin&nbsp;(2011)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"A&nbsp;Schur-Pade&nbsp;Algorithm&nbsp;for&nbsp;Fractional&nbsp;Powers&nbsp;of&nbsp;a&nbsp;Matrix."<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SIAM&nbsp;Journal&nbsp;on&nbsp;Matrix&nbsp;Analysis&nbsp;and&nbsp;Applications,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32&nbsp;(3).&nbsp;pp.&nbsp;1056-1078.&nbsp;ISSN&nbsp;0895-4798<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;logm,&nbsp;expm<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([[1.0,&nbsp;3.0],&nbsp;[1.0,&nbsp;4.0]])<br>
&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;<a href="#-logm">logm</a>(a)<br>
&gt;&gt;&gt;&nbsp;b<br>
array([[-1.02571087,&nbsp;&nbsp;2.05142174],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.68380725,&nbsp;&nbsp;1.02571087]])<br>
&gt;&gt;&gt;&nbsp;<a href="#-expm">expm</a>(b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Verify&nbsp;<a href="#-expm">expm</a>(<a href="#-logm">logm</a>(a))&nbsp;returns&nbsp;a<br>
array([[&nbsp;1.,&nbsp;&nbsp;3.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.,&nbsp;&nbsp;4.]])</tt></dd></dl>
 <dl><dt><a name="-lstsq"><strong>lstsq</strong></a>(a, b, cond<font color="#909090">=None</font>, overwrite_a<font color="#909090">=False</font>, overwrite_b<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>, lapack_driver<font color="#909090">=None</font>)</dt><dd><tt>Compute&nbsp;least-squares&nbsp;solution&nbsp;to&nbsp;equation&nbsp;Ax&nbsp;=&nbsp;b.<br>
&nbsp;<br>
Compute&nbsp;a&nbsp;vector&nbsp;x&nbsp;such&nbsp;that&nbsp;the&nbsp;2-norm&nbsp;``|b&nbsp;-&nbsp;A&nbsp;x|``&nbsp;is&nbsp;minimized.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Left&nbsp;hand&nbsp;side&nbsp;matrix&nbsp;(2-D&nbsp;array).<br>
b&nbsp;:&nbsp;(M,)&nbsp;or&nbsp;(M,&nbsp;K)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Right&nbsp;hand&nbsp;side&nbsp;matrix&nbsp;or&nbsp;vector&nbsp;(1-D&nbsp;or&nbsp;2-D&nbsp;array).<br>
cond&nbsp;:&nbsp;float,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Cutoff&nbsp;for&nbsp;'small'&nbsp;singular&nbsp;values;&nbsp;used&nbsp;to&nbsp;determine&nbsp;effective<br>
&nbsp;&nbsp;&nbsp;&nbsp;rank&nbsp;of&nbsp;a.&nbsp;Singular&nbsp;values&nbsp;smaller&nbsp;than<br>
&nbsp;&nbsp;&nbsp;&nbsp;``rcond&nbsp;*&nbsp;largest_singular_value``&nbsp;are&nbsp;considered&nbsp;zero.<br>
overwrite_a&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Discard&nbsp;data&nbsp;in&nbsp;`a`&nbsp;(may&nbsp;enhance&nbsp;performance).&nbsp;Default&nbsp;is&nbsp;False.<br>
overwrite_b&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Discard&nbsp;data&nbsp;in&nbsp;`b`&nbsp;(may&nbsp;enhance&nbsp;performance).&nbsp;Default&nbsp;is&nbsp;False.<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrices&nbsp;contain&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
lapack_driver:&nbsp;str,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Which&nbsp;LAPACK&nbsp;driver&nbsp;is&nbsp;used&nbsp;to&nbsp;solve&nbsp;the&nbsp;least-squares&nbsp;problem.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Options&nbsp;are&nbsp;``'gelsd'``,&nbsp;``'gelsy'``,&nbsp;``'gelss'``.&nbsp;Default<br>
&nbsp;&nbsp;&nbsp;&nbsp;(``'gelsd'``)&nbsp;is&nbsp;a&nbsp;good&nbsp;choice.&nbsp;&nbsp;However,&nbsp;``'gelsy'``&nbsp;can&nbsp;be&nbsp;slightly<br>
&nbsp;&nbsp;&nbsp;&nbsp;faster&nbsp;on&nbsp;many&nbsp;problems.&nbsp;&nbsp;``'gelss'``&nbsp;was&nbsp;used&nbsp;historically.&nbsp;&nbsp;It&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;generally&nbsp;slow&nbsp;but&nbsp;uses&nbsp;less&nbsp;memory.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;..&nbsp;versionadded::&nbsp;0.17.0<br>
&nbsp;<br>
Returns<br>
-------<br>
x&nbsp;:&nbsp;(N,)&nbsp;or&nbsp;(N,&nbsp;K)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Least-squares&nbsp;solution.&nbsp;&nbsp;Return&nbsp;shape&nbsp;matches&nbsp;shape&nbsp;of&nbsp;`b`.<br>
residues&nbsp;:&nbsp;()&nbsp;or&nbsp;(1,)&nbsp;or&nbsp;(K,)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Sums&nbsp;of&nbsp;residues,&nbsp;squared&nbsp;2-norm&nbsp;for&nbsp;each&nbsp;column&nbsp;in&nbsp;``b&nbsp;-&nbsp;a&nbsp;x``.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;rank&nbsp;of&nbsp;matrix&nbsp;a&nbsp;is&nbsp;``&lt;&nbsp;N``&nbsp;or&nbsp;``&gt;&nbsp;M``,&nbsp;or&nbsp;``'gelsy'``&nbsp;is&nbsp;used,<br>
&nbsp;&nbsp;&nbsp;&nbsp;this&nbsp;is&nbsp;an&nbsp;empty&nbsp;array.&nbsp;If&nbsp;b&nbsp;was&nbsp;1-D,&nbsp;this&nbsp;is&nbsp;an&nbsp;(1,)&nbsp;shape&nbsp;array,<br>
&nbsp;&nbsp;&nbsp;&nbsp;otherwise&nbsp;the&nbsp;shape&nbsp;is&nbsp;(K,).<br>
rank&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;Effective&nbsp;rank&nbsp;of&nbsp;matrix&nbsp;`a`.<br>
s&nbsp;:&nbsp;(min(M,N),)&nbsp;ndarray&nbsp;or&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;Singular&nbsp;values&nbsp;of&nbsp;`a`.&nbsp;The&nbsp;condition&nbsp;number&nbsp;of&nbsp;a&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;``abs(s[0]&nbsp;/&nbsp;s[-1])``.&nbsp;None&nbsp;is&nbsp;returned&nbsp;when&nbsp;``'gelsy'``&nbsp;is&nbsp;used.<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;computation&nbsp;does&nbsp;not&nbsp;converge.<br>
&nbsp;<br>
ValueError<br>
&nbsp;&nbsp;&nbsp;&nbsp;When&nbsp;parameters&nbsp;are&nbsp;wrong.<br>
&nbsp;<br>
See&nbsp;Also<br>
--------<br>
optimize.nnls&nbsp;:&nbsp;linear&nbsp;least&nbsp;squares&nbsp;with&nbsp;non-negativity&nbsp;constraint</tt></dd></dl>
 <dl><dt><a name="-lu"><strong>lu</strong></a>(a, permute_l<font color="#909090">=False</font>, overwrite_a<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Compute&nbsp;pivoted&nbsp;LU&nbsp;decomposition&nbsp;of&nbsp;a&nbsp;matrix.<br>
&nbsp;<br>
The&nbsp;decomposition&nbsp;is::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;P&nbsp;L&nbsp;U<br>
&nbsp;<br>
where&nbsp;P&nbsp;is&nbsp;a&nbsp;permutation&nbsp;matrix,&nbsp;L&nbsp;lower&nbsp;triangular&nbsp;with&nbsp;unit<br>
diagonal&nbsp;elements,&nbsp;and&nbsp;U&nbsp;upper&nbsp;triangular.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Array&nbsp;to&nbsp;decompose<br>
permute_l&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Perform&nbsp;the&nbsp;multiplication&nbsp;P*L&nbsp;&nbsp;(Default:&nbsp;do&nbsp;not&nbsp;permute)<br>
overwrite_a&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;overwrite&nbsp;data&nbsp;in&nbsp;a&nbsp;(may&nbsp;improve&nbsp;performance)<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
**(If&nbsp;permute_l&nbsp;==&nbsp;False)**<br>
&nbsp;<br>
p&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Permutation&nbsp;matrix<br>
l&nbsp;:&nbsp;(M,&nbsp;K)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Lower&nbsp;triangular&nbsp;or&nbsp;trapezoidal&nbsp;matrix&nbsp;with&nbsp;unit&nbsp;diagonal.<br>
&nbsp;&nbsp;&nbsp;&nbsp;K&nbsp;=&nbsp;min(M,&nbsp;N)<br>
u&nbsp;:&nbsp;(K,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Upper&nbsp;triangular&nbsp;or&nbsp;trapezoidal&nbsp;matrix<br>
&nbsp;<br>
**(If&nbsp;permute_l&nbsp;==&nbsp;True)**<br>
&nbsp;<br>
pl&nbsp;:&nbsp;(M,&nbsp;K)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Permuted&nbsp;L&nbsp;matrix.<br>
&nbsp;&nbsp;&nbsp;&nbsp;K&nbsp;=&nbsp;min(M,&nbsp;N)<br>
u&nbsp;:&nbsp;(K,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Upper&nbsp;triangular&nbsp;or&nbsp;trapezoidal&nbsp;matrix<br>
&nbsp;<br>
Notes<br>
-----<br>
This&nbsp;is&nbsp;a&nbsp;LU&nbsp;factorization&nbsp;routine&nbsp;written&nbsp;for&nbsp;Scipy.</tt></dd></dl>
 <dl><dt><a name="-lu_factor"><strong>lu_factor</strong></a>(a, overwrite_a<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Compute&nbsp;pivoted&nbsp;LU&nbsp;decomposition&nbsp;of&nbsp;a&nbsp;matrix.<br>
&nbsp;<br>
The&nbsp;decomposition&nbsp;is::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;P&nbsp;L&nbsp;U<br>
&nbsp;<br>
where&nbsp;P&nbsp;is&nbsp;a&nbsp;permutation&nbsp;matrix,&nbsp;L&nbsp;lower&nbsp;triangular&nbsp;with&nbsp;unit<br>
diagonal&nbsp;elements,&nbsp;and&nbsp;U&nbsp;upper&nbsp;triangular.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;to&nbsp;decompose<br>
overwrite_a&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;overwrite&nbsp;data&nbsp;in&nbsp;A&nbsp;(may&nbsp;increase&nbsp;performance)<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
lu&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;containing&nbsp;U&nbsp;in&nbsp;its&nbsp;upper&nbsp;triangle,&nbsp;and&nbsp;L&nbsp;in&nbsp;its&nbsp;lower&nbsp;triangle.<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;unit&nbsp;diagonal&nbsp;elements&nbsp;of&nbsp;L&nbsp;are&nbsp;not&nbsp;stored.<br>
piv&nbsp;:&nbsp;(N,)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Pivot&nbsp;indices&nbsp;representing&nbsp;the&nbsp;permutation&nbsp;matrix&nbsp;P:<br>
&nbsp;&nbsp;&nbsp;&nbsp;row&nbsp;i&nbsp;of&nbsp;matrix&nbsp;was&nbsp;interchanged&nbsp;with&nbsp;row&nbsp;piv[i].<br>
&nbsp;<br>
See&nbsp;also<br>
--------<br>
lu_solve&nbsp;:&nbsp;solve&nbsp;an&nbsp;equation&nbsp;system&nbsp;using&nbsp;the&nbsp;LU&nbsp;factorization&nbsp;of&nbsp;a&nbsp;matrix<br>
&nbsp;<br>
Notes<br>
-----<br>
This&nbsp;is&nbsp;a&nbsp;wrapper&nbsp;to&nbsp;the&nbsp;``*GETRF``&nbsp;routines&nbsp;from&nbsp;LAPACK.</tt></dd></dl>
 <dl><dt><a name="-lu_solve"><strong>lu_solve</strong></a>(lu_and_piv, b, trans<font color="#909090">=0</font>, overwrite_b<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Solve&nbsp;an&nbsp;equation&nbsp;system,&nbsp;a&nbsp;x&nbsp;=&nbsp;b,&nbsp;given&nbsp;the&nbsp;LU&nbsp;factorization&nbsp;of&nbsp;a<br>
&nbsp;<br>
Parameters<br>
----------<br>
(lu,&nbsp;piv)<br>
&nbsp;&nbsp;&nbsp;&nbsp;Factorization&nbsp;of&nbsp;the&nbsp;coefficient&nbsp;matrix&nbsp;a,&nbsp;as&nbsp;given&nbsp;by&nbsp;lu_factor<br>
b&nbsp;:&nbsp;array<br>
&nbsp;&nbsp;&nbsp;&nbsp;Right-hand&nbsp;side<br>
trans&nbsp;:&nbsp;{0,&nbsp;1,&nbsp;2},&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;of&nbsp;system&nbsp;to&nbsp;solve:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;=====&nbsp;&nbsp;=========<br>
&nbsp;&nbsp;&nbsp;&nbsp;trans&nbsp;&nbsp;system<br>
&nbsp;&nbsp;&nbsp;&nbsp;=====&nbsp;&nbsp;=========<br>
&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;x&nbsp;&nbsp;&nbsp;=&nbsp;b<br>
&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a^T&nbsp;x&nbsp;=&nbsp;b<br>
&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a^H&nbsp;x&nbsp;=&nbsp;b<br>
&nbsp;&nbsp;&nbsp;&nbsp;=====&nbsp;&nbsp;=========<br>
overwrite_b&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;overwrite&nbsp;data&nbsp;in&nbsp;b&nbsp;(may&nbsp;increase&nbsp;performance)<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrices&nbsp;contain&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
x&nbsp;:&nbsp;array<br>
&nbsp;&nbsp;&nbsp;&nbsp;Solution&nbsp;to&nbsp;the&nbsp;system<br>
&nbsp;<br>
See&nbsp;also<br>
--------<br>
lu_factor&nbsp;:&nbsp;LU&nbsp;factorize&nbsp;a&nbsp;matrix</tt></dd></dl>
 <dl><dt><a name="-norm"><strong>norm</strong></a>(a, ord<font color="#909090">=None</font>, axis<font color="#909090">=None</font>, keepdims<font color="#909090">=False</font>)</dt><dd><tt>Matrix&nbsp;or&nbsp;vector&nbsp;norm.<br>
&nbsp;<br>
This&nbsp;function&nbsp;is&nbsp;able&nbsp;to&nbsp;return&nbsp;one&nbsp;of&nbsp;seven&nbsp;different&nbsp;matrix&nbsp;norms,<br>
or&nbsp;one&nbsp;of&nbsp;an&nbsp;infinite&nbsp;number&nbsp;of&nbsp;vector&nbsp;norms&nbsp;(described&nbsp;below),&nbsp;depending<br>
on&nbsp;the&nbsp;value&nbsp;of&nbsp;the&nbsp;``ord``&nbsp;parameter.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,)&nbsp;or&nbsp;(M,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Input&nbsp;array.&nbsp;&nbsp;If&nbsp;`axis`&nbsp;is&nbsp;None,&nbsp;`a`&nbsp;must&nbsp;be&nbsp;1-D&nbsp;or&nbsp;2-D.<br>
ord&nbsp;:&nbsp;{non-zero&nbsp;int,&nbsp;inf,&nbsp;-inf,&nbsp;'fro'},&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Order&nbsp;of&nbsp;the&nbsp;norm&nbsp;(see&nbsp;table&nbsp;under&nbsp;``Notes``).&nbsp;inf&nbsp;means&nbsp;numpy's<br>
&nbsp;&nbsp;&nbsp;&nbsp;`inf`&nbsp;object<br>
axis&nbsp;:&nbsp;{int,&nbsp;2-tuple&nbsp;of&nbsp;ints,&nbsp;None},&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;`axis`&nbsp;is&nbsp;an&nbsp;integer,&nbsp;it&nbsp;specifies&nbsp;the&nbsp;axis&nbsp;of&nbsp;`a`&nbsp;along&nbsp;which&nbsp;to<br>
&nbsp;&nbsp;&nbsp;&nbsp;compute&nbsp;the&nbsp;vector&nbsp;norms.&nbsp;&nbsp;If&nbsp;`axis`&nbsp;is&nbsp;a&nbsp;2-tuple,&nbsp;it&nbsp;specifies&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;axes&nbsp;that&nbsp;hold&nbsp;2-D&nbsp;matrices,&nbsp;and&nbsp;the&nbsp;matrix&nbsp;norms&nbsp;of&nbsp;these&nbsp;matrices<br>
&nbsp;&nbsp;&nbsp;&nbsp;are&nbsp;computed.&nbsp;&nbsp;If&nbsp;`axis`&nbsp;is&nbsp;None&nbsp;then&nbsp;either&nbsp;a&nbsp;vector&nbsp;norm&nbsp;(when&nbsp;`a`<br>
&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;1-D)&nbsp;or&nbsp;a&nbsp;matrix&nbsp;norm&nbsp;(when&nbsp;`a`&nbsp;is&nbsp;2-D)&nbsp;is&nbsp;returned.<br>
keepdims&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;this&nbsp;is&nbsp;set&nbsp;to&nbsp;True,&nbsp;the&nbsp;axes&nbsp;which&nbsp;are&nbsp;normed&nbsp;over&nbsp;are&nbsp;left&nbsp;in&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;as&nbsp;dimensions&nbsp;with&nbsp;size&nbsp;one.&nbsp;&nbsp;With&nbsp;this&nbsp;option&nbsp;the&nbsp;result&nbsp;will<br>
&nbsp;&nbsp;&nbsp;&nbsp;broadcast&nbsp;correctly&nbsp;against&nbsp;the&nbsp;original&nbsp;`a`.<br>
&nbsp;<br>
Returns<br>
-------<br>
n&nbsp;:&nbsp;float&nbsp;or&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Norm&nbsp;of&nbsp;the&nbsp;matrix&nbsp;or&nbsp;vector(s).<br>
&nbsp;<br>
Notes<br>
-----<br>
For&nbsp;values&nbsp;of&nbsp;``ord&nbsp;&lt;=&nbsp;0``,&nbsp;the&nbsp;result&nbsp;is,&nbsp;strictly&nbsp;speaking,&nbsp;not&nbsp;a<br>
mathematical&nbsp;'norm',&nbsp;but&nbsp;it&nbsp;may&nbsp;still&nbsp;be&nbsp;useful&nbsp;for&nbsp;various&nbsp;numerical<br>
purposes.<br>
&nbsp;<br>
The&nbsp;following&nbsp;norms&nbsp;can&nbsp;be&nbsp;calculated:<br>
&nbsp;<br>
=====&nbsp;&nbsp;============================&nbsp;&nbsp;==========================<br>
ord&nbsp;&nbsp;&nbsp;&nbsp;norm&nbsp;for&nbsp;matrices&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;norm&nbsp;for&nbsp;vectors<br>
=====&nbsp;&nbsp;============================&nbsp;&nbsp;==========================<br>
None&nbsp;&nbsp;&nbsp;Frobenius&nbsp;norm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2-norm<br>
'fro'&nbsp;&nbsp;Frobenius&nbsp;norm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<br>
inf&nbsp;&nbsp;&nbsp;&nbsp;max(sum(abs(x),&nbsp;axis=1))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max(abs(x))<br>
-inf&nbsp;&nbsp;&nbsp;min(sum(abs(x),&nbsp;axis=1))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min(abs(x))<br>
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum(x&nbsp;!=&nbsp;0)<br>
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max(sum(abs(x),&nbsp;axis=0))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;below<br>
-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min(sum(abs(x),&nbsp;axis=0))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;below<br>
2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2-norm&nbsp;(largest&nbsp;sing.&nbsp;value)&nbsp;&nbsp;as&nbsp;below<br>
-2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smallest&nbsp;singular&nbsp;value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;below<br>
other&nbsp;&nbsp;--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum(abs(x)**ord)**(1./ord)<br>
=====&nbsp;&nbsp;============================&nbsp;&nbsp;==========================<br>
&nbsp;<br>
The&nbsp;Frobenius&nbsp;norm&nbsp;is&nbsp;given&nbsp;by&nbsp;[1]_:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;:math:`||A||_F&nbsp;=&nbsp;[\sum_{i,j}&nbsp;abs(a_{i,j})^2]^{1/2}`<br>
&nbsp;<br>
The&nbsp;``axis``&nbsp;and&nbsp;``keepdims``&nbsp;arguments&nbsp;are&nbsp;passed&nbsp;directly&nbsp;to<br>
``numpy.linalg.norm``&nbsp;and&nbsp;are&nbsp;only&nbsp;usable&nbsp;if&nbsp;they&nbsp;are&nbsp;supported<br>
by&nbsp;the&nbsp;version&nbsp;of&nbsp;numpy&nbsp;in&nbsp;use.<br>
&nbsp;<br>
References<br>
----------<br>
..&nbsp;[1]&nbsp;G.&nbsp;H.&nbsp;Golub&nbsp;and&nbsp;C.&nbsp;F.&nbsp;Van&nbsp;Loan,&nbsp;*Matrix&nbsp;Computations*,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Baltimore,&nbsp;MD,&nbsp;Johns&nbsp;Hopkins&nbsp;University&nbsp;Press,&nbsp;1985,&nbsp;pg.&nbsp;15<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;norm<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.arange(9)&nbsp;-&nbsp;4.0<br>
&gt;&gt;&gt;&nbsp;a<br>
array([-4.,&nbsp;-3.,&nbsp;-2.,&nbsp;-1.,&nbsp;&nbsp;0.,&nbsp;&nbsp;1.,&nbsp;&nbsp;2.,&nbsp;&nbsp;3.,&nbsp;&nbsp;4.])<br>
&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;a.reshape((3,&nbsp;3))<br>
&gt;&gt;&gt;&nbsp;b<br>
array([[-4.,&nbsp;-3.,&nbsp;-2.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-1.,&nbsp;&nbsp;0.,&nbsp;&nbsp;1.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;2.,&nbsp;&nbsp;3.,&nbsp;&nbsp;4.]])<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;<a href="#-norm">norm</a>(a)<br>
7.745966692414834<br>
&gt;&gt;&gt;&nbsp;<a href="#-norm">norm</a>(b)<br>
7.745966692414834<br>
&gt;&gt;&gt;&nbsp;<a href="#-norm">norm</a>(b,&nbsp;'fro')<br>
7.745966692414834<br>
&gt;&gt;&gt;&nbsp;<a href="#-norm">norm</a>(a,&nbsp;np.inf)<br>
4<br>
&gt;&gt;&gt;&nbsp;<a href="#-norm">norm</a>(b,&nbsp;np.inf)<br>
9<br>
&gt;&gt;&gt;&nbsp;<a href="#-norm">norm</a>(a,&nbsp;-np.inf)<br>
0<br>
&gt;&gt;&gt;&nbsp;<a href="#-norm">norm</a>(b,&nbsp;-np.inf)<br>
2<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;<a href="#-norm">norm</a>(a,&nbsp;1)<br>
20<br>
&gt;&gt;&gt;&nbsp;<a href="#-norm">norm</a>(b,&nbsp;1)<br>
7<br>
&gt;&gt;&gt;&nbsp;<a href="#-norm">norm</a>(a,&nbsp;-1)<br>
-4.6566128774142013e-010<br>
&gt;&gt;&gt;&nbsp;<a href="#-norm">norm</a>(b,&nbsp;-1)<br>
6<br>
&gt;&gt;&gt;&nbsp;<a href="#-norm">norm</a>(a,&nbsp;2)<br>
7.745966692414834<br>
&gt;&gt;&gt;&nbsp;<a href="#-norm">norm</a>(b,&nbsp;2)<br>
7.3484692283495345<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;<a href="#-norm">norm</a>(a,&nbsp;-2)<br>
0<br>
&gt;&gt;&gt;&nbsp;<a href="#-norm">norm</a>(b,&nbsp;-2)<br>
1.8570331885190563e-016<br>
&gt;&gt;&gt;&nbsp;<a href="#-norm">norm</a>(a,&nbsp;3)<br>
5.8480354764257312<br>
&gt;&gt;&gt;&nbsp;<a href="#-norm">norm</a>(a,&nbsp;-3)<br>
0</tt></dd></dl>
 <dl><dt><a name="-ordqz"><strong>ordqz</strong></a>(A, B, sort<font color="#909090">='lhp'</font>, output<font color="#909090">='real'</font>, overwrite_a<font color="#909090">=False</font>, overwrite_b<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>QZ&nbsp;decomposition&nbsp;for&nbsp;a&nbsp;pair&nbsp;of&nbsp;matrices&nbsp;with&nbsp;reordering.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.17.0<br>
&nbsp;<br>
Parameters<br>
----------<br>
A&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;2d&nbsp;array&nbsp;to&nbsp;decompose<br>
B&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;2d&nbsp;array&nbsp;to&nbsp;decompose<br>
sort&nbsp;:&nbsp;{callable,&nbsp;'lhp',&nbsp;'rhp',&nbsp;'iuc',&nbsp;'ouc'},&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Specifies&nbsp;whether&nbsp;the&nbsp;upper&nbsp;eigenvalues&nbsp;should&nbsp;be&nbsp;sorted.&nbsp;&nbsp;A&nbsp;callable<br>
&nbsp;&nbsp;&nbsp;&nbsp;may&nbsp;be&nbsp;passed&nbsp;that,&nbsp;given&nbsp;a&nbsp;eigenvalue,&nbsp;returns&nbsp;a&nbsp;boolean&nbsp;denoting<br>
&nbsp;&nbsp;&nbsp;&nbsp;whether&nbsp;the&nbsp;eigenvalue&nbsp;should&nbsp;be&nbsp;sorted&nbsp;to&nbsp;the&nbsp;top-left&nbsp;(True).&nbsp;For<br>
&nbsp;&nbsp;&nbsp;&nbsp;real&nbsp;matrix&nbsp;pairs,&nbsp;the&nbsp;sort&nbsp;function&nbsp;takes&nbsp;three&nbsp;real&nbsp;arguments<br>
&nbsp;&nbsp;&nbsp;&nbsp;(alphar,&nbsp;alphai,&nbsp;beta).&nbsp;The&nbsp;eigenvalue<br>
&nbsp;&nbsp;&nbsp;&nbsp;``x&nbsp;=&nbsp;(alphar&nbsp;+&nbsp;alphai*1j)/beta``.&nbsp;&nbsp;For&nbsp;complex&nbsp;matrix&nbsp;pairs&nbsp;or<br>
&nbsp;&nbsp;&nbsp;&nbsp;output='complex',&nbsp;the&nbsp;sort&nbsp;function&nbsp;takes&nbsp;two&nbsp;complex&nbsp;arguments<br>
&nbsp;&nbsp;&nbsp;&nbsp;(alpha,&nbsp;beta).&nbsp;The&nbsp;eigenvalue&nbsp;``x&nbsp;=&nbsp;(alpha/beta)``.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Alternatively,&nbsp;string&nbsp;parameters&nbsp;may&nbsp;be&nbsp;used:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;'lhp'&nbsp;&nbsp;&nbsp;Left-hand&nbsp;plane&nbsp;(x.real&nbsp;&lt;&nbsp;0.0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;'rhp'&nbsp;&nbsp;&nbsp;Right-hand&nbsp;plane&nbsp;(x.real&nbsp;&gt;&nbsp;0.0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;'iuc'&nbsp;&nbsp;&nbsp;Inside&nbsp;the&nbsp;unit&nbsp;circle&nbsp;(x*x.conjugate()&nbsp;&lt;&nbsp;1.0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;'ouc'&nbsp;&nbsp;&nbsp;Outside&nbsp;the&nbsp;unit&nbsp;circle&nbsp;(x*x.conjugate()&nbsp;&gt;&nbsp;1.0)<br>
&nbsp;<br>
output&nbsp;:&nbsp;str&nbsp;{'real','complex'},&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Construct&nbsp;the&nbsp;real&nbsp;or&nbsp;complex&nbsp;QZ&nbsp;decomposition&nbsp;for&nbsp;real&nbsp;matrices.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Default&nbsp;is&nbsp;'real'.<br>
overwrite_a&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;the&nbsp;contents&nbsp;of&nbsp;A&nbsp;are&nbsp;overwritten.<br>
overwrite_b&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;the&nbsp;contents&nbsp;of&nbsp;B&nbsp;are&nbsp;overwritten.<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;true&nbsp;checks&nbsp;the&nbsp;elements&nbsp;of&nbsp;`A`&nbsp;and&nbsp;`B`&nbsp;are&nbsp;finite&nbsp;numbers.&nbsp;If<br>
&nbsp;&nbsp;&nbsp;&nbsp;false&nbsp;does&nbsp;no&nbsp;checking&nbsp;and&nbsp;passes&nbsp;matrix&nbsp;through&nbsp;to<br>
&nbsp;&nbsp;&nbsp;&nbsp;underlying&nbsp;algorithm.<br>
&nbsp;<br>
Returns<br>
-------<br>
AA&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Generalized&nbsp;Schur&nbsp;form&nbsp;of&nbsp;A.<br>
BB&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Generalized&nbsp;Schur&nbsp;form&nbsp;of&nbsp;B.<br>
alpha&nbsp;:&nbsp;(N,)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;alpha&nbsp;=&nbsp;alphar&nbsp;+&nbsp;alphai&nbsp;*&nbsp;1j.&nbsp;See&nbsp;notes.<br>
beta&nbsp;:&nbsp;(N,)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;See&nbsp;notes.<br>
Q&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;left&nbsp;Schur&nbsp;vectors.<br>
Z&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;right&nbsp;Schur&nbsp;vectors.<br>
&nbsp;<br>
Notes<br>
-----<br>
On&nbsp;exit,&nbsp;``(ALPHAR(j)&nbsp;+&nbsp;ALPHAI(j)*i)/BETA(j),&nbsp;j=1,...,N``,&nbsp;will&nbsp;be&nbsp;the<br>
generalized&nbsp;eigenvalues.&nbsp;&nbsp;``ALPHAR(j)&nbsp;+&nbsp;ALPHAI(j)*i``&nbsp;and<br>
``BETA(j),j=1,...,N``&nbsp;are&nbsp;the&nbsp;diagonals&nbsp;of&nbsp;the&nbsp;complex&nbsp;Schur&nbsp;form&nbsp;(S,T)<br>
that&nbsp;would&nbsp;result&nbsp;if&nbsp;the&nbsp;2-by-2&nbsp;diagonal&nbsp;blocks&nbsp;of&nbsp;the&nbsp;real&nbsp;generalized<br>
Schur&nbsp;form&nbsp;of&nbsp;(A,B)&nbsp;were&nbsp;further&nbsp;reduced&nbsp;to&nbsp;triangular&nbsp;form&nbsp;using&nbsp;complex<br>
unitary&nbsp;transformations.&nbsp;If&nbsp;ALPHAI(j)&nbsp;is&nbsp;zero,&nbsp;then&nbsp;the&nbsp;j-th&nbsp;eigenvalue&nbsp;is<br>
real;&nbsp;if&nbsp;positive,&nbsp;then&nbsp;the&nbsp;``j``-th&nbsp;and&nbsp;``(j+1)``-st&nbsp;eigenvalues&nbsp;are&nbsp;a&nbsp;complex<br>
conjugate&nbsp;pair,&nbsp;with&nbsp;``ALPHAI(j+1)``&nbsp;negative.<br>
&nbsp;<br>
See&nbsp;also<br>
--------<br>
qz</tt></dd></dl>
 <dl><dt><a name="-orth"><strong>orth</strong></a>(A)</dt><dd><tt>Construct&nbsp;an&nbsp;orthonormal&nbsp;basis&nbsp;for&nbsp;the&nbsp;range&nbsp;of&nbsp;A&nbsp;using&nbsp;SVD<br>
&nbsp;<br>
Parameters<br>
----------<br>
A&nbsp;:&nbsp;(M,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Input&nbsp;array<br>
&nbsp;<br>
Returns<br>
-------<br>
Q&nbsp;:&nbsp;(M,&nbsp;K)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Orthonormal&nbsp;basis&nbsp;for&nbsp;the&nbsp;range&nbsp;of&nbsp;A.<br>
&nbsp;&nbsp;&nbsp;&nbsp;K&nbsp;=&nbsp;effective&nbsp;rank&nbsp;of&nbsp;A,&nbsp;as&nbsp;determined&nbsp;by&nbsp;automatic&nbsp;cutoff<br>
&nbsp;<br>
See&nbsp;also<br>
--------<br>
svd&nbsp;:&nbsp;Singular&nbsp;value&nbsp;decomposition&nbsp;of&nbsp;a&nbsp;matrix</tt></dd></dl>
 <dl><dt><a name="-orthogonal_procrustes"><strong>orthogonal_procrustes</strong></a>(A, B, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Compute&nbsp;the&nbsp;matrix&nbsp;solution&nbsp;of&nbsp;the&nbsp;orthogonal&nbsp;Procrustes&nbsp;problem.<br>
&nbsp;<br>
Given&nbsp;matrices&nbsp;A&nbsp;and&nbsp;B&nbsp;of&nbsp;equal&nbsp;shape,&nbsp;find&nbsp;an&nbsp;orthogonal&nbsp;matrix&nbsp;R<br>
that&nbsp;most&nbsp;closely&nbsp;maps&nbsp;A&nbsp;to&nbsp;B&nbsp;[1]_.<br>
Note&nbsp;that&nbsp;unlike&nbsp;higher&nbsp;level&nbsp;Procrustes&nbsp;analyses&nbsp;of&nbsp;spatial&nbsp;data,<br>
this&nbsp;function&nbsp;only&nbsp;uses&nbsp;orthogonal&nbsp;transformations&nbsp;like&nbsp;rotations<br>
and&nbsp;reflections,&nbsp;and&nbsp;it&nbsp;does&nbsp;not&nbsp;use&nbsp;scaling&nbsp;or&nbsp;translation.<br>
&nbsp;<br>
Parameters<br>
----------<br>
A&nbsp;:&nbsp;(M,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;to&nbsp;be&nbsp;mapped.<br>
B&nbsp;:&nbsp;(M,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Target&nbsp;matrix.<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrices&nbsp;contain&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
R&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;matrix&nbsp;solution&nbsp;of&nbsp;the&nbsp;orthogonal&nbsp;Procrustes&nbsp;problem.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Minimizes&nbsp;the&nbsp;Frobenius&nbsp;norm&nbsp;of&nbsp;dot(A,&nbsp;R)&nbsp;-&nbsp;B,&nbsp;subject&nbsp;to<br>
&nbsp;&nbsp;&nbsp;&nbsp;dot(R.T,&nbsp;R)&nbsp;==&nbsp;I.<br>
scale&nbsp;:&nbsp;float<br>
&nbsp;&nbsp;&nbsp;&nbsp;Sum&nbsp;of&nbsp;the&nbsp;singular&nbsp;values&nbsp;of&nbsp;``dot(A.T,&nbsp;B)``.<br>
&nbsp;<br>
Raises<br>
------<br>
ValueError<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;the&nbsp;input&nbsp;arrays&nbsp;are&nbsp;incompatibly&nbsp;shaped.<br>
&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;may&nbsp;also&nbsp;be&nbsp;raised&nbsp;if&nbsp;matrix&nbsp;A&nbsp;or&nbsp;B&nbsp;contains&nbsp;an&nbsp;inf&nbsp;or&nbsp;nan<br>
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;check_finite&nbsp;is&nbsp;True,&nbsp;or&nbsp;if&nbsp;the&nbsp;matrix&nbsp;product&nbsp;AB&nbsp;contains<br>
&nbsp;&nbsp;&nbsp;&nbsp;an&nbsp;inf&nbsp;or&nbsp;nan.<br>
&nbsp;<br>
Notes<br>
-----<br>
..&nbsp;versionadded::&nbsp;0.15.0<br>
&nbsp;<br>
References<br>
----------<br>
..&nbsp;[1]&nbsp;Peter&nbsp;H.&nbsp;Schonemann,&nbsp;"A&nbsp;generalized&nbsp;solution&nbsp;of&nbsp;the&nbsp;orthogonal<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Procrustes&nbsp;problem",&nbsp;Psychometrica&nbsp;--&nbsp;Vol.&nbsp;31,&nbsp;No.&nbsp;1,&nbsp;March,&nbsp;1996.</tt></dd></dl>
 <dl><dt><a name="-pascal"><strong>pascal</strong></a>(n, kind<font color="#909090">='symmetric'</font>, exact<font color="#909090">=True</font>)</dt><dd><tt>Returns&nbsp;the&nbsp;n&nbsp;x&nbsp;n&nbsp;Pascal&nbsp;matrix.<br>
&nbsp;<br>
The&nbsp;Pascal&nbsp;matrix&nbsp;is&nbsp;a&nbsp;matrix&nbsp;containing&nbsp;the&nbsp;binomial&nbsp;coefficients&nbsp;as<br>
its&nbsp;elements.<br>
&nbsp;<br>
Parameters<br>
----------<br>
n&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;size&nbsp;of&nbsp;the&nbsp;matrix&nbsp;to&nbsp;create;&nbsp;that&nbsp;is,&nbsp;the&nbsp;result&nbsp;is&nbsp;an&nbsp;n&nbsp;x&nbsp;n<br>
&nbsp;&nbsp;&nbsp;&nbsp;matrix.<br>
kind&nbsp;:&nbsp;str,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Must&nbsp;be&nbsp;one&nbsp;of&nbsp;'symmetric',&nbsp;'lower',&nbsp;or&nbsp;'upper'.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Default&nbsp;is&nbsp;'symmetric'.<br>
exact&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;`exact`&nbsp;is&nbsp;True,&nbsp;the&nbsp;result&nbsp;is&nbsp;either&nbsp;an&nbsp;array&nbsp;of&nbsp;type<br>
&nbsp;&nbsp;&nbsp;&nbsp;numpy.uint64&nbsp;(if&nbsp;n&nbsp;&lt;&nbsp;35)&nbsp;or&nbsp;an&nbsp;object&nbsp;array&nbsp;of&nbsp;Python&nbsp;long&nbsp;integers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;`exact`&nbsp;is&nbsp;False,&nbsp;the&nbsp;coefficients&nbsp;in&nbsp;the&nbsp;matrix&nbsp;are&nbsp;computed&nbsp;using<br>
&nbsp;&nbsp;&nbsp;&nbsp;`scipy.special.comb`&nbsp;with&nbsp;`exact=False`.&nbsp;&nbsp;The&nbsp;result&nbsp;will&nbsp;be&nbsp;a&nbsp;floating<br>
&nbsp;&nbsp;&nbsp;&nbsp;point&nbsp;array,&nbsp;and&nbsp;the&nbsp;values&nbsp;in&nbsp;the&nbsp;array&nbsp;will&nbsp;not&nbsp;be&nbsp;the&nbsp;exact<br>
&nbsp;&nbsp;&nbsp;&nbsp;coefficients,&nbsp;but&nbsp;this&nbsp;version&nbsp;is&nbsp;much&nbsp;faster&nbsp;than&nbsp;`exact=True`.<br>
&nbsp;<br>
Returns<br>
-------<br>
p&nbsp;:&nbsp;(n,&nbsp;n)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;Pascal&nbsp;matrix.<br>
&nbsp;<br>
See&nbsp;Also<br>
--------<br>
invpascal<br>
&nbsp;<br>
Notes<br>
-----<br>
See&nbsp;<a href="http://en.wikipedia.org/wiki/Pascal_matrix">http://en.wikipedia.org/wiki/Pascal_matrix</a>&nbsp;for&nbsp;more&nbsp;information<br>
about&nbsp;Pascal&nbsp;matrices.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;pascal<br>
&gt;&gt;&gt;&nbsp;<a href="#-pascal">pascal</a>(4)<br>
array([[&nbsp;1,&nbsp;&nbsp;1,&nbsp;&nbsp;1,&nbsp;&nbsp;1],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1,&nbsp;&nbsp;2,&nbsp;&nbsp;3,&nbsp;&nbsp;4],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1,&nbsp;&nbsp;3,&nbsp;&nbsp;6,&nbsp;10],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1,&nbsp;&nbsp;4,&nbsp;10,&nbsp;20]],&nbsp;dtype=uint64)<br>
&gt;&gt;&gt;&nbsp;<a href="#-pascal">pascal</a>(4,&nbsp;kind='lower')<br>
array([[1,&nbsp;0,&nbsp;0,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1,&nbsp;1,&nbsp;0,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1,&nbsp;2,&nbsp;1,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1,&nbsp;3,&nbsp;3,&nbsp;1]],&nbsp;dtype=uint64)<br>
&gt;&gt;&gt;&nbsp;<a href="#-pascal">pascal</a>(50)[-1,&nbsp;-1]<br>
25477612258980856902730428600L<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.special&nbsp;import&nbsp;comb<br>
&gt;&gt;&gt;&nbsp;comb(98,&nbsp;49,&nbsp;exact=True)<br>
25477612258980856902730428600L</tt></dd></dl>
 <dl><dt><a name="-pinv"><strong>pinv</strong></a>(a, cond<font color="#909090">=None</font>, rcond<font color="#909090">=None</font>, return_rank<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Compute&nbsp;the&nbsp;(Moore-Penrose)&nbsp;pseudo-inverse&nbsp;of&nbsp;a&nbsp;matrix.<br>
&nbsp;<br>
Calculate&nbsp;a&nbsp;generalized&nbsp;inverse&nbsp;of&nbsp;a&nbsp;matrix&nbsp;using&nbsp;a&nbsp;least-squares<br>
solver.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;to&nbsp;be&nbsp;pseudo-inverted.<br>
cond,&nbsp;rcond&nbsp;:&nbsp;float,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Cutoff&nbsp;for&nbsp;'small'&nbsp;singular&nbsp;values&nbsp;in&nbsp;the&nbsp;least-squares&nbsp;solver.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Singular&nbsp;values&nbsp;smaller&nbsp;than&nbsp;``rcond&nbsp;*&nbsp;largest_singular_value``<br>
&nbsp;&nbsp;&nbsp;&nbsp;are&nbsp;considered&nbsp;zero.<br>
return_rank&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;True,&nbsp;return&nbsp;the&nbsp;effective&nbsp;rank&nbsp;of&nbsp;the&nbsp;matrix<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
B&nbsp;:&nbsp;(N,&nbsp;M)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;pseudo-inverse&nbsp;of&nbsp;matrix&nbsp;`a`.<br>
rank&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;effective&nbsp;rank&nbsp;of&nbsp;the&nbsp;matrix.&nbsp;&nbsp;Returned&nbsp;if&nbsp;return_rank&nbsp;==&nbsp;True<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;computation&nbsp;does&nbsp;not&nbsp;converge.<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy&nbsp;import&nbsp;linalg<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.random.randn(9,&nbsp;6)<br>
&gt;&gt;&gt;&nbsp;B&nbsp;=&nbsp;linalg.<a href="#-pinv">pinv</a>(a)<br>
&gt;&gt;&gt;&nbsp;np.allclose(a,&nbsp;np.dot(a,&nbsp;np.dot(B,&nbsp;a)))<br>
True<br>
&gt;&gt;&gt;&nbsp;np.allclose(B,&nbsp;np.dot(B,&nbsp;np.dot(a,&nbsp;B)))<br>
True</tt></dd></dl>
 <dl><dt><a name="-pinv2"><strong>pinv2</strong></a>(a, cond<font color="#909090">=None</font>, rcond<font color="#909090">=None</font>, return_rank<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Compute&nbsp;the&nbsp;(Moore-Penrose)&nbsp;pseudo-inverse&nbsp;of&nbsp;a&nbsp;matrix.<br>
&nbsp;<br>
Calculate&nbsp;a&nbsp;generalized&nbsp;inverse&nbsp;of&nbsp;a&nbsp;matrix&nbsp;using&nbsp;its<br>
singular-value&nbsp;decomposition&nbsp;and&nbsp;including&nbsp;all&nbsp;'large'&nbsp;singular<br>
values.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;to&nbsp;be&nbsp;pseudo-inverted.<br>
cond,&nbsp;rcond&nbsp;:&nbsp;float&nbsp;or&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;Cutoff&nbsp;for&nbsp;'small'&nbsp;singular&nbsp;values.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Singular&nbsp;values&nbsp;smaller&nbsp;than&nbsp;``rcond*largest_singular_value``<br>
&nbsp;&nbsp;&nbsp;&nbsp;are&nbsp;considered&nbsp;zero.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;None&nbsp;or&nbsp;-1,&nbsp;suitable&nbsp;machine&nbsp;precision&nbsp;is&nbsp;used.<br>
return_rank&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;True,&nbsp;return&nbsp;the&nbsp;effective&nbsp;rank&nbsp;of&nbsp;the&nbsp;matrix<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
B&nbsp;:&nbsp;(N,&nbsp;M)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;pseudo-inverse&nbsp;of&nbsp;matrix&nbsp;`a`.<br>
rank&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;effective&nbsp;rank&nbsp;of&nbsp;the&nbsp;matrix.&nbsp;&nbsp;Returned&nbsp;if&nbsp;return_rank&nbsp;==&nbsp;True<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;SVD&nbsp;computation&nbsp;does&nbsp;not&nbsp;converge.<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy&nbsp;import&nbsp;linalg<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.random.randn(9,&nbsp;6)<br>
&gt;&gt;&gt;&nbsp;B&nbsp;=&nbsp;linalg.<a href="#-pinv2">pinv2</a>(a)<br>
&gt;&gt;&gt;&nbsp;np.allclose(a,&nbsp;np.dot(a,&nbsp;np.dot(B,&nbsp;a)))<br>
True<br>
&gt;&gt;&gt;&nbsp;np.allclose(B,&nbsp;np.dot(B,&nbsp;np.dot(a,&nbsp;B)))<br>
True</tt></dd></dl>
 <dl><dt><a name="-pinvh"><strong>pinvh</strong></a>(a, cond<font color="#909090">=None</font>, rcond<font color="#909090">=None</font>, lower<font color="#909090">=True</font>, return_rank<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Compute&nbsp;the&nbsp;(Moore-Penrose)&nbsp;pseudo-inverse&nbsp;of&nbsp;a&nbsp;Hermitian&nbsp;matrix.<br>
&nbsp;<br>
Calculate&nbsp;a&nbsp;generalized&nbsp;inverse&nbsp;of&nbsp;a&nbsp;Hermitian&nbsp;or&nbsp;real&nbsp;symmetric&nbsp;matrix<br>
using&nbsp;its&nbsp;eigenvalue&nbsp;decomposition&nbsp;and&nbsp;including&nbsp;all&nbsp;eigenvalues&nbsp;with<br>
'large'&nbsp;absolute&nbsp;value.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Real&nbsp;symmetric&nbsp;or&nbsp;complex&nbsp;hermetian&nbsp;matrix&nbsp;to&nbsp;be&nbsp;pseudo-inverted<br>
cond,&nbsp;rcond&nbsp;:&nbsp;float&nbsp;or&nbsp;None<br>
&nbsp;&nbsp;&nbsp;&nbsp;Cutoff&nbsp;for&nbsp;'small'&nbsp;eigenvalues.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Singular&nbsp;values&nbsp;smaller&nbsp;than&nbsp;rcond&nbsp;*&nbsp;largest_eigenvalue&nbsp;are&nbsp;considered<br>
&nbsp;&nbsp;&nbsp;&nbsp;zero.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;None&nbsp;or&nbsp;-1,&nbsp;suitable&nbsp;machine&nbsp;precision&nbsp;is&nbsp;used.<br>
lower&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;the&nbsp;pertinent&nbsp;array&nbsp;data&nbsp;is&nbsp;taken&nbsp;from&nbsp;the&nbsp;lower&nbsp;or&nbsp;upper<br>
&nbsp;&nbsp;&nbsp;&nbsp;triangle&nbsp;of&nbsp;a.&nbsp;(Default:&nbsp;lower)<br>
return_rank&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;True,&nbsp;return&nbsp;the&nbsp;effective&nbsp;rank&nbsp;of&nbsp;the&nbsp;matrix<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
B&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;pseudo-inverse&nbsp;of&nbsp;matrix&nbsp;`a`.<br>
rank&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;effective&nbsp;rank&nbsp;of&nbsp;the&nbsp;matrix.&nbsp;&nbsp;Returned&nbsp;if&nbsp;return_rank&nbsp;==&nbsp;True<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;eigenvalue&nbsp;does&nbsp;not&nbsp;converge<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;pinvh<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.random.randn(9,&nbsp;6)<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.dot(a,&nbsp;a.T)<br>
&gt;&gt;&gt;&nbsp;B&nbsp;=&nbsp;<a href="#-pinvh">pinvh</a>(a)<br>
&gt;&gt;&gt;&nbsp;np.allclose(a,&nbsp;np.dot(a,&nbsp;np.dot(B,&nbsp;a)))<br>
True<br>
&gt;&gt;&gt;&nbsp;np.allclose(B,&nbsp;np.dot(B,&nbsp;np.dot(a,&nbsp;B)))<br>
True</tt></dd></dl>
 <dl><dt><a name="-polar"><strong>polar</strong></a>(a, side<font color="#909090">='right'</font>)</dt><dd><tt>Compute&nbsp;the&nbsp;polar&nbsp;decomposition.<br>
&nbsp;<br>
Returns&nbsp;the&nbsp;factors&nbsp;of&nbsp;the&nbsp;polar&nbsp;decomposition&nbsp;[1]_&nbsp;`u`&nbsp;and&nbsp;`p`&nbsp;such<br>
that&nbsp;``a&nbsp;=&nbsp;up``&nbsp;(if&nbsp;`side`&nbsp;is&nbsp;"right")&nbsp;or&nbsp;``a&nbsp;=&nbsp;pu``&nbsp;(if&nbsp;`side`&nbsp;is<br>
"left"),&nbsp;where&nbsp;`p`&nbsp;is&nbsp;positive&nbsp;semidefinite.&nbsp;&nbsp;Depending&nbsp;on&nbsp;the&nbsp;shape<br>
of&nbsp;`a`,&nbsp;either&nbsp;the&nbsp;rows&nbsp;or&nbsp;columns&nbsp;of&nbsp;`u`&nbsp;are&nbsp;orthonormal.&nbsp;&nbsp;When&nbsp;`a`<br>
is&nbsp;a&nbsp;square&nbsp;array,&nbsp;`u`&nbsp;is&nbsp;a&nbsp;square&nbsp;unitary&nbsp;array.&nbsp;&nbsp;When&nbsp;`a`&nbsp;is&nbsp;not<br>
square,&nbsp;the&nbsp;"canonical&nbsp;polar&nbsp;decomposition"&nbsp;[2]_&nbsp;is&nbsp;computed.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(m,&nbsp;n)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;array&nbsp;to&nbsp;be&nbsp;factored.<br>
side&nbsp;:&nbsp;{'left',&nbsp;'right'},&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Determines&nbsp;whether&nbsp;a&nbsp;right&nbsp;or&nbsp;left&nbsp;polar&nbsp;decomposition&nbsp;is&nbsp;computed.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;`side`&nbsp;is&nbsp;"right",&nbsp;then&nbsp;``a&nbsp;=&nbsp;up``.&nbsp;&nbsp;If&nbsp;`side`&nbsp;is&nbsp;"left",&nbsp;&nbsp;then<br>
&nbsp;&nbsp;&nbsp;&nbsp;``a&nbsp;=&nbsp;pu``.&nbsp;&nbsp;The&nbsp;default&nbsp;is&nbsp;"right".<br>
&nbsp;<br>
Returns<br>
-------<br>
u&nbsp;:&nbsp;(m,&nbsp;n)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;`a`&nbsp;is&nbsp;square,&nbsp;then&nbsp;`u`&nbsp;is&nbsp;unitary.&nbsp;&nbsp;If&nbsp;m&nbsp;&gt;&nbsp;n,&nbsp;then&nbsp;the&nbsp;columns<br>
&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;`a`&nbsp;are&nbsp;orthonormal,&nbsp;and&nbsp;if&nbsp;m&nbsp;&lt;&nbsp;n,&nbsp;then&nbsp;the&nbsp;rows&nbsp;of&nbsp;`u`&nbsp;are<br>
&nbsp;&nbsp;&nbsp;&nbsp;orthonormal.<br>
p&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;`p`&nbsp;is&nbsp;Hermitian&nbsp;positive&nbsp;semidefinite.&nbsp;&nbsp;If&nbsp;`a`&nbsp;is&nbsp;nonsingular,&nbsp;`p`<br>
&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;positive&nbsp;definite.&nbsp;&nbsp;The&nbsp;shape&nbsp;of&nbsp;`p`&nbsp;is&nbsp;(n,&nbsp;n)&nbsp;or&nbsp;(m,&nbsp;m),&nbsp;depending<br>
&nbsp;&nbsp;&nbsp;&nbsp;on&nbsp;whether&nbsp;`side`&nbsp;is&nbsp;"right"&nbsp;or&nbsp;"left",&nbsp;respectively.<br>
&nbsp;<br>
References<br>
----------<br>
..&nbsp;[1]&nbsp;R.&nbsp;A.&nbsp;Horn&nbsp;and&nbsp;C.&nbsp;R.&nbsp;Johnson,&nbsp;"Matrix&nbsp;Analysis",&nbsp;Cambridge<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;University&nbsp;Press,&nbsp;1985.<br>
..&nbsp;[2]&nbsp;N.&nbsp;J.&nbsp;Higham,&nbsp;"Functions&nbsp;of&nbsp;Matrices:&nbsp;Theory&nbsp;and&nbsp;Computation",<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SIAM,&nbsp;2008.<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;polar<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([[1,&nbsp;-1],&nbsp;[2,&nbsp;4]])<br>
&gt;&gt;&gt;&nbsp;u,&nbsp;p&nbsp;=&nbsp;<a href="#-polar">polar</a>(a)<br>
&gt;&gt;&gt;&nbsp;u<br>
array([[&nbsp;0.85749293,&nbsp;-0.51449576],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.51449576,&nbsp;&nbsp;0.85749293]])<br>
&gt;&gt;&gt;&nbsp;p<br>
array([[&nbsp;1.88648444,&nbsp;&nbsp;1.2004901&nbsp;],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.2004901&nbsp;,&nbsp;&nbsp;3.94446746]])<br>
&nbsp;<br>
A&nbsp;non-square&nbsp;example,&nbsp;with&nbsp;m&nbsp;&lt;&nbsp;n:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;np.array([[0.5,&nbsp;1,&nbsp;2],&nbsp;[1.5,&nbsp;3,&nbsp;4]])<br>
&gt;&gt;&gt;&nbsp;u,&nbsp;p&nbsp;=&nbsp;<a href="#-polar">polar</a>(b)<br>
&gt;&gt;&gt;&nbsp;u<br>
array([[-0.21196618,&nbsp;-0.42393237,&nbsp;&nbsp;0.88054056],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.39378971,&nbsp;&nbsp;0.78757942,&nbsp;&nbsp;0.4739708&nbsp;]])<br>
&gt;&gt;&gt;&nbsp;p<br>
array([[&nbsp;0.48470147,&nbsp;&nbsp;0.96940295,&nbsp;&nbsp;1.15122648],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.96940295,&nbsp;&nbsp;1.9388059&nbsp;,&nbsp;&nbsp;2.30245295],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.15122648,&nbsp;&nbsp;2.30245295,&nbsp;&nbsp;3.65696431]])<br>
&gt;&gt;&gt;&nbsp;u.dot(p)&nbsp;&nbsp;&nbsp;#&nbsp;Verify&nbsp;the&nbsp;decomposition.<br>
array([[&nbsp;0.5,&nbsp;&nbsp;1.&nbsp;,&nbsp;&nbsp;2.&nbsp;],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.5,&nbsp;&nbsp;3.&nbsp;,&nbsp;&nbsp;4.&nbsp;]])<br>
&gt;&gt;&gt;&nbsp;u.dot(u.T)&nbsp;&nbsp;&nbsp;#&nbsp;The&nbsp;rows&nbsp;of&nbsp;u&nbsp;are&nbsp;orthonormal.<br>
array([[&nbsp;&nbsp;1.00000000e+00,&nbsp;&nbsp;-2.07353665e-17],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-2.07353665e-17,&nbsp;&nbsp;&nbsp;1.00000000e+00]])<br>
&nbsp;<br>
Another&nbsp;non-square&nbsp;example,&nbsp;with&nbsp;m&nbsp;&gt;&nbsp;n:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;c&nbsp;=&nbsp;b.T<br>
&gt;&gt;&gt;&nbsp;u,&nbsp;p&nbsp;=&nbsp;<a href="#-polar">polar</a>(c)<br>
&gt;&gt;&gt;&nbsp;u<br>
array([[-0.21196618,&nbsp;&nbsp;0.39378971],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.42393237,&nbsp;&nbsp;0.78757942],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.88054056,&nbsp;&nbsp;0.4739708&nbsp;]])<br>
&gt;&gt;&gt;&nbsp;p<br>
array([[&nbsp;1.23116567,&nbsp;&nbsp;1.93241587],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.93241587,&nbsp;&nbsp;4.84930602]])<br>
&gt;&gt;&gt;&nbsp;u.dot(p)&nbsp;&nbsp;&nbsp;#&nbsp;Verify&nbsp;the&nbsp;decomposition.<br>
array([[&nbsp;0.5,&nbsp;&nbsp;1.5],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.&nbsp;,&nbsp;&nbsp;3.&nbsp;],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;2.&nbsp;,&nbsp;&nbsp;4.&nbsp;]])<br>
&gt;&gt;&gt;&nbsp;u.T.dot(u)&nbsp;&nbsp;#&nbsp;The&nbsp;columns&nbsp;of&nbsp;u&nbsp;are&nbsp;orthonormal.<br>
array([[&nbsp;&nbsp;1.00000000e+00,&nbsp;&nbsp;-1.26363763e-16],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-1.26363763e-16,&nbsp;&nbsp;&nbsp;1.00000000e+00]])</tt></dd></dl>
 <dl><dt><a name="-qr"><strong>qr</strong></a>(a, overwrite_a<font color="#909090">=False</font>, lwork<font color="#909090">=None</font>, mode<font color="#909090">='full'</font>, pivoting<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Compute&nbsp;QR&nbsp;decomposition&nbsp;of&nbsp;a&nbsp;matrix.<br>
&nbsp;<br>
Calculate&nbsp;the&nbsp;decomposition&nbsp;``A&nbsp;=&nbsp;Q&nbsp;R``&nbsp;where&nbsp;Q&nbsp;is&nbsp;unitary/orthogonal<br>
and&nbsp;R&nbsp;upper&nbsp;triangular.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;to&nbsp;be&nbsp;decomposed<br>
overwrite_a&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;data&nbsp;in&nbsp;a&nbsp;is&nbsp;overwritten&nbsp;(may&nbsp;improve&nbsp;performance)<br>
lwork&nbsp;:&nbsp;int,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Work&nbsp;array&nbsp;size,&nbsp;lwork&nbsp;&gt;=&nbsp;a.shape[1].&nbsp;If&nbsp;None&nbsp;or&nbsp;-1,&nbsp;an&nbsp;optimal&nbsp;size<br>
&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;computed.<br>
mode&nbsp;:&nbsp;{'full',&nbsp;'r',&nbsp;'economic',&nbsp;'raw'},&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Determines&nbsp;what&nbsp;information&nbsp;is&nbsp;to&nbsp;be&nbsp;returned:&nbsp;either&nbsp;both&nbsp;Q&nbsp;and&nbsp;R<br>
&nbsp;&nbsp;&nbsp;&nbsp;('full',&nbsp;default),&nbsp;only&nbsp;R&nbsp;('r')&nbsp;or&nbsp;both&nbsp;Q&nbsp;and&nbsp;R&nbsp;but&nbsp;computed&nbsp;in<br>
&nbsp;&nbsp;&nbsp;&nbsp;economy-size&nbsp;('economic',&nbsp;see&nbsp;Notes).&nbsp;The&nbsp;final&nbsp;option&nbsp;'raw'<br>
&nbsp;&nbsp;&nbsp;&nbsp;(added&nbsp;in&nbsp;Scipy&nbsp;0.11)&nbsp;makes&nbsp;the&nbsp;function&nbsp;return&nbsp;two&nbsp;matrices<br>
&nbsp;&nbsp;&nbsp;&nbsp;(Q,&nbsp;TAU)&nbsp;in&nbsp;the&nbsp;internal&nbsp;format&nbsp;used&nbsp;by&nbsp;LAPACK.<br>
pivoting&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;or&nbsp;not&nbsp;factorization&nbsp;should&nbsp;include&nbsp;pivoting&nbsp;for&nbsp;rank-revealing<br>
&nbsp;&nbsp;&nbsp;&nbsp;qr&nbsp;decomposition.&nbsp;If&nbsp;pivoting,&nbsp;compute&nbsp;the&nbsp;decomposition<br>
&nbsp;&nbsp;&nbsp;&nbsp;``A&nbsp;P&nbsp;=&nbsp;Q&nbsp;R``&nbsp;as&nbsp;above,&nbsp;but&nbsp;where&nbsp;P&nbsp;is&nbsp;chosen&nbsp;such&nbsp;that&nbsp;the&nbsp;diagonal<br>
&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;R&nbsp;is&nbsp;non-increasing.<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
Q&nbsp;:&nbsp;float&nbsp;or&nbsp;complex&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Of&nbsp;shape&nbsp;(M,&nbsp;M),&nbsp;or&nbsp;(M,&nbsp;K)&nbsp;for&nbsp;``mode='economic'``.&nbsp;&nbsp;Not&nbsp;returned<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;``mode='r'``.<br>
R&nbsp;:&nbsp;float&nbsp;or&nbsp;complex&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Of&nbsp;shape&nbsp;(M,&nbsp;N),&nbsp;or&nbsp;(K,&nbsp;N)&nbsp;for&nbsp;``mode='economic'``.&nbsp;&nbsp;``K&nbsp;=&nbsp;min(M,&nbsp;N)``.<br>
P&nbsp;:&nbsp;int&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Of&nbsp;shape&nbsp;(N,)&nbsp;for&nbsp;``pivoting=True``.&nbsp;Not&nbsp;returned&nbsp;if<br>
&nbsp;&nbsp;&nbsp;&nbsp;``pivoting=False``.<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;Raised&nbsp;if&nbsp;decomposition&nbsp;fails<br>
&nbsp;<br>
Notes<br>
-----<br>
This&nbsp;is&nbsp;an&nbsp;interface&nbsp;to&nbsp;the&nbsp;LAPACK&nbsp;routines&nbsp;dgeqrf,&nbsp;zgeqrf,<br>
dorgqr,&nbsp;zungqr,&nbsp;dgeqp3,&nbsp;and&nbsp;zgeqp3.<br>
&nbsp;<br>
If&nbsp;``mode=economic``,&nbsp;the&nbsp;shapes&nbsp;of&nbsp;Q&nbsp;and&nbsp;R&nbsp;are&nbsp;(M,&nbsp;K)&nbsp;and&nbsp;(K,&nbsp;N)&nbsp;instead<br>
of&nbsp;(M,M)&nbsp;and&nbsp;(M,N),&nbsp;with&nbsp;``K=min(M,N)``.<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy&nbsp;import&nbsp;random,&nbsp;linalg,&nbsp;dot,&nbsp;diag,&nbsp;all,&nbsp;allclose<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;random.randn(9,&nbsp;6)<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;q,&nbsp;r&nbsp;=&nbsp;linalg.<a href="#-qr">qr</a>(a)<br>
&gt;&gt;&gt;&nbsp;allclose(a,&nbsp;np.dot(q,&nbsp;r))<br>
True<br>
&gt;&gt;&gt;&nbsp;q.shape,&nbsp;r.shape<br>
((9,&nbsp;9),&nbsp;(9,&nbsp;6))<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;r2&nbsp;=&nbsp;linalg.<a href="#-qr">qr</a>(a,&nbsp;mode='r')<br>
&gt;&gt;&gt;&nbsp;allclose(r,&nbsp;r2)<br>
True<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;q3,&nbsp;r3&nbsp;=&nbsp;linalg.<a href="#-qr">qr</a>(a,&nbsp;mode='economic')<br>
&gt;&gt;&gt;&nbsp;q3.shape,&nbsp;r3.shape<br>
((9,&nbsp;6),&nbsp;(6,&nbsp;6))<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;q4,&nbsp;r4,&nbsp;p4&nbsp;=&nbsp;linalg.<a href="#-qr">qr</a>(a,&nbsp;pivoting=True)<br>
&gt;&gt;&gt;&nbsp;d&nbsp;=&nbsp;abs(diag(r4))<br>
&gt;&gt;&gt;&nbsp;all(d[1:]&nbsp;&lt;=&nbsp;d[:-1])<br>
True<br>
&gt;&gt;&gt;&nbsp;allclose(a[:,&nbsp;p4],&nbsp;dot(q4,&nbsp;r4))<br>
True<br>
&gt;&gt;&gt;&nbsp;q4.shape,&nbsp;r4.shape,&nbsp;p4.shape<br>
((9,&nbsp;9),&nbsp;(9,&nbsp;6),&nbsp;(6,))<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;q5,&nbsp;r5,&nbsp;p5&nbsp;=&nbsp;linalg.<a href="#-qr">qr</a>(a,&nbsp;mode='economic',&nbsp;pivoting=True)<br>
&gt;&gt;&gt;&nbsp;q5.shape,&nbsp;r5.shape,&nbsp;p5.shape<br>
((9,&nbsp;6),&nbsp;(6,&nbsp;6),&nbsp;(6,))</tt></dd></dl>
 <dl><dt><a name="-qr_delete"><strong>qr_delete</strong></a>(...)</dt><dd><tt><a href="#-qr_delete">qr_delete</a>(Q,&nbsp;R,&nbsp;k,&nbsp;int&nbsp;p=1,&nbsp;which='row',&nbsp;overwrite_qr=False,&nbsp;check_finite=True)<br>
&nbsp;<br>
QR&nbsp;downdate&nbsp;on&nbsp;row&nbsp;or&nbsp;column&nbsp;deletions<br>
&nbsp;<br>
If&nbsp;``A&nbsp;=&nbsp;Q&nbsp;R``&nbsp;is&nbsp;the&nbsp;QR&nbsp;factorization&nbsp;of&nbsp;``A``,&nbsp;return&nbsp;the&nbsp;QR<br>
factorization&nbsp;of&nbsp;``A``&nbsp;where&nbsp;``p``&nbsp;rows&nbsp;or&nbsp;columns&nbsp;have&nbsp;been&nbsp;removed<br>
starting&nbsp;at&nbsp;row&nbsp;or&nbsp;column&nbsp;``k``.<br>
&nbsp;<br>
Parameters<br>
----------<br>
Q&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;or&nbsp;(M,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Unitary/orthogonal&nbsp;matrix&nbsp;from&nbsp;QR&nbsp;decomposition.<br>
R&nbsp;:&nbsp;(M,&nbsp;N)&nbsp;or&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Upper&nbsp;triangular&nbsp;matrix&nbsp;from&nbsp;QR&nbsp;decomposition.<br>
k&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;Index&nbsp;of&nbsp;the&nbsp;first&nbsp;row&nbsp;or&nbsp;column&nbsp;to&nbsp;delete.<br>
p&nbsp;:&nbsp;int,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Number&nbsp;of&nbsp;rows&nbsp;or&nbsp;columns&nbsp;to&nbsp;delete,&nbsp;defaults&nbsp;to&nbsp;1.<br>
which:&nbsp;{'row',&nbsp;'col'},&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Determines&nbsp;if&nbsp;rows&nbsp;or&nbsp;columns&nbsp;will&nbsp;be&nbsp;deleted,&nbsp;defaults&nbsp;to&nbsp;'row'<br>
overwrite_qr&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;consume&nbsp;Q&nbsp;and&nbsp;R,&nbsp;overwriting&nbsp;their&nbsp;contents&nbsp;with&nbsp;their<br>
&nbsp;&nbsp;&nbsp;&nbsp;downdated&nbsp;versions,&nbsp;and&nbsp;returning&nbsp;approriately&nbsp;sized&nbsp;views.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Defaults&nbsp;to&nbsp;False.<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Default&nbsp;is&nbsp;True.<br>
&nbsp;<br>
Returns<br>
-------<br>
Q1&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Updated&nbsp;unitary/orthogonal&nbsp;factor<br>
R1&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Updated&nbsp;upper&nbsp;triangular&nbsp;factor<br>
&nbsp;<br>
See&nbsp;Also<br>
--------<br>
qr,&nbsp;qr_multiply,&nbsp;qr_insert,&nbsp;qr_update<br>
&nbsp;<br>
Notes<br>
-----<br>
This&nbsp;routine&nbsp;does&nbsp;not&nbsp;guarantee&nbsp;that&nbsp;the&nbsp;diagonal&nbsp;entries&nbsp;of&nbsp;``R1``&nbsp;are<br>
positive.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.16.0<br>
&nbsp;<br>
References<br>
----------<br>
..&nbsp;[1]&nbsp;Golub,&nbsp;G.&nbsp;H.&nbsp;&amp;&nbsp;Van&nbsp;Loan,&nbsp;C.&nbsp;F.&nbsp;Matrix&nbsp;Computations,&nbsp;3rd&nbsp;Ed.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Johns&nbsp;Hopkins&nbsp;University&nbsp;Press,&nbsp;1996).<br>
&nbsp;<br>
..&nbsp;[2]&nbsp;Daniel,&nbsp;J.&nbsp;W.,&nbsp;Gragg,&nbsp;W.&nbsp;B.,&nbsp;Kaufman,&nbsp;L.&nbsp;&amp;&nbsp;Stewart,&nbsp;G.&nbsp;W.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reorthogonalization&nbsp;and&nbsp;stable&nbsp;algorithms&nbsp;for&nbsp;updating&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gram-Schmidt&nbsp;QR&nbsp;factorization.&nbsp;Math.&nbsp;Comput.&nbsp;30,&nbsp;772-795&nbsp;(1976).<br>
&nbsp;<br>
..&nbsp;[3]&nbsp;Reichel,&nbsp;L.&nbsp;&amp;&nbsp;Gragg,&nbsp;W.&nbsp;B.&nbsp;Algorithm&nbsp;686:&nbsp;FORTRAN&nbsp;Subroutines&nbsp;for<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Updating&nbsp;the&nbsp;QR&nbsp;Decomposition.&nbsp;ACM&nbsp;Trans.&nbsp;Math.&nbsp;Softw.&nbsp;16,&nbsp;369-377<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1990).<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy&nbsp;import&nbsp;linalg<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([[&nbsp;&nbsp;3.,&nbsp;&nbsp;-2.,&nbsp;&nbsp;-2.],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;6.,&nbsp;&nbsp;-9.,&nbsp;&nbsp;-3.],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-3.,&nbsp;&nbsp;10.,&nbsp;&nbsp;&nbsp;1.],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;6.,&nbsp;&nbsp;-7.,&nbsp;&nbsp;&nbsp;4.],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;7.,&nbsp;&nbsp;&nbsp;8.,&nbsp;&nbsp;-6.]])<br>
&gt;&gt;&gt;&nbsp;q,&nbsp;r&nbsp;=&nbsp;linalg.<a href="#-qr">qr</a>(a)<br>
&nbsp;<br>
Given&nbsp;this&nbsp;QR&nbsp;decomposition,&nbsp;update&nbsp;q&nbsp;and&nbsp;r&nbsp;when&nbsp;2&nbsp;rows&nbsp;are&nbsp;removed.<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;q1,&nbsp;r1&nbsp;=&nbsp;linalg.<a href="#-qr_delete">qr_delete</a>(q,&nbsp;r,&nbsp;2,&nbsp;2,&nbsp;'row',&nbsp;False)<br>
&gt;&gt;&gt;&nbsp;q1<br>
array([[&nbsp;0.30942637,&nbsp;&nbsp;0.15347579,&nbsp;&nbsp;0.93845645],&nbsp;&nbsp;#&nbsp;may&nbsp;vary&nbsp;(signs)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.61885275,&nbsp;&nbsp;0.71680171,&nbsp;-0.32127338],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.72199487,&nbsp;-0.68017681,&nbsp;-0.12681844]])<br>
&gt;&gt;&gt;&nbsp;r1<br>
array([[&nbsp;&nbsp;9.69535971,&nbsp;&nbsp;-0.4125685&nbsp;,&nbsp;&nbsp;-6.80738023],&nbsp;&nbsp;#&nbsp;may&nbsp;vary&nbsp;(signs)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;-12.19958144,&nbsp;&nbsp;&nbsp;1.62370412],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;-0.15218213]])<br>
&nbsp;<br>
The&nbsp;update&nbsp;is&nbsp;equivalent,&nbsp;but&nbsp;faster&nbsp;than&nbsp;the&nbsp;following.<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;a1&nbsp;=&nbsp;np.delete(a,&nbsp;slice(2,4),&nbsp;0)<br>
&gt;&gt;&gt;&nbsp;a1<br>
array([[&nbsp;3.,&nbsp;-2.,&nbsp;-2.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;6.,&nbsp;-9.,&nbsp;-3.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;7.,&nbsp;&nbsp;8.,&nbsp;-6.]])<br>
&gt;&gt;&gt;&nbsp;q_direct,&nbsp;r_direct&nbsp;=&nbsp;linalg.<a href="#-qr">qr</a>(a1)<br>
&nbsp;<br>
Check&nbsp;that&nbsp;we&nbsp;have&nbsp;equivalent&nbsp;results:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;np.dot(q1,&nbsp;r1)<br>
array([[&nbsp;3.,&nbsp;-2.,&nbsp;-2.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;6.,&nbsp;-9.,&nbsp;-3.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;7.,&nbsp;&nbsp;8.,&nbsp;-6.]])<br>
&gt;&gt;&gt;&nbsp;np.allclose(np.dot(q1,&nbsp;r1),&nbsp;a1)<br>
True<br>
&nbsp;<br>
And&nbsp;the&nbsp;updated&nbsp;Q&nbsp;is&nbsp;still&nbsp;unitary:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;np.allclose(np.dot(q1.T,&nbsp;q1),&nbsp;np.eye(3))<br>
True</tt></dd></dl>
 <dl><dt><a name="-qr_insert"><strong>qr_insert</strong></a>(...)</dt><dd><tt><a href="#-qr_insert">qr_insert</a>(Q,&nbsp;R,&nbsp;u,&nbsp;k,&nbsp;which='row',&nbsp;rcond=None,&nbsp;overwrite_qru=False,&nbsp;check_finite=True)<br>
&nbsp;<br>
QR&nbsp;update&nbsp;on&nbsp;row&nbsp;or&nbsp;column&nbsp;insertions<br>
&nbsp;<br>
If&nbsp;``A&nbsp;=&nbsp;Q&nbsp;R``&nbsp;is&nbsp;the&nbsp;QR&nbsp;factorization&nbsp;of&nbsp;``A``,&nbsp;return&nbsp;the&nbsp;QR<br>
factorization&nbsp;of&nbsp;``A``&nbsp;where&nbsp;rows&nbsp;or&nbsp;columns&nbsp;have&nbsp;been&nbsp;inserted&nbsp;starting<br>
at&nbsp;row&nbsp;or&nbsp;column&nbsp;``k``.<br>
&nbsp;<br>
Parameters<br>
----------<br>
Q&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Unitary/orthogonal&nbsp;matrix&nbsp;from&nbsp;the&nbsp;QR&nbsp;decomposition&nbsp;of&nbsp;A.<br>
R&nbsp;:&nbsp;(M,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Upper&nbsp;triangular&nbsp;matrix&nbsp;from&nbsp;the&nbsp;QR&nbsp;decomposition&nbsp;of&nbsp;A.<br>
u&nbsp;:&nbsp;(N,),&nbsp;(p,&nbsp;N),&nbsp;(M,),&nbsp;or&nbsp;(M,&nbsp;p)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Rows&nbsp;or&nbsp;columns&nbsp;to&nbsp;insert<br>
k&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;Index&nbsp;before&nbsp;which&nbsp;`u`&nbsp;is&nbsp;to&nbsp;be&nbsp;inserted.<br>
which:&nbsp;{'row',&nbsp;'col'},&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Determines&nbsp;if&nbsp;rows&nbsp;or&nbsp;columns&nbsp;will&nbsp;be&nbsp;inserted,&nbsp;defaults&nbsp;to&nbsp;'row'<br>
rcond&nbsp;:&nbsp;float<br>
&nbsp;&nbsp;&nbsp;&nbsp;Lower&nbsp;bound&nbsp;on&nbsp;the&nbsp;reciprocal&nbsp;condition&nbsp;number&nbsp;of&nbsp;``Q``&nbsp;augmented&nbsp;with<br>
&nbsp;&nbsp;&nbsp;&nbsp;``u/||u||``&nbsp;Only&nbsp;used&nbsp;when&nbsp;updating&nbsp;economic&nbsp;mode&nbsp;(thin,&nbsp;(M,N)&nbsp;(N,N))<br>
&nbsp;&nbsp;&nbsp;&nbsp;decompositions.&nbsp;&nbsp;If&nbsp;None,&nbsp;machine&nbsp;precision&nbsp;is&nbsp;used.&nbsp;&nbsp;Defaults&nbsp;to<br>
&nbsp;&nbsp;&nbsp;&nbsp;None.<br>
overwrite_qru&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;consume&nbsp;Q,&nbsp;R,&nbsp;and&nbsp;u,&nbsp;if&nbsp;possible,&nbsp;while&nbsp;performing&nbsp;the&nbsp;update,<br>
&nbsp;&nbsp;&nbsp;&nbsp;otherwise&nbsp;make&nbsp;copies&nbsp;as&nbsp;necessary.&nbsp;Defaults&nbsp;to&nbsp;False.<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrices&nbsp;contain&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Default&nbsp;is&nbsp;True.<br>
&nbsp;<br>
Returns<br>
-------<br>
Q1&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Updated&nbsp;unitary/orthogonal&nbsp;factor<br>
R1&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Updated&nbsp;upper&nbsp;triangular&nbsp;factor<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a>&nbsp;:<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;updating&nbsp;a&nbsp;(M,N)&nbsp;(N,N)&nbsp;factorization&nbsp;and&nbsp;the&nbsp;reciprocal&nbsp;condition<br>
&nbsp;&nbsp;&nbsp;&nbsp;number&nbsp;of&nbsp;Q&nbsp;augmented&nbsp;with&nbsp;u/||u||&nbsp;is&nbsp;smaller&nbsp;than&nbsp;rcond.<br>
&nbsp;<br>
See&nbsp;Also<br>
--------<br>
qr,&nbsp;qr_multiply,&nbsp;qr_delete,&nbsp;qr_update<br>
&nbsp;<br>
Notes<br>
-----<br>
This&nbsp;routine&nbsp;does&nbsp;not&nbsp;guarantee&nbsp;that&nbsp;the&nbsp;diagonal&nbsp;entries&nbsp;of&nbsp;``R1``&nbsp;are<br>
positive.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.16.0<br>
&nbsp;<br>
References<br>
----------<br>
&nbsp;<br>
..&nbsp;[1]&nbsp;Golub,&nbsp;G.&nbsp;H.&nbsp;&amp;&nbsp;Van&nbsp;Loan,&nbsp;C.&nbsp;F.&nbsp;Matrix&nbsp;Computations,&nbsp;3rd&nbsp;Ed.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Johns&nbsp;Hopkins&nbsp;University&nbsp;Press,&nbsp;1996).<br>
&nbsp;<br>
..&nbsp;[2]&nbsp;Daniel,&nbsp;J.&nbsp;W.,&nbsp;Gragg,&nbsp;W.&nbsp;B.,&nbsp;Kaufman,&nbsp;L.&nbsp;&amp;&nbsp;Stewart,&nbsp;G.&nbsp;W.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reorthogonalization&nbsp;and&nbsp;stable&nbsp;algorithms&nbsp;for&nbsp;updating&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gram-Schmidt&nbsp;QR&nbsp;factorization.&nbsp;Math.&nbsp;Comput.&nbsp;30,&nbsp;772-795&nbsp;(1976).<br>
&nbsp;<br>
..&nbsp;[3]&nbsp;Reichel,&nbsp;L.&nbsp;&amp;&nbsp;Gragg,&nbsp;W.&nbsp;B.&nbsp;Algorithm&nbsp;686:&nbsp;FORTRAN&nbsp;Subroutines&nbsp;for<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Updating&nbsp;the&nbsp;QR&nbsp;Decomposition.&nbsp;ACM&nbsp;Trans.&nbsp;Math.&nbsp;Softw.&nbsp;16,&nbsp;369-377<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1990).<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy&nbsp;import&nbsp;linalg<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([[&nbsp;&nbsp;3.,&nbsp;&nbsp;-2.,&nbsp;&nbsp;-2.],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;6.,&nbsp;&nbsp;-7.,&nbsp;&nbsp;&nbsp;4.],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;7.,&nbsp;&nbsp;&nbsp;8.,&nbsp;&nbsp;-6.]])<br>
&gt;&gt;&gt;&nbsp;q,&nbsp;r&nbsp;=&nbsp;linalg.<a href="#-qr">qr</a>(a)<br>
&nbsp;<br>
Given&nbsp;this&nbsp;QR&nbsp;decomposition,&nbsp;update&nbsp;q&nbsp;and&nbsp;r&nbsp;when&nbsp;2&nbsp;rows&nbsp;are&nbsp;inserted.<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;u&nbsp;=&nbsp;np.array([[&nbsp;&nbsp;6.,&nbsp;&nbsp;-9.,&nbsp;&nbsp;-3.],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-3.,&nbsp;&nbsp;10.,&nbsp;&nbsp;&nbsp;1.]])<br>
&gt;&gt;&gt;&nbsp;q1,&nbsp;r1&nbsp;=&nbsp;linalg.<a href="#-qr_insert">qr_insert</a>(q,&nbsp;r,&nbsp;u,&nbsp;2,&nbsp;'row')<br>
&gt;&gt;&gt;&nbsp;q1<br>
array([[-0.25445668,&nbsp;&nbsp;0.02246245,&nbsp;&nbsp;0.18146236,&nbsp;-0.72798806,&nbsp;&nbsp;0.60979671],&nbsp;&nbsp;#&nbsp;may&nbsp;vary&nbsp;(signs)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.50891336,&nbsp;&nbsp;0.23226178,&nbsp;-0.82836478,&nbsp;-0.02837033,&nbsp;-0.00828114],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.50891336,&nbsp;&nbsp;0.35715302,&nbsp;&nbsp;0.38937158,&nbsp;&nbsp;0.58110733,&nbsp;&nbsp;0.35235345],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.25445668,&nbsp;-0.52202743,&nbsp;-0.32165498,&nbsp;&nbsp;0.36263239,&nbsp;&nbsp;0.65404509],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.59373225,&nbsp;-0.73856549,&nbsp;&nbsp;0.16065817,&nbsp;-0.0063658&nbsp;,&nbsp;-0.27595554]])<br>
&gt;&gt;&gt;&nbsp;r1<br>
array([[-11.78982612,&nbsp;&nbsp;&nbsp;6.44623587,&nbsp;&nbsp;&nbsp;3.81685018],&nbsp;&nbsp;#&nbsp;may&nbsp;vary&nbsp;(signs)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;-16.01393278,&nbsp;&nbsp;&nbsp;3.72202865],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;-6.13010256],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]])<br>
&nbsp;<br>
The&nbsp;update&nbsp;is&nbsp;equivalent,&nbsp;but&nbsp;faster&nbsp;than&nbsp;the&nbsp;following.<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;a1&nbsp;=&nbsp;np.insert(a,&nbsp;2,&nbsp;u,&nbsp;0)<br>
&gt;&gt;&gt;&nbsp;a1<br>
array([[&nbsp;&nbsp;3.,&nbsp;&nbsp;-2.,&nbsp;&nbsp;-2.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;6.,&nbsp;&nbsp;-7.,&nbsp;&nbsp;&nbsp;4.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;6.,&nbsp;&nbsp;-9.,&nbsp;&nbsp;-3.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-3.,&nbsp;&nbsp;10.,&nbsp;&nbsp;&nbsp;1.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;7.,&nbsp;&nbsp;&nbsp;8.,&nbsp;&nbsp;-6.]])<br>
&gt;&gt;&gt;&nbsp;q_direct,&nbsp;r_direct&nbsp;=&nbsp;linalg.<a href="#-qr">qr</a>(a1)<br>
&nbsp;<br>
Check&nbsp;that&nbsp;we&nbsp;have&nbsp;equivalent&nbsp;results:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;np.dot(q1,&nbsp;r1)<br>
array([[&nbsp;&nbsp;3.,&nbsp;&nbsp;-2.,&nbsp;&nbsp;-2.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;6.,&nbsp;&nbsp;-7.,&nbsp;&nbsp;&nbsp;4.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;6.,&nbsp;&nbsp;-9.,&nbsp;&nbsp;-3.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-3.,&nbsp;&nbsp;10.,&nbsp;&nbsp;&nbsp;1.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;7.,&nbsp;&nbsp;&nbsp;8.,&nbsp;&nbsp;-6.]])<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;np.allclose(np.dot(q1,&nbsp;r1),&nbsp;a1)<br>
True<br>
&nbsp;<br>
And&nbsp;the&nbsp;updated&nbsp;Q&nbsp;is&nbsp;still&nbsp;unitary:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;np.allclose(np.dot(q1.T,&nbsp;q1),&nbsp;np.eye(5))<br>
True</tt></dd></dl>
 <dl><dt><a name="-qr_multiply"><strong>qr_multiply</strong></a>(a, c, mode<font color="#909090">='right'</font>, pivoting<font color="#909090">=False</font>, conjugate<font color="#909090">=False</font>, overwrite_a<font color="#909090">=False</font>, overwrite_c<font color="#909090">=False</font>)</dt><dd><tt>Calculate&nbsp;the&nbsp;QR&nbsp;decomposition&nbsp;and&nbsp;multiply&nbsp;Q&nbsp;with&nbsp;a&nbsp;matrix.<br>
&nbsp;<br>
Calculate&nbsp;the&nbsp;decomposition&nbsp;``A&nbsp;=&nbsp;Q&nbsp;R``&nbsp;where&nbsp;Q&nbsp;is&nbsp;unitary/orthogonal<br>
and&nbsp;R&nbsp;upper&nbsp;triangular.&nbsp;Multiply&nbsp;Q&nbsp;with&nbsp;a&nbsp;vector&nbsp;or&nbsp;a&nbsp;matrix&nbsp;c.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;array_like,&nbsp;shape&nbsp;(M,&nbsp;N)<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;to&nbsp;be&nbsp;decomposed<br>
c&nbsp;:&nbsp;array_like,&nbsp;one-&nbsp;or&nbsp;two-dimensional<br>
&nbsp;&nbsp;&nbsp;&nbsp;calculate&nbsp;the&nbsp;product&nbsp;of&nbsp;c&nbsp;and&nbsp;q,&nbsp;depending&nbsp;on&nbsp;the&nbsp;mode:<br>
mode&nbsp;:&nbsp;{'left',&nbsp;'right'},&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;``dot(Q,&nbsp;c)``&nbsp;is&nbsp;returned&nbsp;if&nbsp;mode&nbsp;is&nbsp;'left',<br>
&nbsp;&nbsp;&nbsp;&nbsp;``dot(c,&nbsp;Q)``&nbsp;is&nbsp;returned&nbsp;if&nbsp;mode&nbsp;is&nbsp;'right'.<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;shape&nbsp;of&nbsp;c&nbsp;must&nbsp;be&nbsp;appropriate&nbsp;for&nbsp;the&nbsp;matrix&nbsp;multiplications,<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;mode&nbsp;is&nbsp;'left',&nbsp;``min(a.shape)&nbsp;==&nbsp;c.shape[0]``,<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;mode&nbsp;is&nbsp;'right',&nbsp;``a.shape[0]&nbsp;==&nbsp;c.shape[1]``.<br>
pivoting&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;or&nbsp;not&nbsp;factorization&nbsp;should&nbsp;include&nbsp;pivoting&nbsp;for&nbsp;rank-revealing<br>
&nbsp;&nbsp;&nbsp;&nbsp;qr&nbsp;decomposition,&nbsp;see&nbsp;the&nbsp;documentation&nbsp;of&nbsp;qr.<br>
conjugate&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;Q&nbsp;should&nbsp;be&nbsp;complex-conjugated.&nbsp;This&nbsp;might&nbsp;be&nbsp;faster<br>
&nbsp;&nbsp;&nbsp;&nbsp;than&nbsp;explicit&nbsp;conjugation.<br>
overwrite_a&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;data&nbsp;in&nbsp;a&nbsp;is&nbsp;overwritten&nbsp;(may&nbsp;improve&nbsp;performance)<br>
overwrite_c&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;data&nbsp;in&nbsp;c&nbsp;is&nbsp;overwritten&nbsp;(may&nbsp;improve&nbsp;performance).<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;this&nbsp;is&nbsp;used,&nbsp;c&nbsp;must&nbsp;be&nbsp;big&nbsp;enough&nbsp;to&nbsp;keep&nbsp;the&nbsp;result,<br>
&nbsp;&nbsp;&nbsp;&nbsp;i.e.&nbsp;c.shape[0]&nbsp;=&nbsp;a.shape[0]&nbsp;if&nbsp;mode&nbsp;is&nbsp;'left'.<br>
&nbsp;<br>
&nbsp;<br>
Returns<br>
-------<br>
CQ&nbsp;:&nbsp;float&nbsp;or&nbsp;complex&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;product&nbsp;of&nbsp;Q&nbsp;and&nbsp;c,&nbsp;as&nbsp;defined&nbsp;in&nbsp;mode<br>
R&nbsp;:&nbsp;float&nbsp;or&nbsp;complex&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Of&nbsp;shape&nbsp;(K,&nbsp;N),&nbsp;``K&nbsp;=&nbsp;min(M,&nbsp;N)``.<br>
P&nbsp;:&nbsp;ndarray&nbsp;of&nbsp;ints<br>
&nbsp;&nbsp;&nbsp;&nbsp;Of&nbsp;shape&nbsp;(N,)&nbsp;for&nbsp;``pivoting=True``.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Not&nbsp;returned&nbsp;if&nbsp;``pivoting=False``.<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;Raised&nbsp;if&nbsp;decomposition&nbsp;fails<br>
&nbsp;<br>
Notes<br>
-----<br>
This&nbsp;is&nbsp;an&nbsp;interface&nbsp;to&nbsp;the&nbsp;LAPACK&nbsp;routines&nbsp;dgeqrf,&nbsp;zgeqrf,<br>
dormqr,&nbsp;zunmqr,&nbsp;dgeqp3,&nbsp;and&nbsp;zgeqp3.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0</tt></dd></dl>
 <dl><dt><a name="-qr_update"><strong>qr_update</strong></a>(...)</dt><dd><tt><a href="#-qr_update">qr_update</a>(Q,&nbsp;R,&nbsp;u,&nbsp;v,&nbsp;overwrite_qruv=False,&nbsp;check_finite=True)<br>
&nbsp;<br>
Rank-k&nbsp;QR&nbsp;update<br>
&nbsp;<br>
If&nbsp;``A&nbsp;=&nbsp;Q&nbsp;R``&nbsp;is&nbsp;the&nbsp;QR&nbsp;factorization&nbsp;of&nbsp;``A``,&nbsp;return&nbsp;the&nbsp;QR<br>
factorization&nbsp;of&nbsp;``A&nbsp;+&nbsp;u&nbsp;v**T``&nbsp;for&nbsp;real&nbsp;``A``&nbsp;or&nbsp;``A&nbsp;+&nbsp;u&nbsp;v**H``<br>
for&nbsp;complex&nbsp;``A``.<br>
&nbsp;<br>
Parameters<br>
----------<br>
Q&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;or&nbsp;(M,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Unitary/orthogonal&nbsp;matrix&nbsp;from&nbsp;the&nbsp;qr&nbsp;decomposition&nbsp;of&nbsp;A.<br>
R&nbsp;:&nbsp;(M,&nbsp;N)&nbsp;or&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Upper&nbsp;triangular&nbsp;matrix&nbsp;from&nbsp;the&nbsp;qr&nbsp;decomposition&nbsp;of&nbsp;A.<br>
u&nbsp;:&nbsp;(M,)&nbsp;or&nbsp;(M,&nbsp;k)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Left&nbsp;update&nbsp;vector<br>
v&nbsp;:&nbsp;(N,)&nbsp;or&nbsp;(N,&nbsp;k)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Right&nbsp;update&nbsp;vector<br>
overwrite_qruv&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;consume&nbsp;Q,&nbsp;R,&nbsp;u,&nbsp;and&nbsp;v,&nbsp;if&nbsp;possible,&nbsp;while&nbsp;performing&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;update,&nbsp;otherwise&nbsp;make&nbsp;copies&nbsp;as&nbsp;necessary.&nbsp;Defaults&nbsp;to&nbsp;False.<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Default&nbsp;is&nbsp;True.<br>
&nbsp;<br>
Returns<br>
-------<br>
Q1&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Updated&nbsp;unitary/orthogonal&nbsp;factor<br>
R1&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Updated&nbsp;upper&nbsp;triangular&nbsp;factor<br>
&nbsp;<br>
See&nbsp;Also<br>
--------<br>
qr,&nbsp;qr_multiply,&nbsp;qr_delete,&nbsp;qr_insert<br>
&nbsp;<br>
Notes<br>
-----<br>
This&nbsp;routine&nbsp;does&nbsp;not&nbsp;guarantee&nbsp;that&nbsp;the&nbsp;diagonal&nbsp;entries&nbsp;of&nbsp;`R1`&nbsp;are<br>
real&nbsp;or&nbsp;positive.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.16.0<br>
&nbsp;<br>
References<br>
----------<br>
..&nbsp;[1]&nbsp;Golub,&nbsp;G.&nbsp;H.&nbsp;&amp;&nbsp;Van&nbsp;Loan,&nbsp;C.&nbsp;F.&nbsp;Matrix&nbsp;Computations,&nbsp;3rd&nbsp;Ed.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Johns&nbsp;Hopkins&nbsp;University&nbsp;Press,&nbsp;1996).<br>
&nbsp;<br>
..&nbsp;[2]&nbsp;Daniel,&nbsp;J.&nbsp;W.,&nbsp;Gragg,&nbsp;W.&nbsp;B.,&nbsp;Kaufman,&nbsp;L.&nbsp;&amp;&nbsp;Stewart,&nbsp;G.&nbsp;W.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reorthogonalization&nbsp;and&nbsp;stable&nbsp;algorithms&nbsp;for&nbsp;updating&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gram-Schmidt&nbsp;QR&nbsp;factorization.&nbsp;Math.&nbsp;Comput.&nbsp;30,&nbsp;772-795&nbsp;(1976).<br>
&nbsp;<br>
..&nbsp;[3]&nbsp;Reichel,&nbsp;L.&nbsp;&amp;&nbsp;Gragg,&nbsp;W.&nbsp;B.&nbsp;Algorithm&nbsp;686:&nbsp;FORTRAN&nbsp;Subroutines&nbsp;for<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Updating&nbsp;the&nbsp;QR&nbsp;Decomposition.&nbsp;ACM&nbsp;Trans.&nbsp;Math.&nbsp;Softw.&nbsp;16,&nbsp;369-377<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1990).<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy&nbsp;import&nbsp;linalg<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([[&nbsp;&nbsp;3.,&nbsp;&nbsp;-2.,&nbsp;&nbsp;-2.],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;6.,&nbsp;&nbsp;-9.,&nbsp;&nbsp;-3.],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-3.,&nbsp;&nbsp;10.,&nbsp;&nbsp;&nbsp;1.],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;6.,&nbsp;&nbsp;-7.,&nbsp;&nbsp;&nbsp;4.],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;7.,&nbsp;&nbsp;&nbsp;8.,&nbsp;&nbsp;-6.]])<br>
&gt;&gt;&gt;&nbsp;q,&nbsp;r&nbsp;=&nbsp;linalg.<a href="#-qr">qr</a>(a)<br>
&nbsp;<br>
Given&nbsp;this&nbsp;q,&nbsp;r&nbsp;decomposition,&nbsp;perform&nbsp;a&nbsp;rank&nbsp;1&nbsp;update.<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;u&nbsp;=&nbsp;np.array([7.,&nbsp;-2.,&nbsp;4.,&nbsp;3.,&nbsp;5.])<br>
&gt;&gt;&gt;&nbsp;v&nbsp;=&nbsp;np.array([1.,&nbsp;3.,&nbsp;-5.])<br>
&gt;&gt;&gt;&nbsp;q_up,&nbsp;r_up&nbsp;=&nbsp;linalg.<a href="#-qr_update">qr_update</a>(q,&nbsp;r,&nbsp;u,&nbsp;v,&nbsp;False)<br>
&gt;&gt;&gt;&nbsp;q_up<br>
array([[&nbsp;0.54073807,&nbsp;&nbsp;0.18645997,&nbsp;&nbsp;0.81707661,&nbsp;-0.02136616,&nbsp;&nbsp;0.06902409],&nbsp;&nbsp;#&nbsp;may&nbsp;vary&nbsp;(signs)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.21629523,&nbsp;-0.63257324,&nbsp;&nbsp;0.06567893,&nbsp;&nbsp;0.34125904,&nbsp;-0.65749222],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.05407381,&nbsp;&nbsp;0.64757787,&nbsp;-0.12781284,&nbsp;-0.20031219,&nbsp;-0.72198188],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.48666426,&nbsp;-0.30466718,&nbsp;-0.27487277,&nbsp;-0.77079214,&nbsp;&nbsp;0.0256951&nbsp;],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.64888568,&nbsp;&nbsp;0.23001&nbsp;&nbsp;&nbsp;,&nbsp;-0.4859845&nbsp;,&nbsp;&nbsp;0.49883891,&nbsp;&nbsp;0.20253783]])<br>
&gt;&gt;&gt;&nbsp;r_up<br>
array([[&nbsp;18.49324201,&nbsp;&nbsp;24.11691794,&nbsp;-44.98940746],&nbsp;&nbsp;#&nbsp;may&nbsp;vary&nbsp;(signs)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;31.95894662,&nbsp;-27.40998201],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;-9.25451794],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]])<br>
&nbsp;<br>
The&nbsp;update&nbsp;is&nbsp;equivalent,&nbsp;but&nbsp;faster&nbsp;than&nbsp;the&nbsp;following.<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;a_up&nbsp;=&nbsp;a&nbsp;+&nbsp;np.outer(u,&nbsp;v)<br>
&gt;&gt;&gt;&nbsp;q_direct,&nbsp;r_direct&nbsp;=&nbsp;linalg.<a href="#-qr">qr</a>(a_up)<br>
&nbsp;<br>
Check&nbsp;that&nbsp;we&nbsp;have&nbsp;equivalent&nbsp;results:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;np.allclose(np.dot(q_up,&nbsp;r_up),&nbsp;a_up)<br>
True<br>
&nbsp;<br>
And&nbsp;the&nbsp;updated&nbsp;Q&nbsp;is&nbsp;still&nbsp;unitary:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;np.allclose(np.dot(q_up.T,&nbsp;q_up),&nbsp;np.eye(5))<br>
True<br>
&nbsp;<br>
Updating&nbsp;economic&nbsp;(reduced,&nbsp;thin)&nbsp;decompositions&nbsp;is&nbsp;also&nbsp;possible:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;qe,&nbsp;re&nbsp;=&nbsp;linalg.<a href="#-qr">qr</a>(a,&nbsp;mode='economic')<br>
&gt;&gt;&gt;&nbsp;qe_up,&nbsp;re_up&nbsp;=&nbsp;linalg.<a href="#-qr_update">qr_update</a>(qe,&nbsp;re,&nbsp;u,&nbsp;v,&nbsp;False)<br>
&gt;&gt;&gt;&nbsp;qe_up<br>
array([[&nbsp;0.54073807,&nbsp;&nbsp;0.18645997,&nbsp;&nbsp;0.81707661],&nbsp;&nbsp;#&nbsp;may&nbsp;vary&nbsp;(signs)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.21629523,&nbsp;-0.63257324,&nbsp;&nbsp;0.06567893],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.05407381,&nbsp;&nbsp;0.64757787,&nbsp;-0.12781284],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.48666426,&nbsp;-0.30466718,&nbsp;-0.27487277],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.64888568,&nbsp;&nbsp;0.23001&nbsp;&nbsp;&nbsp;,&nbsp;-0.4859845&nbsp;]])<br>
&gt;&gt;&gt;&nbsp;re_up<br>
array([[&nbsp;18.49324201,&nbsp;&nbsp;24.11691794,&nbsp;-44.98940746],&nbsp;&nbsp;#&nbsp;may&nbsp;vary&nbsp;(signs)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;31.95894662,&nbsp;-27.40998201],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;-9.25451794]])<br>
&gt;&gt;&gt;&nbsp;np.allclose(np.dot(qe_up,&nbsp;re_up),&nbsp;a_up)<br>
True<br>
&gt;&gt;&gt;&nbsp;np.allclose(np.dot(qe_up.T,&nbsp;qe_up),&nbsp;np.eye(3))<br>
True<br>
&nbsp;<br>
Similarly&nbsp;to&nbsp;the&nbsp;above,&nbsp;perform&nbsp;a&nbsp;rank&nbsp;2&nbsp;update.<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;u2&nbsp;=&nbsp;np.array([[&nbsp;7.,&nbsp;-1,],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-2.,&nbsp;&nbsp;4.],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;4.,&nbsp;&nbsp;2.],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;3.,&nbsp;-6.],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;5.,&nbsp;&nbsp;3.]])<br>
&gt;&gt;&gt;&nbsp;v2&nbsp;=&nbsp;np.array([[&nbsp;1.,&nbsp;2.],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;3.,&nbsp;4.],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-5.,&nbsp;2]])<br>
&gt;&gt;&gt;&nbsp;q_up2,&nbsp;r_up2&nbsp;=&nbsp;linalg.<a href="#-qr_update">qr_update</a>(q,&nbsp;r,&nbsp;u2,&nbsp;v2,&nbsp;False)<br>
&gt;&gt;&gt;&nbsp;q_up2<br>
array([[-0.33626508,&nbsp;-0.03477253,&nbsp;&nbsp;0.61956287,&nbsp;-0.64352987,&nbsp;-0.29618884],&nbsp;&nbsp;#&nbsp;may&nbsp;vary&nbsp;(signs)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.50439762,&nbsp;&nbsp;0.58319694,&nbsp;-0.43010077,&nbsp;-0.33395279,&nbsp;&nbsp;0.33008064],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.21016568,&nbsp;-0.63123106,&nbsp;&nbsp;0.0582249&nbsp;,&nbsp;-0.13675572,&nbsp;&nbsp;0.73163206],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.12609941,&nbsp;&nbsp;0.49694436,&nbsp;&nbsp;0.64590024,&nbsp;&nbsp;0.31191919,&nbsp;&nbsp;0.47187344],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.75659643,&nbsp;-0.11517748,&nbsp;&nbsp;0.10284903,&nbsp;&nbsp;0.5986227&nbsp;,&nbsp;-0.21299983]])<br>
&gt;&gt;&gt;&nbsp;r_up2<br>
array([[-23.79075451,&nbsp;-41.1084062&nbsp;,&nbsp;&nbsp;24.71548348],&nbsp;&nbsp;#&nbsp;may&nbsp;vary&nbsp;(signs)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;-33.83931057,&nbsp;&nbsp;11.02226551],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;48.91476811],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]])<br>
&nbsp;<br>
This&nbsp;update&nbsp;is&nbsp;also&nbsp;a&nbsp;valid&nbsp;qr&nbsp;decomposition&nbsp;of&nbsp;``A&nbsp;+&nbsp;U&nbsp;V**T``.<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;a_up2&nbsp;=&nbsp;a&nbsp;+&nbsp;np.dot(u2,&nbsp;v2.T)<br>
&gt;&gt;&gt;&nbsp;np.allclose(a_up2,&nbsp;np.dot(q_up2,&nbsp;r_up2))<br>
True<br>
&gt;&gt;&gt;&nbsp;np.allclose(np.dot(q_up2.T,&nbsp;q_up2),&nbsp;np.eye(5))<br>
True</tt></dd></dl>
 <dl><dt><a name="-qz"><strong>qz</strong></a>(A, B, output<font color="#909090">='real'</font>, lwork<font color="#909090">=None</font>, sort<font color="#909090">=None</font>, overwrite_a<font color="#909090">=False</font>, overwrite_b<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>QZ&nbsp;decomposition&nbsp;for&nbsp;generalized&nbsp;eigenvalues&nbsp;of&nbsp;a&nbsp;pair&nbsp;of&nbsp;matrices.<br>
&nbsp;<br>
The&nbsp;QZ,&nbsp;or&nbsp;generalized&nbsp;Schur,&nbsp;decomposition&nbsp;for&nbsp;a&nbsp;pair&nbsp;of&nbsp;N&nbsp;x&nbsp;N<br>
nonsymmetric&nbsp;matrices&nbsp;(A,B)&nbsp;is::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;(A,B)&nbsp;=&nbsp;(Q*AA*Z',&nbsp;Q*BB*Z')<br>
&nbsp;<br>
where&nbsp;AA,&nbsp;BB&nbsp;is&nbsp;in&nbsp;generalized&nbsp;Schur&nbsp;form&nbsp;if&nbsp;BB&nbsp;is&nbsp;upper-triangular<br>
with&nbsp;non-negative&nbsp;diagonal&nbsp;and&nbsp;AA&nbsp;is&nbsp;upper-triangular,&nbsp;or&nbsp;for&nbsp;real&nbsp;QZ<br>
decomposition&nbsp;(``output='real'``)&nbsp;block&nbsp;upper&nbsp;triangular&nbsp;with&nbsp;1x1<br>
and&nbsp;2x2&nbsp;blocks.&nbsp;&nbsp;In&nbsp;this&nbsp;case,&nbsp;the&nbsp;1x1&nbsp;blocks&nbsp;correspond&nbsp;to&nbsp;real<br>
generalized&nbsp;eigenvalues&nbsp;and&nbsp;2x2&nbsp;blocks&nbsp;are&nbsp;'standardized'&nbsp;by&nbsp;making<br>
the&nbsp;corresponding&nbsp;elements&nbsp;of&nbsp;BB&nbsp;have&nbsp;the&nbsp;form::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;a&nbsp;0&nbsp;]<br>
&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0&nbsp;b&nbsp;]<br>
&nbsp;<br>
and&nbsp;the&nbsp;pair&nbsp;of&nbsp;corresponding&nbsp;2x2&nbsp;blocks&nbsp;in&nbsp;AA&nbsp;and&nbsp;BB&nbsp;will&nbsp;have&nbsp;a&nbsp;complex<br>
conjugate&nbsp;pair&nbsp;of&nbsp;generalized&nbsp;eigenvalues.&nbsp;&nbsp;If&nbsp;(``output='complex'``)&nbsp;or<br>
A&nbsp;and&nbsp;B&nbsp;are&nbsp;complex&nbsp;matrices,&nbsp;Z'&nbsp;denotes&nbsp;the&nbsp;conjugate-transpose&nbsp;of&nbsp;Z.<br>
Q&nbsp;and&nbsp;Z&nbsp;are&nbsp;unitary&nbsp;matrices.<br>
&nbsp;<br>
Parameters<br>
----------<br>
A&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;2d&nbsp;array&nbsp;to&nbsp;decompose<br>
B&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;2d&nbsp;array&nbsp;to&nbsp;decompose<br>
output&nbsp;:&nbsp;{'real',&nbsp;'complex'},&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Construct&nbsp;the&nbsp;real&nbsp;or&nbsp;complex&nbsp;QZ&nbsp;decomposition&nbsp;for&nbsp;real&nbsp;matrices.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Default&nbsp;is&nbsp;'real'.<br>
lwork&nbsp;:&nbsp;int,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Work&nbsp;array&nbsp;size.&nbsp;&nbsp;If&nbsp;None&nbsp;or&nbsp;-1,&nbsp;it&nbsp;is&nbsp;automatically&nbsp;computed.<br>
sort&nbsp;:&nbsp;{None,&nbsp;callable,&nbsp;'lhp',&nbsp;'rhp',&nbsp;'iuc',&nbsp;'ouc'},&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;NOTE:&nbsp;THIS&nbsp;INPUT&nbsp;IS&nbsp;DISABLED&nbsp;FOR&nbsp;NOW.&nbsp;Use&nbsp;ordqz&nbsp;instead.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Specifies&nbsp;whether&nbsp;the&nbsp;upper&nbsp;eigenvalues&nbsp;should&nbsp;be&nbsp;sorted.&nbsp;&nbsp;A&nbsp;callable<br>
&nbsp;&nbsp;&nbsp;&nbsp;may&nbsp;be&nbsp;passed&nbsp;that,&nbsp;given&nbsp;a&nbsp;eigenvalue,&nbsp;returns&nbsp;a&nbsp;boolean&nbsp;denoting<br>
&nbsp;&nbsp;&nbsp;&nbsp;whether&nbsp;the&nbsp;eigenvalue&nbsp;should&nbsp;be&nbsp;sorted&nbsp;to&nbsp;the&nbsp;top-left&nbsp;(True).&nbsp;For<br>
&nbsp;&nbsp;&nbsp;&nbsp;real&nbsp;matrix&nbsp;pairs,&nbsp;the&nbsp;sort&nbsp;function&nbsp;takes&nbsp;three&nbsp;real&nbsp;arguments<br>
&nbsp;&nbsp;&nbsp;&nbsp;(alphar,&nbsp;alphai,&nbsp;beta).&nbsp;The&nbsp;eigenvalue<br>
&nbsp;&nbsp;&nbsp;&nbsp;``x&nbsp;=&nbsp;(alphar&nbsp;+&nbsp;alphai*1j)/beta``.&nbsp;&nbsp;For&nbsp;complex&nbsp;matrix&nbsp;pairs&nbsp;or<br>
&nbsp;&nbsp;&nbsp;&nbsp;output='complex',&nbsp;the&nbsp;sort&nbsp;function&nbsp;takes&nbsp;two&nbsp;complex&nbsp;arguments<br>
&nbsp;&nbsp;&nbsp;&nbsp;(alpha,&nbsp;beta).&nbsp;The&nbsp;eigenvalue&nbsp;``x&nbsp;=&nbsp;(alpha/beta)``.&nbsp;&nbsp;Alternatively,<br>
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;parameters&nbsp;may&nbsp;be&nbsp;used:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;'lhp'&nbsp;&nbsp;&nbsp;Left-hand&nbsp;plane&nbsp;(x.real&nbsp;&lt;&nbsp;0.0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;'rhp'&nbsp;&nbsp;&nbsp;Right-hand&nbsp;plane&nbsp;(x.real&nbsp;&gt;&nbsp;0.0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;'iuc'&nbsp;&nbsp;&nbsp;Inside&nbsp;the&nbsp;unit&nbsp;circle&nbsp;(x*x.conjugate()&nbsp;&lt;&nbsp;1.0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;'ouc'&nbsp;&nbsp;&nbsp;Outside&nbsp;the&nbsp;unit&nbsp;circle&nbsp;(x*x.conjugate()&nbsp;&gt;&nbsp;1.0)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Defaults&nbsp;to&nbsp;None&nbsp;(no&nbsp;sorting).<br>
overwrite_a&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;overwrite&nbsp;data&nbsp;in&nbsp;a&nbsp;(may&nbsp;improve&nbsp;performance)<br>
overwrite_b&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;overwrite&nbsp;data&nbsp;in&nbsp;b&nbsp;(may&nbsp;improve&nbsp;performance)<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;true&nbsp;checks&nbsp;the&nbsp;elements&nbsp;of&nbsp;`A`&nbsp;and&nbsp;`B`&nbsp;are&nbsp;finite&nbsp;numbers.&nbsp;If<br>
&nbsp;&nbsp;&nbsp;&nbsp;false&nbsp;does&nbsp;no&nbsp;checking&nbsp;and&nbsp;passes&nbsp;matrix&nbsp;through&nbsp;to<br>
&nbsp;&nbsp;&nbsp;&nbsp;underlying&nbsp;algorithm.<br>
&nbsp;<br>
Returns<br>
-------<br>
AA&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Generalized&nbsp;Schur&nbsp;form&nbsp;of&nbsp;A.<br>
BB&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Generalized&nbsp;Schur&nbsp;form&nbsp;of&nbsp;B.<br>
Q&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;left&nbsp;Schur&nbsp;vectors.<br>
Z&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;right&nbsp;Schur&nbsp;vectors.<br>
&nbsp;<br>
Notes<br>
-----<br>
Q&nbsp;is&nbsp;transposed&nbsp;versus&nbsp;the&nbsp;equivalent&nbsp;function&nbsp;in&nbsp;Matlab.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy&nbsp;import&nbsp;linalg<br>
&gt;&gt;&gt;&nbsp;np.random.seed(1234)<br>
&gt;&gt;&gt;&nbsp;A&nbsp;=&nbsp;np.arange(9).reshape((3,&nbsp;3))<br>
&gt;&gt;&gt;&nbsp;B&nbsp;=&nbsp;np.random.randn(3,&nbsp;3)<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;AA,&nbsp;BB,&nbsp;Q,&nbsp;Z&nbsp;=&nbsp;linalg.<a href="#-qz">qz</a>(A,&nbsp;B)<br>
&gt;&gt;&gt;&nbsp;AA<br>
array([[-13.40928183,&nbsp;&nbsp;-4.62471562,&nbsp;&nbsp;&nbsp;1.09215523],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;1.22805978],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;0.31973817]])<br>
&gt;&gt;&gt;&nbsp;BB<br>
array([[&nbsp;0.33362547,&nbsp;-1.37393632,&nbsp;&nbsp;0.02179805],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;1.68144922,&nbsp;&nbsp;0.74683866],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;0.9258294&nbsp;]])<br>
&gt;&gt;&gt;&nbsp;Q<br>
array([[&nbsp;0.14134727,&nbsp;-0.97562773,&nbsp;&nbsp;0.16784365],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.49835904,&nbsp;-0.07636948,&nbsp;-0.86360059],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.85537081,&nbsp;&nbsp;0.20571399,&nbsp;&nbsp;0.47541828]])<br>
&gt;&gt;&gt;&nbsp;Z<br>
array([[-0.24900855,&nbsp;-0.51772687,&nbsp;&nbsp;0.81850696],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.79813178,&nbsp;&nbsp;0.58842606,&nbsp;&nbsp;0.12938478],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-0.54861681,&nbsp;-0.6210585&nbsp;,&nbsp;-0.55973739]])<br>
&nbsp;<br>
See&nbsp;also<br>
--------<br>
ordqz</tt></dd></dl>
 <dl><dt><a name="-rq"><strong>rq</strong></a>(a, overwrite_a<font color="#909090">=False</font>, lwork<font color="#909090">=None</font>, mode<font color="#909090">='full'</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Compute&nbsp;RQ&nbsp;decomposition&nbsp;of&nbsp;a&nbsp;matrix.<br>
&nbsp;<br>
Calculate&nbsp;the&nbsp;decomposition&nbsp;``A&nbsp;=&nbsp;R&nbsp;Q``&nbsp;where&nbsp;Q&nbsp;is&nbsp;unitary/orthogonal<br>
and&nbsp;R&nbsp;upper&nbsp;triangular.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;to&nbsp;be&nbsp;decomposed<br>
overwrite_a&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;data&nbsp;in&nbsp;a&nbsp;is&nbsp;overwritten&nbsp;(may&nbsp;improve&nbsp;performance)<br>
lwork&nbsp;:&nbsp;int,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Work&nbsp;array&nbsp;size,&nbsp;lwork&nbsp;&gt;=&nbsp;a.shape[1].&nbsp;If&nbsp;None&nbsp;or&nbsp;-1,&nbsp;an&nbsp;optimal&nbsp;size<br>
&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;computed.<br>
mode&nbsp;:&nbsp;{'full',&nbsp;'r',&nbsp;'economic'},&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Determines&nbsp;what&nbsp;information&nbsp;is&nbsp;to&nbsp;be&nbsp;returned:&nbsp;either&nbsp;both&nbsp;Q&nbsp;and&nbsp;R<br>
&nbsp;&nbsp;&nbsp;&nbsp;('full',&nbsp;default),&nbsp;only&nbsp;R&nbsp;('r')&nbsp;or&nbsp;both&nbsp;Q&nbsp;and&nbsp;R&nbsp;but&nbsp;computed&nbsp;in<br>
&nbsp;&nbsp;&nbsp;&nbsp;economy-size&nbsp;('economic',&nbsp;see&nbsp;Notes).<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
R&nbsp;:&nbsp;float&nbsp;or&nbsp;complex&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Of&nbsp;shape&nbsp;(M,&nbsp;N)&nbsp;or&nbsp;(M,&nbsp;K)&nbsp;for&nbsp;``mode='economic'``.&nbsp;&nbsp;``K&nbsp;=&nbsp;min(M,&nbsp;N)``.<br>
Q&nbsp;:&nbsp;float&nbsp;or&nbsp;complex&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Of&nbsp;shape&nbsp;(N,&nbsp;N)&nbsp;or&nbsp;(K,&nbsp;N)&nbsp;for&nbsp;``mode='economic'``.&nbsp;&nbsp;Not&nbsp;returned<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;``mode='r'``.<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;decomposition&nbsp;fails.<br>
&nbsp;<br>
Notes<br>
-----<br>
This&nbsp;is&nbsp;an&nbsp;interface&nbsp;to&nbsp;the&nbsp;LAPACK&nbsp;routines&nbsp;sgerqf,&nbsp;dgerqf,&nbsp;cgerqf,&nbsp;zgerqf,<br>
sorgrq,&nbsp;dorgrq,&nbsp;cungrq&nbsp;and&nbsp;zungrq.<br>
&nbsp;<br>
If&nbsp;``mode=economic``,&nbsp;the&nbsp;shapes&nbsp;of&nbsp;Q&nbsp;and&nbsp;R&nbsp;are&nbsp;(K,&nbsp;N)&nbsp;and&nbsp;(M,&nbsp;K)&nbsp;instead<br>
of&nbsp;(N,N)&nbsp;and&nbsp;(M,N),&nbsp;with&nbsp;``K=min(M,N)``.<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy&nbsp;import&nbsp;linalg<br>
&gt;&gt;&gt;&nbsp;from&nbsp;numpy&nbsp;import&nbsp;random,&nbsp;dot,&nbsp;allclose<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;random.randn(6,&nbsp;9)<br>
&gt;&gt;&gt;&nbsp;r,&nbsp;q&nbsp;=&nbsp;linalg.<a href="#-rq">rq</a>(a)<br>
&gt;&gt;&gt;&nbsp;allclose(a,&nbsp;dot(r,&nbsp;q))<br>
True<br>
&gt;&gt;&gt;&nbsp;r.shape,&nbsp;q.shape<br>
((6,&nbsp;9),&nbsp;(9,&nbsp;9))<br>
&gt;&gt;&gt;&nbsp;r2&nbsp;=&nbsp;linalg.<a href="#-rq">rq</a>(a,&nbsp;mode='r')<br>
&gt;&gt;&gt;&nbsp;allclose(r,&nbsp;r2)<br>
True<br>
&gt;&gt;&gt;&nbsp;r3,&nbsp;q3&nbsp;=&nbsp;linalg.<a href="#-rq">rq</a>(a,&nbsp;mode='economic')<br>
&gt;&gt;&gt;&nbsp;r3.shape,&nbsp;q3.shape<br>
((6,&nbsp;6),&nbsp;(6,&nbsp;9))</tt></dd></dl>
 <dl><dt><a name="-rsf2csf"><strong>rsf2csf</strong></a>(T, Z, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Convert&nbsp;real&nbsp;Schur&nbsp;form&nbsp;to&nbsp;complex&nbsp;Schur&nbsp;form.<br>
&nbsp;<br>
Convert&nbsp;a&nbsp;quasi-diagonal&nbsp;real-valued&nbsp;Schur&nbsp;form&nbsp;to&nbsp;the&nbsp;upper&nbsp;triangular<br>
complex-valued&nbsp;Schur&nbsp;form.<br>
&nbsp;<br>
Parameters<br>
----------<br>
T&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Real&nbsp;Schur&nbsp;form&nbsp;of&nbsp;the&nbsp;original&nbsp;matrix<br>
Z&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Schur&nbsp;transformation&nbsp;matrix<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrices&nbsp;contain&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
T&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Complex&nbsp;Schur&nbsp;form&nbsp;of&nbsp;the&nbsp;original&nbsp;matrix<br>
Z&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Schur&nbsp;transformation&nbsp;matrix&nbsp;corresponding&nbsp;to&nbsp;the&nbsp;complex&nbsp;form<br>
&nbsp;<br>
See&nbsp;also<br>
--------<br>
schur&nbsp;:&nbsp;Schur&nbsp;decompose&nbsp;a&nbsp;matrix</tt></dd></dl>
 <dl><dt><a name="-schur"><strong>schur</strong></a>(a, output<font color="#909090">='real'</font>, lwork<font color="#909090">=None</font>, overwrite_a<font color="#909090">=False</font>, sort<font color="#909090">=None</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Compute&nbsp;Schur&nbsp;decomposition&nbsp;of&nbsp;a&nbsp;matrix.<br>
&nbsp;<br>
The&nbsp;Schur&nbsp;decomposition&nbsp;is::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;Z&nbsp;T&nbsp;Z^H<br>
&nbsp;<br>
where&nbsp;Z&nbsp;is&nbsp;unitary&nbsp;and&nbsp;T&nbsp;is&nbsp;either&nbsp;upper-triangular,&nbsp;or&nbsp;for&nbsp;real<br>
Schur&nbsp;decomposition&nbsp;(output='real'),&nbsp;quasi-upper&nbsp;triangular.&nbsp;&nbsp;In<br>
the&nbsp;quasi-triangular&nbsp;form,&nbsp;2x2&nbsp;blocks&nbsp;describing&nbsp;complex-valued<br>
eigenvalue&nbsp;pairs&nbsp;may&nbsp;extrude&nbsp;from&nbsp;the&nbsp;diagonal.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;to&nbsp;decompose<br>
output&nbsp;:&nbsp;{'real',&nbsp;'complex'},&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Construct&nbsp;the&nbsp;real&nbsp;or&nbsp;complex&nbsp;Schur&nbsp;decomposition&nbsp;(for&nbsp;real&nbsp;matrices).<br>
lwork&nbsp;:&nbsp;int,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Work&nbsp;array&nbsp;size.&nbsp;If&nbsp;None&nbsp;or&nbsp;-1,&nbsp;it&nbsp;is&nbsp;automatically&nbsp;computed.<br>
overwrite_a&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;overwrite&nbsp;data&nbsp;in&nbsp;a&nbsp;(may&nbsp;improve&nbsp;performance).<br>
sort&nbsp;:&nbsp;{None,&nbsp;callable,&nbsp;'lhp',&nbsp;'rhp',&nbsp;'iuc',&nbsp;'ouc'},&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Specifies&nbsp;whether&nbsp;the&nbsp;upper&nbsp;eigenvalues&nbsp;should&nbsp;be&nbsp;sorted.&nbsp;&nbsp;A&nbsp;callable<br>
&nbsp;&nbsp;&nbsp;&nbsp;may&nbsp;be&nbsp;passed&nbsp;that,&nbsp;given&nbsp;a&nbsp;eigenvalue,&nbsp;returns&nbsp;a&nbsp;boolean&nbsp;denoting<br>
&nbsp;&nbsp;&nbsp;&nbsp;whether&nbsp;the&nbsp;eigenvalue&nbsp;should&nbsp;be&nbsp;sorted&nbsp;to&nbsp;the&nbsp;top-left&nbsp;(True).<br>
&nbsp;&nbsp;&nbsp;&nbsp;Alternatively,&nbsp;string&nbsp;parameters&nbsp;may&nbsp;be&nbsp;used::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'lhp'&nbsp;&nbsp;&nbsp;Left-hand&nbsp;plane&nbsp;(x.real&nbsp;&lt;&nbsp;0.0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'rhp'&nbsp;&nbsp;&nbsp;Right-hand&nbsp;plane&nbsp;(x.real&nbsp;&gt;&nbsp;0.0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'iuc'&nbsp;&nbsp;&nbsp;Inside&nbsp;the&nbsp;unit&nbsp;circle&nbsp;(x*x.conjugate()&nbsp;&lt;=&nbsp;1.0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'ouc'&nbsp;&nbsp;&nbsp;Outside&nbsp;the&nbsp;unit&nbsp;circle&nbsp;(x*x.conjugate()&nbsp;&gt;&nbsp;1.0)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Defaults&nbsp;to&nbsp;None&nbsp;(no&nbsp;sorting).<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
T&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Schur&nbsp;form&nbsp;of&nbsp;A.&nbsp;It&nbsp;is&nbsp;real-valued&nbsp;for&nbsp;the&nbsp;real&nbsp;Schur&nbsp;decomposition.<br>
Z&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;An&nbsp;unitary&nbsp;Schur&nbsp;transformation&nbsp;matrix&nbsp;for&nbsp;A.<br>
&nbsp;&nbsp;&nbsp;&nbsp;It&nbsp;is&nbsp;real-valued&nbsp;for&nbsp;the&nbsp;real&nbsp;Schur&nbsp;decomposition.<br>
sdim&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;and&nbsp;only&nbsp;if&nbsp;sorting&nbsp;was&nbsp;requested,&nbsp;a&nbsp;third&nbsp;return&nbsp;value&nbsp;will<br>
&nbsp;&nbsp;&nbsp;&nbsp;contain&nbsp;the&nbsp;number&nbsp;of&nbsp;eigenvalues&nbsp;satisfying&nbsp;the&nbsp;sort&nbsp;condition.<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;Error&nbsp;raised&nbsp;under&nbsp;three&nbsp;conditions:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;The&nbsp;algorithm&nbsp;failed&nbsp;due&nbsp;to&nbsp;a&nbsp;failure&nbsp;of&nbsp;the&nbsp;QR&nbsp;algorithm&nbsp;to<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compute&nbsp;all&nbsp;eigenvalues<br>
&nbsp;&nbsp;&nbsp;&nbsp;2.&nbsp;If&nbsp;eigenvalue&nbsp;sorting&nbsp;was&nbsp;requested,&nbsp;the&nbsp;eigenvalues&nbsp;could&nbsp;not&nbsp;be<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reordered&nbsp;due&nbsp;to&nbsp;a&nbsp;failure&nbsp;to&nbsp;separate&nbsp;eigenvalues,&nbsp;usually&nbsp;because<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;poor&nbsp;conditioning<br>
&nbsp;&nbsp;&nbsp;&nbsp;3.&nbsp;If&nbsp;eigenvalue&nbsp;sorting&nbsp;was&nbsp;requested,&nbsp;roundoff&nbsp;errors&nbsp;caused&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leading&nbsp;eigenvalues&nbsp;to&nbsp;no&nbsp;longer&nbsp;satisfy&nbsp;the&nbsp;sorting&nbsp;condition<br>
&nbsp;<br>
See&nbsp;also<br>
--------<br>
rsf2csf&nbsp;:&nbsp;Convert&nbsp;real&nbsp;Schur&nbsp;form&nbsp;to&nbsp;complex&nbsp;Schur&nbsp;form</tt></dd></dl>
 <dl><dt><a name="-signm"><strong>signm</strong></a>(A, disp<font color="#909090">=True</font>)</dt><dd><tt>Matrix&nbsp;sign&nbsp;function.<br>
&nbsp;<br>
Extension&nbsp;of&nbsp;the&nbsp;scalar&nbsp;sign(x)&nbsp;to&nbsp;matrices.<br>
&nbsp;<br>
Parameters<br>
----------<br>
A&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;at&nbsp;which&nbsp;to&nbsp;evaluate&nbsp;the&nbsp;sign&nbsp;function<br>
disp&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Print&nbsp;warning&nbsp;if&nbsp;error&nbsp;in&nbsp;the&nbsp;result&nbsp;is&nbsp;estimated&nbsp;large<br>
&nbsp;&nbsp;&nbsp;&nbsp;instead&nbsp;of&nbsp;returning&nbsp;estimated&nbsp;error.&nbsp;(Default:&nbsp;True)<br>
&nbsp;<br>
Returns<br>
-------<br>
signm&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Value&nbsp;of&nbsp;the&nbsp;sign&nbsp;function&nbsp;at&nbsp;`A`<br>
errest&nbsp;:&nbsp;float<br>
&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;disp&nbsp;==&nbsp;False)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;1-norm&nbsp;of&nbsp;the&nbsp;estimated&nbsp;error,&nbsp;||err||_1&nbsp;/&nbsp;||A||_1<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;signm,&nbsp;eigvals<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;[[1,2,3],&nbsp;[1,2,1],&nbsp;[1,1,1]]<br>
&gt;&gt;&gt;&nbsp;<a href="#-eigvals">eigvals</a>(a)<br>
array([&nbsp;4.12488542+0.j,&nbsp;-0.76155718+0.j,&nbsp;&nbsp;0.63667176+0.j])<br>
&gt;&gt;&gt;&nbsp;<a href="#-eigvals">eigvals</a>(<a href="#-signm">signm</a>(a))<br>
array([-1.+0.j,&nbsp;&nbsp;1.+0.j,&nbsp;&nbsp;1.+0.j])</tt></dd></dl>
 <dl><dt><a name="-sinhm"><strong>sinhm</strong></a>(A)</dt><dd><tt>Compute&nbsp;the&nbsp;hyperbolic&nbsp;matrix&nbsp;sine.<br>
&nbsp;<br>
This&nbsp;routine&nbsp;uses&nbsp;expm&nbsp;to&nbsp;compute&nbsp;the&nbsp;matrix&nbsp;exponentials.<br>
&nbsp;<br>
Parameters<br>
----------<br>
A&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Input&nbsp;array.<br>
&nbsp;<br>
Returns<br>
-------<br>
sinhm&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Hyperbolic&nbsp;matrix&nbsp;sine&nbsp;of&nbsp;`A`<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;tanhm,&nbsp;sinhm,&nbsp;coshm<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([[1.0,&nbsp;3.0],&nbsp;[1.0,&nbsp;4.0]])<br>
&gt;&gt;&gt;&nbsp;s&nbsp;=&nbsp;<a href="#-sinhm">sinhm</a>(a)<br>
&gt;&gt;&gt;&nbsp;s<br>
array([[&nbsp;10.57300653,&nbsp;&nbsp;39.28826594],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;13.09608865,&nbsp;&nbsp;49.86127247]])<br>
&nbsp;<br>
Verify&nbsp;<a href="#-tanhm">tanhm</a>(a)&nbsp;=&nbsp;<a href="#-sinhm">sinhm</a>(a).dot(<a href="#-inv">inv</a>(<a href="#-coshm">coshm</a>(a)))<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;t&nbsp;=&nbsp;<a href="#-tanhm">tanhm</a>(a)<br>
&gt;&gt;&gt;&nbsp;c&nbsp;=&nbsp;<a href="#-coshm">coshm</a>(a)<br>
&gt;&gt;&gt;&nbsp;t&nbsp;-&nbsp;s.dot(np.linalg.<a href="#-inv">inv</a>(c))<br>
array([[&nbsp;&nbsp;2.72004641e-15,&nbsp;&nbsp;&nbsp;4.55191440e-15],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.00000000e+00,&nbsp;&nbsp;-5.55111512e-16]])</tt></dd></dl>
 <dl><dt><a name="-sinm"><strong>sinm</strong></a>(A)</dt><dd><tt>Compute&nbsp;the&nbsp;matrix&nbsp;sine.<br>
&nbsp;<br>
This&nbsp;routine&nbsp;uses&nbsp;expm&nbsp;to&nbsp;compute&nbsp;the&nbsp;matrix&nbsp;exponentials.<br>
&nbsp;<br>
Parameters<br>
----------<br>
A&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Input&nbsp;array.<br>
&nbsp;<br>
Returns<br>
-------<br>
sinm&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;cosine&nbsp;of&nbsp;`A`<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;expm,&nbsp;sinm,&nbsp;cosm<br>
&nbsp;<br>
Euler's&nbsp;identity&nbsp;(exp(i*theta)&nbsp;=&nbsp;cos(theta)&nbsp;+&nbsp;i*sin(theta))<br>
applied&nbsp;to&nbsp;a&nbsp;matrix:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([[1.0,&nbsp;2.0],&nbsp;[-1.0,&nbsp;3.0]])<br>
&gt;&gt;&gt;&nbsp;<a href="#-expm">expm</a>(1j*a)<br>
array([[&nbsp;0.42645930+1.89217551j,&nbsp;-2.13721484-0.97811252j],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.06860742+0.48905626j,&nbsp;-1.71075555+0.91406299j]])<br>
&gt;&gt;&gt;&nbsp;<a href="#-cosm">cosm</a>(a)&nbsp;+&nbsp;1j*<a href="#-sinm">sinm</a>(a)<br>
array([[&nbsp;0.42645930+1.89217551j,&nbsp;-2.13721484-0.97811252j],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.06860742+0.48905626j,&nbsp;-1.71075555+0.91406299j]])</tt></dd></dl>
 <dl><dt><a name="-solve"><strong>solve</strong></a>(a, b, sym_pos<font color="#909090">=False</font>, lower<font color="#909090">=False</font>, overwrite_a<font color="#909090">=False</font>, overwrite_b<font color="#909090">=False</font>, debug<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Solve&nbsp;the&nbsp;equation&nbsp;``a&nbsp;x&nbsp;=&nbsp;b``&nbsp;for&nbsp;``x``.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;square&nbsp;matrix.<br>
b&nbsp;:&nbsp;(M,)&nbsp;or&nbsp;(M,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Right-hand&nbsp;side&nbsp;matrix&nbsp;in&nbsp;``a&nbsp;x&nbsp;=&nbsp;b``.<br>
sym_pos&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Assume&nbsp;`a`&nbsp;is&nbsp;symmetric&nbsp;and&nbsp;positive&nbsp;definite.<br>
lower&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Use&nbsp;only&nbsp;data&nbsp;contained&nbsp;in&nbsp;the&nbsp;lower&nbsp;triangle&nbsp;of&nbsp;`a`,&nbsp;if&nbsp;`sym_pos`&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;true.&nbsp;&nbsp;Default&nbsp;is&nbsp;to&nbsp;use&nbsp;upper&nbsp;triangle.<br>
overwrite_a&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Allow&nbsp;overwriting&nbsp;data&nbsp;in&nbsp;`a`&nbsp;(may&nbsp;enhance&nbsp;performance).<br>
&nbsp;&nbsp;&nbsp;&nbsp;Default&nbsp;is&nbsp;False.<br>
overwrite_b&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Allow&nbsp;overwriting&nbsp;data&nbsp;in&nbsp;`b`&nbsp;(may&nbsp;enhance&nbsp;performance).<br>
&nbsp;&nbsp;&nbsp;&nbsp;Default&nbsp;is&nbsp;False.<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrices&nbsp;contain&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
x&nbsp;:&nbsp;(M,)&nbsp;or&nbsp;(M,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Solution&nbsp;to&nbsp;the&nbsp;system&nbsp;``a&nbsp;x&nbsp;=&nbsp;b``.&nbsp;&nbsp;Shape&nbsp;of&nbsp;the&nbsp;return&nbsp;matches&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;shape&nbsp;of&nbsp;`b`.<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;`a`&nbsp;is&nbsp;singular.<br>
ValueError<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;`a`&nbsp;is&nbsp;not&nbsp;square<br>
&nbsp;<br>
Examples<br>
--------<br>
Given&nbsp;`a`&nbsp;and&nbsp;`b`,&nbsp;solve&nbsp;for&nbsp;`x`:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([[3,&nbsp;2,&nbsp;0],&nbsp;[1,&nbsp;-1,&nbsp;0],&nbsp;[0,&nbsp;5,&nbsp;1]])<br>
&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;np.array([2,&nbsp;4,&nbsp;-1])<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy&nbsp;import&nbsp;linalg<br>
&gt;&gt;&gt;&nbsp;x&nbsp;=&nbsp;linalg.<a href="#-solve">solve</a>(a,&nbsp;b)<br>
&gt;&gt;&gt;&nbsp;x<br>
array([&nbsp;2.,&nbsp;-2.,&nbsp;&nbsp;9.])<br>
&gt;&gt;&gt;&nbsp;np.dot(a,&nbsp;x)&nbsp;==&nbsp;b<br>
array([&nbsp;True,&nbsp;&nbsp;True,&nbsp;&nbsp;True],&nbsp;dtype=bool)</tt></dd></dl>
 <dl><dt><a name="-solve_banded"><strong>solve_banded</strong></a>(l_and_u, ab, b, overwrite_ab<font color="#909090">=False</font>, overwrite_b<font color="#909090">=False</font>, debug<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Solve&nbsp;the&nbsp;equation&nbsp;a&nbsp;x&nbsp;=&nbsp;b&nbsp;for&nbsp;x,&nbsp;assuming&nbsp;a&nbsp;is&nbsp;banded&nbsp;matrix.<br>
&nbsp;<br>
The&nbsp;matrix&nbsp;a&nbsp;is&nbsp;stored&nbsp;in&nbsp;`ab`&nbsp;using&nbsp;the&nbsp;matrix&nbsp;diagonal&nbsp;ordered&nbsp;form::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;ab[u&nbsp;+&nbsp;i&nbsp;-&nbsp;j,&nbsp;j]&nbsp;==&nbsp;a[i,j]<br>
&nbsp;<br>
Example&nbsp;of&nbsp;`ab`&nbsp;(shape&nbsp;of&nbsp;a&nbsp;is&nbsp;(6,6),&nbsp;`u`&nbsp;=1,&nbsp;`l`&nbsp;=2)::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;a01&nbsp;&nbsp;a12&nbsp;&nbsp;a23&nbsp;&nbsp;a34&nbsp;&nbsp;a45<br>
&nbsp;&nbsp;&nbsp;&nbsp;a00&nbsp;&nbsp;a11&nbsp;&nbsp;a22&nbsp;&nbsp;a33&nbsp;&nbsp;a44&nbsp;&nbsp;a55<br>
&nbsp;&nbsp;&nbsp;&nbsp;a10&nbsp;&nbsp;a21&nbsp;&nbsp;a32&nbsp;&nbsp;a43&nbsp;&nbsp;a54&nbsp;&nbsp;&nbsp;*<br>
&nbsp;&nbsp;&nbsp;&nbsp;a20&nbsp;&nbsp;a31&nbsp;&nbsp;a42&nbsp;&nbsp;a53&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;*<br>
&nbsp;<br>
Parameters<br>
----------<br>
(l,&nbsp;u)&nbsp;:&nbsp;(integer,&nbsp;integer)<br>
&nbsp;&nbsp;&nbsp;&nbsp;Number&nbsp;of&nbsp;non-zero&nbsp;lower&nbsp;and&nbsp;upper&nbsp;diagonals<br>
ab&nbsp;:&nbsp;(`l`&nbsp;+&nbsp;`u`&nbsp;+&nbsp;1,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Banded&nbsp;matrix<br>
b&nbsp;:&nbsp;(M,)&nbsp;or&nbsp;(M,&nbsp;K)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Right-hand&nbsp;side<br>
overwrite_ab&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Discard&nbsp;data&nbsp;in&nbsp;`ab`&nbsp;(may&nbsp;enhance&nbsp;performance)<br>
overwrite_b&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Discard&nbsp;data&nbsp;in&nbsp;`b`&nbsp;(may&nbsp;enhance&nbsp;performance)<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrices&nbsp;contain&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
x&nbsp;:&nbsp;(M,)&nbsp;or&nbsp;(M,&nbsp;K)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;solution&nbsp;to&nbsp;the&nbsp;system&nbsp;a&nbsp;x&nbsp;=&nbsp;b.&nbsp;&nbsp;Returned&nbsp;shape&nbsp;depends&nbsp;on&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;shape&nbsp;of&nbsp;`b`.</tt></dd></dl>
 <dl><dt><a name="-solve_circulant"><strong>solve_circulant</strong></a>(c, b, singular<font color="#909090">='raise'</font>, tol<font color="#909090">=None</font>, caxis<font color="#909090">=-1</font>, baxis<font color="#909090">=0</font>, outaxis<font color="#909090">=0</font>)</dt><dd><tt>Solve&nbsp;C&nbsp;x&nbsp;=&nbsp;b&nbsp;for&nbsp;x,&nbsp;where&nbsp;C&nbsp;is&nbsp;a&nbsp;circulant&nbsp;matrix.<br>
&nbsp;<br>
`C`&nbsp;is&nbsp;the&nbsp;circulant&nbsp;matrix&nbsp;associated&nbsp;with&nbsp;the&nbsp;vector&nbsp;`c`.<br>
&nbsp;<br>
The&nbsp;system&nbsp;is&nbsp;solved&nbsp;by&nbsp;doing&nbsp;division&nbsp;in&nbsp;Fourier&nbsp;space.&nbsp;&nbsp;The<br>
calculation&nbsp;is::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;ifft(fft(b)&nbsp;/&nbsp;fft(c))<br>
&nbsp;<br>
where&nbsp;`fft`&nbsp;and&nbsp;`ifft`&nbsp;are&nbsp;the&nbsp;fast&nbsp;Fourier&nbsp;transform&nbsp;and&nbsp;its&nbsp;inverse,<br>
respectively.&nbsp;&nbsp;For&nbsp;a&nbsp;large&nbsp;vector&nbsp;`c`,&nbsp;this&nbsp;is&nbsp;*much*&nbsp;faster&nbsp;than<br>
solving&nbsp;the&nbsp;system&nbsp;with&nbsp;the&nbsp;full&nbsp;circulant&nbsp;matrix.<br>
&nbsp;<br>
Parameters<br>
----------<br>
c&nbsp;:&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;coefficients&nbsp;of&nbsp;the&nbsp;circulant&nbsp;matrix.<br>
b&nbsp;:&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Right-hand&nbsp;side&nbsp;matrix&nbsp;in&nbsp;``a&nbsp;x&nbsp;=&nbsp;b``.<br>
singular&nbsp;:&nbsp;str,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;argument&nbsp;controls&nbsp;how&nbsp;a&nbsp;near&nbsp;singular&nbsp;circulant&nbsp;matrix&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;handled.&nbsp;&nbsp;If&nbsp;`singular`&nbsp;is&nbsp;"raise"&nbsp;and&nbsp;the&nbsp;circulant&nbsp;matrix&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;near&nbsp;singular,&nbsp;a&nbsp;`<a href="#LinAlgError">LinAlgError</a>`&nbsp;is&nbsp;raised.&nbsp;&nbsp;If&nbsp;`singular`&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;"lstsq",&nbsp;the&nbsp;least&nbsp;squares&nbsp;solution&nbsp;is&nbsp;returned.&nbsp;&nbsp;Default&nbsp;is&nbsp;"raise".<br>
tol&nbsp;:&nbsp;float,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;any&nbsp;eigenvalue&nbsp;of&nbsp;the&nbsp;circulant&nbsp;matrix&nbsp;has&nbsp;an&nbsp;absolute&nbsp;value<br>
&nbsp;&nbsp;&nbsp;&nbsp;that&nbsp;is&nbsp;less&nbsp;than&nbsp;or&nbsp;equal&nbsp;to&nbsp;`tol`,&nbsp;the&nbsp;matrix&nbsp;is&nbsp;considered&nbsp;to&nbsp;be<br>
&nbsp;&nbsp;&nbsp;&nbsp;near&nbsp;singular.&nbsp;&nbsp;If&nbsp;not&nbsp;given,&nbsp;`tol`&nbsp;is&nbsp;set&nbsp;to::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tol&nbsp;=&nbsp;abs_eigs.max()&nbsp;*&nbsp;abs_eigs.size&nbsp;*&nbsp;np.finfo(np.float64).eps<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;where&nbsp;`abs_eigs`&nbsp;is&nbsp;the&nbsp;array&nbsp;of&nbsp;absolute&nbsp;values&nbsp;of&nbsp;the&nbsp;eigenvalues<br>
&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;the&nbsp;circulant&nbsp;matrix.<br>
caxis&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;When&nbsp;`c`&nbsp;has&nbsp;dimension&nbsp;greater&nbsp;than&nbsp;1,&nbsp;it&nbsp;is&nbsp;viewed&nbsp;as&nbsp;a&nbsp;collection<br>
&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;circulant&nbsp;vectors.&nbsp;&nbsp;In&nbsp;this&nbsp;case,&nbsp;`caxis`&nbsp;is&nbsp;the&nbsp;axis&nbsp;of&nbsp;`c`&nbsp;that<br>
&nbsp;&nbsp;&nbsp;&nbsp;holds&nbsp;the&nbsp;vectors&nbsp;of&nbsp;circulant&nbsp;coefficients.<br>
baxis&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;When&nbsp;`b`&nbsp;has&nbsp;dimension&nbsp;greater&nbsp;than&nbsp;1,&nbsp;it&nbsp;is&nbsp;viewed&nbsp;as&nbsp;a&nbsp;collection<br>
&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;vectors.&nbsp;&nbsp;In&nbsp;this&nbsp;case,&nbsp;`baxis`&nbsp;is&nbsp;the&nbsp;axis&nbsp;of&nbsp;`b`&nbsp;that&nbsp;holds&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;right-hand&nbsp;side&nbsp;vectors.<br>
outaxis&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;When&nbsp;`c`&nbsp;or&nbsp;`b`&nbsp;are&nbsp;multidimensional,&nbsp;the&nbsp;value&nbsp;returned&nbsp;by<br>
&nbsp;&nbsp;&nbsp;&nbsp;`solve_circulant`&nbsp;is&nbsp;multidimensional.&nbsp;&nbsp;In&nbsp;this&nbsp;case,&nbsp;`outaxis`&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;axis&nbsp;of&nbsp;the&nbsp;result&nbsp;that&nbsp;holds&nbsp;the&nbsp;solution&nbsp;vectors.<br>
&nbsp;<br>
Returns<br>
-------<br>
x&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Solution&nbsp;to&nbsp;the&nbsp;system&nbsp;``C&nbsp;x&nbsp;=&nbsp;b``.<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;the&nbsp;circulant&nbsp;matrix&nbsp;associated&nbsp;with&nbsp;`c`&nbsp;is&nbsp;near&nbsp;singular.<br>
&nbsp;<br>
See&nbsp;Also<br>
--------<br>
circulant<br>
&nbsp;<br>
Notes<br>
-----<br>
For&nbsp;a&nbsp;one-dimensional&nbsp;vector&nbsp;`c`&nbsp;with&nbsp;length&nbsp;`m`,&nbsp;and&nbsp;an&nbsp;array&nbsp;`b`<br>
with&nbsp;shape&nbsp;``(m,&nbsp;...)``,<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#-solve_circulant">solve_circulant</a>(c,&nbsp;b)<br>
&nbsp;<br>
returns&nbsp;the&nbsp;same&nbsp;result&nbsp;as<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#-solve">solve</a>(<a href="#-circulant">circulant</a>(c),&nbsp;b)<br>
&nbsp;<br>
where&nbsp;`solve`&nbsp;and&nbsp;`circulant`&nbsp;are&nbsp;from&nbsp;`scipy.linalg`.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.16.0<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;solve_circulant,&nbsp;solve,&nbsp;circulant,&nbsp;lstsq<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;c&nbsp;=&nbsp;np.array([2,&nbsp;2,&nbsp;4])<br>
&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;np.array([1,&nbsp;2,&nbsp;3])<br>
&gt;&gt;&gt;&nbsp;<a href="#-solve_circulant">solve_circulant</a>(c,&nbsp;b)<br>
array([&nbsp;0.75,&nbsp;-0.25,&nbsp;&nbsp;0.25])<br>
&nbsp;<br>
Compare&nbsp;that&nbsp;result&nbsp;to&nbsp;solving&nbsp;the&nbsp;system&nbsp;with&nbsp;`scipy.linalg.solve`:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;<a href="#-solve">solve</a>(<a href="#-circulant">circulant</a>(c),&nbsp;b)<br>
array([&nbsp;0.75,&nbsp;-0.25,&nbsp;&nbsp;0.25])<br>
&nbsp;<br>
A&nbsp;singular&nbsp;example:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;c&nbsp;=&nbsp;np.array([1,&nbsp;1,&nbsp;0,&nbsp;0])<br>
&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;np.array([1,&nbsp;2,&nbsp;3,&nbsp;4])<br>
&nbsp;<br>
Calling&nbsp;``<a href="#-solve_circulant">solve_circulant</a>(c,&nbsp;b)``&nbsp;will&nbsp;raise&nbsp;a&nbsp;`<a href="#LinAlgError">LinAlgError</a>`.&nbsp;&nbsp;For&nbsp;the<br>
least&nbsp;square&nbsp;solution,&nbsp;use&nbsp;the&nbsp;option&nbsp;``singular='lstsq'``:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;<a href="#-solve_circulant">solve_circulant</a>(c,&nbsp;b,&nbsp;singular='lstsq')<br>
array([&nbsp;0.25,&nbsp;&nbsp;1.25,&nbsp;&nbsp;2.25,&nbsp;&nbsp;1.25])<br>
&nbsp;<br>
Compare&nbsp;to&nbsp;`scipy.linalg.lstsq`:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;x,&nbsp;resid,&nbsp;rnk,&nbsp;s&nbsp;=&nbsp;<a href="#-lstsq">lstsq</a>(<a href="#-circulant">circulant</a>(c),&nbsp;b)<br>
&gt;&gt;&gt;&nbsp;x<br>
array([&nbsp;0.25,&nbsp;&nbsp;1.25,&nbsp;&nbsp;2.25,&nbsp;&nbsp;1.25])<br>
&nbsp;<br>
A&nbsp;broadcasting&nbsp;example:<br>
&nbsp;<br>
Suppose&nbsp;we&nbsp;have&nbsp;the&nbsp;vectors&nbsp;of&nbsp;two&nbsp;circulant&nbsp;matrices&nbsp;stored&nbsp;in&nbsp;an&nbsp;array<br>
with&nbsp;shape&nbsp;(2,&nbsp;5),&nbsp;and&nbsp;three&nbsp;`b`&nbsp;vectors&nbsp;stored&nbsp;in&nbsp;an&nbsp;array&nbsp;with&nbsp;shape<br>
(3,&nbsp;5).&nbsp;&nbsp;For&nbsp;example,<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;c&nbsp;=&nbsp;np.array([[1.5,&nbsp;2,&nbsp;3,&nbsp;0,&nbsp;0],&nbsp;[1,&nbsp;1,&nbsp;4,&nbsp;3,&nbsp;2]])<br>
&gt;&gt;&gt;&nbsp;b&nbsp;=&nbsp;np.arange(15).reshape(-1,&nbsp;5)<br>
&nbsp;<br>
We&nbsp;want&nbsp;to&nbsp;solve&nbsp;all&nbsp;combinations&nbsp;of&nbsp;circulant&nbsp;matrices&nbsp;and&nbsp;`b`&nbsp;vectors,<br>
with&nbsp;the&nbsp;result&nbsp;stored&nbsp;in&nbsp;an&nbsp;array&nbsp;with&nbsp;shape&nbsp;(2,&nbsp;3,&nbsp;5).&nbsp;&nbsp;When&nbsp;we<br>
disregard&nbsp;the&nbsp;axes&nbsp;of&nbsp;`c`&nbsp;and&nbsp;`b`&nbsp;that&nbsp;hold&nbsp;the&nbsp;vectors&nbsp;of&nbsp;coefficients,<br>
the&nbsp;shapes&nbsp;of&nbsp;the&nbsp;collections&nbsp;are&nbsp;(2,)&nbsp;and&nbsp;(3,),&nbsp;respectively,&nbsp;which&nbsp;are<br>
not&nbsp;compatible&nbsp;for&nbsp;broadcasting.&nbsp;&nbsp;To&nbsp;have&nbsp;a&nbsp;broadcast&nbsp;result&nbsp;with&nbsp;shape<br>
(2,&nbsp;3),&nbsp;we&nbsp;add&nbsp;a&nbsp;trivial&nbsp;dimension&nbsp;to&nbsp;`c`:&nbsp;``c[:,&nbsp;np.newaxis,&nbsp;:]``&nbsp;has<br>
shape&nbsp;(2,&nbsp;1,&nbsp;5).&nbsp;&nbsp;The&nbsp;last&nbsp;dimension&nbsp;holds&nbsp;the&nbsp;coefficients&nbsp;of&nbsp;the<br>
circulant&nbsp;matrices,&nbsp;so&nbsp;when&nbsp;we&nbsp;call&nbsp;`solve_circulant`,&nbsp;we&nbsp;can&nbsp;use&nbsp;the<br>
default&nbsp;``caxis=-1``.&nbsp;&nbsp;The&nbsp;coefficients&nbsp;of&nbsp;the&nbsp;`b`&nbsp;vectors&nbsp;are&nbsp;in&nbsp;the&nbsp;last<br>
dimension&nbsp;of&nbsp;the&nbsp;array&nbsp;`b`,&nbsp;so&nbsp;we&nbsp;use&nbsp;``baxis=-1``.&nbsp;&nbsp;If&nbsp;we&nbsp;use&nbsp;the<br>
default&nbsp;`outaxis`,&nbsp;the&nbsp;result&nbsp;will&nbsp;have&nbsp;shape&nbsp;(5,&nbsp;2,&nbsp;3),&nbsp;so&nbsp;we'll&nbsp;use<br>
``outaxis=-1``&nbsp;to&nbsp;put&nbsp;the&nbsp;solution&nbsp;vectors&nbsp;in&nbsp;the&nbsp;last&nbsp;dimension.<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;x&nbsp;=&nbsp;<a href="#-solve_circulant">solve_circulant</a>(c[:,&nbsp;np.newaxis,&nbsp;:],&nbsp;b,&nbsp;baxis=-1,&nbsp;outaxis=-1)<br>
&gt;&gt;&gt;&nbsp;x.shape<br>
(2,&nbsp;3,&nbsp;5)<br>
&gt;&gt;&gt;&nbsp;np.set_printoptions(precision=3)&nbsp;&nbsp;#&nbsp;For&nbsp;compact&nbsp;output&nbsp;of&nbsp;numbers.<br>
&gt;&gt;&gt;&nbsp;x<br>
array([[[-0.118,&nbsp;&nbsp;0.22&nbsp;,&nbsp;&nbsp;1.277,&nbsp;-0.142,&nbsp;&nbsp;0.302],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.651,&nbsp;&nbsp;0.989,&nbsp;&nbsp;2.046,&nbsp;&nbsp;0.627,&nbsp;&nbsp;1.072],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.42&nbsp;,&nbsp;&nbsp;1.758,&nbsp;&nbsp;2.816,&nbsp;&nbsp;1.396,&nbsp;&nbsp;1.841]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[&nbsp;0.401,&nbsp;&nbsp;0.304,&nbsp;&nbsp;0.694,&nbsp;-0.867,&nbsp;&nbsp;0.377],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.856,&nbsp;&nbsp;0.758,&nbsp;&nbsp;1.149,&nbsp;-0.412,&nbsp;&nbsp;0.831],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.31&nbsp;,&nbsp;&nbsp;1.213,&nbsp;&nbsp;1.603,&nbsp;&nbsp;0.042,&nbsp;&nbsp;1.286]]])<br>
&nbsp;<br>
Check&nbsp;by&nbsp;solving&nbsp;one&nbsp;pair&nbsp;of&nbsp;`c`&nbsp;and&nbsp;`b`&nbsp;vectors&nbsp;(cf.&nbsp;``x[1,&nbsp;1,&nbsp;:]``):<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;<a href="#-solve_circulant">solve_circulant</a>(c[1],&nbsp;b[1,&nbsp;:])<br>
array([&nbsp;0.856,&nbsp;&nbsp;0.758,&nbsp;&nbsp;1.149,&nbsp;-0.412,&nbsp;&nbsp;0.831])</tt></dd></dl>
 <dl><dt><a name="-solve_continuous_are"><strong>solve_continuous_are</strong></a>(a, b, q, r)</dt><dd><tt>Solves&nbsp;the&nbsp;continuous&nbsp;algebraic&nbsp;Riccati&nbsp;equation&nbsp;(CARE).<br>
&nbsp;<br>
The&nbsp;CARE&nbsp;is&nbsp;defined&nbsp;as<br>
&nbsp;<br>
..&nbsp;math::<br>
&nbsp;&nbsp;&nbsp;&nbsp;(A'X&nbsp;+&nbsp;XA&nbsp;-&nbsp;XBR^-1B'X+Q=0)<br>
&nbsp;<br>
It&nbsp;is&nbsp;solved&nbsp;directly&nbsp;using&nbsp;a&nbsp;Schur&nbsp;decomposition&nbsp;method.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Input<br>
b&nbsp;:&nbsp;(M,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Input<br>
q&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Input<br>
r&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Non-singular,&nbsp;square&nbsp;matrix<br>
&nbsp;<br>
Returns<br>
-------<br>
x&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Solution&nbsp;to&nbsp;the&nbsp;continuous&nbsp;algebraic&nbsp;Riccati&nbsp;equation<br>
&nbsp;<br>
See&nbsp;Also<br>
--------<br>
solve_discrete_are&nbsp;:&nbsp;Solves&nbsp;the&nbsp;discrete&nbsp;algebraic&nbsp;Riccati&nbsp;equation<br>
&nbsp;<br>
Notes<br>
-----<br>
Method&nbsp;taken&nbsp;from:<br>
Laub,&nbsp;"A&nbsp;Schur&nbsp;Method&nbsp;for&nbsp;Solving&nbsp;Algebraic&nbsp;Riccati&nbsp;Equations."<br>
U.S.&nbsp;Energy&nbsp;Research&nbsp;and&nbsp;Development&nbsp;Agency&nbsp;under&nbsp;contract<br>
ERDA-E(49-18)-2087.<br>
<a href="http://dspace.mit.edu/bitstream/handle/1721.1/1301/R-0859-05666488.pdf">http://dspace.mit.edu/bitstream/handle/1721.1/1301/R-0859-05666488.pdf</a><br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0</tt></dd></dl>
 <dl><dt><a name="-solve_discrete_are"><strong>solve_discrete_are</strong></a>(a, b, q, r)</dt><dd><tt>Solves&nbsp;the&nbsp;discrete&nbsp;algebraic&nbsp;Riccati&nbsp;equation&nbsp;(DARE).<br>
&nbsp;<br>
The&nbsp;DARE&nbsp;is&nbsp;defined&nbsp;as<br>
&nbsp;<br>
..&nbsp;math::<br>
&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;A'XA-(A'XB)(R+B'XB)^-1(B'XA)+Q<br>
&nbsp;<br>
It&nbsp;is&nbsp;solved&nbsp;directly&nbsp;using&nbsp;a&nbsp;Schur&nbsp;decomposition&nbsp;method.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Non-singular,&nbsp;square&nbsp;matrix<br>
b&nbsp;:&nbsp;(M,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Input<br>
q&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Input<br>
r&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Non-singular,&nbsp;square&nbsp;matrix<br>
&nbsp;<br>
Returns<br>
-------<br>
x&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Solution&nbsp;to&nbsp;the&nbsp;continuous&nbsp;Lyapunov&nbsp;equation<br>
&nbsp;<br>
See&nbsp;Also<br>
--------<br>
solve_continuous_are&nbsp;:&nbsp;Solves&nbsp;the&nbsp;continuous&nbsp;algebraic&nbsp;Riccati&nbsp;equation<br>
&nbsp;<br>
Notes<br>
-----<br>
Method&nbsp;taken&nbsp;from:<br>
Laub,&nbsp;"A&nbsp;Schur&nbsp;Method&nbsp;for&nbsp;Solving&nbsp;Algebraic&nbsp;Riccati&nbsp;Equations."<br>
U.S.&nbsp;Energy&nbsp;Research&nbsp;and&nbsp;Development&nbsp;Agency&nbsp;under&nbsp;contract<br>
ERDA-E(49-18)-2087.<br>
<a href="http://dspace.mit.edu/bitstream/handle/1721.1/1301/R-0859-05666488.pdf">http://dspace.mit.edu/bitstream/handle/1721.1/1301/R-0859-05666488.pdf</a><br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0</tt></dd></dl>
 <dl><dt><a name="-solve_discrete_lyapunov"><strong>solve_discrete_lyapunov</strong></a>(a, q, method<font color="#909090">=None</font>)</dt><dd><tt>Solves&nbsp;the&nbsp;discrete&nbsp;Lyapunov&nbsp;equation&nbsp;:math:`AXA^H&nbsp;-&nbsp;X&nbsp;+&nbsp;Q&nbsp;=&nbsp;0`.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a,&nbsp;q&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Square&nbsp;matrices&nbsp;corresponding&nbsp;to&nbsp;A&nbsp;and&nbsp;Q&nbsp;in&nbsp;the&nbsp;equation<br>
&nbsp;&nbsp;&nbsp;&nbsp;above&nbsp;respectively.&nbsp;Must&nbsp;have&nbsp;the&nbsp;same&nbsp;shape.<br>
&nbsp;<br>
method&nbsp;:&nbsp;{'direct',&nbsp;'bilinear'},&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;of&nbsp;solver.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;not&nbsp;given,&nbsp;chosen&nbsp;to&nbsp;be&nbsp;``direct``&nbsp;if&nbsp;``M``&nbsp;is&nbsp;less&nbsp;than&nbsp;10&nbsp;and<br>
&nbsp;&nbsp;&nbsp;&nbsp;``bilinear``&nbsp;otherwise.<br>
&nbsp;<br>
Returns<br>
-------<br>
x&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Solution&nbsp;to&nbsp;the&nbsp;discrete&nbsp;Lyapunov&nbsp;equation<br>
&nbsp;<br>
See&nbsp;Also<br>
--------<br>
solve_lyapunov&nbsp;:&nbsp;computes&nbsp;the&nbsp;solution&nbsp;to&nbsp;the&nbsp;continuous&nbsp;Lyapunov&nbsp;equation<br>
&nbsp;<br>
Notes<br>
-----<br>
This&nbsp;section&nbsp;describes&nbsp;the&nbsp;available&nbsp;solvers&nbsp;that&nbsp;can&nbsp;be&nbsp;selected&nbsp;by&nbsp;the<br>
'method'&nbsp;parameter.&nbsp;The&nbsp;default&nbsp;method&nbsp;is&nbsp;*direct*&nbsp;if&nbsp;``M``&nbsp;is&nbsp;less&nbsp;than&nbsp;10<br>
and&nbsp;``bilinear``&nbsp;otherwise.<br>
&nbsp;<br>
Method&nbsp;*direct*&nbsp;uses&nbsp;a&nbsp;direct&nbsp;analytical&nbsp;solution&nbsp;to&nbsp;the&nbsp;discrete&nbsp;Lyapunov<br>
equation.&nbsp;The&nbsp;algorithm&nbsp;is&nbsp;given&nbsp;in,&nbsp;for&nbsp;example,&nbsp;[1]_.&nbsp;However&nbsp;it&nbsp;requires<br>
the&nbsp;linear&nbsp;solution&nbsp;of&nbsp;a&nbsp;system&nbsp;with&nbsp;dimension&nbsp;:math:`M^2`&nbsp;so&nbsp;that<br>
performance&nbsp;degrades&nbsp;rapidly&nbsp;for&nbsp;even&nbsp;moderately&nbsp;sized&nbsp;matrices.<br>
&nbsp;<br>
Method&nbsp;*bilinear*&nbsp;uses&nbsp;a&nbsp;bilinear&nbsp;transformation&nbsp;to&nbsp;convert&nbsp;the&nbsp;discrete<br>
Lyapunov&nbsp;equation&nbsp;to&nbsp;a&nbsp;continuous&nbsp;Lyapunov&nbsp;equation&nbsp;:math:`(BX+XB'=-C)`<br>
where&nbsp;:math:`B=(A-I)(A+I)^{-1}`&nbsp;and<br>
:math:`C=2(A'&nbsp;+&nbsp;I)^{-1}&nbsp;Q&nbsp;(A&nbsp;+&nbsp;I)^{-1}`.&nbsp;The&nbsp;continuous&nbsp;equation&nbsp;can&nbsp;be<br>
efficiently&nbsp;solved&nbsp;since&nbsp;it&nbsp;is&nbsp;a&nbsp;special&nbsp;case&nbsp;of&nbsp;a&nbsp;Sylvester&nbsp;equation.<br>
The&nbsp;transformation&nbsp;algorithm&nbsp;is&nbsp;from&nbsp;Popov&nbsp;(1964)&nbsp;as&nbsp;described&nbsp;in&nbsp;[2]_.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0<br>
&nbsp;<br>
References<br>
----------<br>
..&nbsp;[1]&nbsp;Hamilton,&nbsp;James&nbsp;D.&nbsp;Time&nbsp;Series&nbsp;Analysis,&nbsp;Princeton:&nbsp;Princeton<br>
&nbsp;&nbsp;&nbsp;University&nbsp;Press,&nbsp;1994.&nbsp;&nbsp;265.&nbsp;&nbsp;Print.<br>
&nbsp;&nbsp;&nbsp;<a href="http://www.scribd.com/doc/20577138/Hamilton-1994-Time-Series-Analysis">http://www.scribd.com/doc/20577138/Hamilton-1994-Time-Series-Analysis</a><br>
..&nbsp;[2]&nbsp;Gajic,&nbsp;Z.,&nbsp;and&nbsp;M.T.J.&nbsp;Qureshi.&nbsp;2008.<br>
&nbsp;&nbsp;&nbsp;Lyapunov&nbsp;Matrix&nbsp;Equation&nbsp;in&nbsp;System&nbsp;Stability&nbsp;and&nbsp;Control.<br>
&nbsp;&nbsp;&nbsp;Dover&nbsp;Books&nbsp;on&nbsp;Engineering&nbsp;Series.&nbsp;Dover&nbsp;Publications.</tt></dd></dl>
 <dl><dt><a name="-solve_lyapunov"><strong>solve_lyapunov</strong></a>(a, q)</dt><dd><tt>Solves&nbsp;the&nbsp;continuous&nbsp;Lyapunov&nbsp;equation&nbsp;:math:`AX&nbsp;+&nbsp;XA^H&nbsp;=&nbsp;Q`.<br>
&nbsp;<br>
Uses&nbsp;the&nbsp;Bartels-Stewart&nbsp;algorithm&nbsp;to&nbsp;find&nbsp;:math:`X`.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;square&nbsp;matrix<br>
&nbsp;<br>
q&nbsp;:&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Right-hand&nbsp;side&nbsp;square&nbsp;matrix<br>
&nbsp;<br>
Returns<br>
-------<br>
x&nbsp;:&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Solution&nbsp;to&nbsp;the&nbsp;continuous&nbsp;Lyapunov&nbsp;equation<br>
&nbsp;<br>
See&nbsp;Also<br>
--------<br>
solve_sylvester&nbsp;:&nbsp;computes&nbsp;the&nbsp;solution&nbsp;to&nbsp;the&nbsp;Sylvester&nbsp;equation<br>
&nbsp;<br>
Notes<br>
-----<br>
Because&nbsp;the&nbsp;continuous&nbsp;Lyapunov&nbsp;equation&nbsp;is&nbsp;just&nbsp;a&nbsp;special&nbsp;form&nbsp;of&nbsp;the<br>
Sylvester&nbsp;equation,&nbsp;this&nbsp;solver&nbsp;relies&nbsp;entirely&nbsp;on&nbsp;solve_sylvester&nbsp;for&nbsp;a<br>
solution.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0</tt></dd></dl>
 <dl><dt><a name="-solve_sylvester"><strong>solve_sylvester</strong></a>(a, b, q)</dt><dd><tt>Computes&nbsp;a&nbsp;solution&nbsp;(X)&nbsp;to&nbsp;the&nbsp;Sylvester&nbsp;equation&nbsp;:math:`AX&nbsp;+&nbsp;XB&nbsp;=&nbsp;Q`.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Leading&nbsp;matrix&nbsp;of&nbsp;the&nbsp;Sylvester&nbsp;equation<br>
b&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Trailing&nbsp;matrix&nbsp;of&nbsp;the&nbsp;Sylvester&nbsp;equation<br>
q&nbsp;:&nbsp;(M,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Right-hand&nbsp;side<br>
&nbsp;<br>
Returns<br>
-------<br>
x&nbsp;:&nbsp;(M,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;solution&nbsp;to&nbsp;the&nbsp;Sylvester&nbsp;equation.<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;solution&nbsp;was&nbsp;not&nbsp;found<br>
&nbsp;<br>
Notes<br>
-----<br>
Computes&nbsp;a&nbsp;solution&nbsp;to&nbsp;the&nbsp;Sylvester&nbsp;matrix&nbsp;equation&nbsp;via&nbsp;the&nbsp;Bartels-<br>
Stewart&nbsp;algorithm.&nbsp;&nbsp;The&nbsp;A&nbsp;and&nbsp;B&nbsp;matrices&nbsp;first&nbsp;undergo&nbsp;Schur<br>
decompositions.&nbsp;&nbsp;The&nbsp;resulting&nbsp;matrices&nbsp;are&nbsp;used&nbsp;to&nbsp;construct&nbsp;an<br>
alternative&nbsp;Sylvester&nbsp;equation&nbsp;(``RY&nbsp;+&nbsp;YS^T&nbsp;=&nbsp;F``)&nbsp;where&nbsp;the&nbsp;R&nbsp;and&nbsp;S<br>
matrices&nbsp;are&nbsp;in&nbsp;quasi-triangular&nbsp;form&nbsp;(or,&nbsp;when&nbsp;R,&nbsp;S&nbsp;or&nbsp;F&nbsp;are&nbsp;complex,<br>
triangular&nbsp;form).&nbsp;&nbsp;The&nbsp;simplified&nbsp;equation&nbsp;is&nbsp;then&nbsp;solved&nbsp;using<br>
``*TRSYL``&nbsp;from&nbsp;LAPACK&nbsp;directly.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0</tt></dd></dl>
 <dl><dt><a name="-solve_toeplitz"><strong>solve_toeplitz</strong></a>(c_or_cr, b, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Solve&nbsp;a&nbsp;Toeplitz&nbsp;system&nbsp;using&nbsp;Levinson&nbsp;Recursion<br>
&nbsp;<br>
The&nbsp;Toeplitz&nbsp;matrix&nbsp;has&nbsp;constant&nbsp;diagonals,&nbsp;with&nbsp;c&nbsp;as&nbsp;its&nbsp;first&nbsp;column<br>
and&nbsp;r&nbsp;as&nbsp;its&nbsp;first&nbsp;row.&nbsp;&nbsp;If&nbsp;r&nbsp;is&nbsp;not&nbsp;given,&nbsp;``r&nbsp;==&nbsp;conjugate(c)``&nbsp;is<br>
assumed.<br>
&nbsp;<br>
Parameters<br>
----------<br>
c_or_cr&nbsp;:&nbsp;array_like&nbsp;or&nbsp;tuple&nbsp;of&nbsp;(array_like,&nbsp;array_like)<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;vector&nbsp;``c``,&nbsp;or&nbsp;a&nbsp;tuple&nbsp;of&nbsp;arrays&nbsp;(``c``,&nbsp;``r``).&nbsp;Whatever&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;actual&nbsp;shape&nbsp;of&nbsp;``c``,&nbsp;it&nbsp;will&nbsp;be&nbsp;converted&nbsp;to&nbsp;a&nbsp;1-D&nbsp;array.&nbsp;If&nbsp;not<br>
&nbsp;&nbsp;&nbsp;&nbsp;supplied,&nbsp;``r&nbsp;=&nbsp;conjugate(c)``&nbsp;is&nbsp;assumed;&nbsp;in&nbsp;this&nbsp;case,&nbsp;if&nbsp;c[0]&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;real,&nbsp;the&nbsp;Toeplitz&nbsp;matrix&nbsp;is&nbsp;Hermitian.&nbsp;r[0]&nbsp;is&nbsp;ignored;&nbsp;the&nbsp;first&nbsp;row<br>
&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;the&nbsp;Toeplitz&nbsp;matrix&nbsp;is&nbsp;``[c[0],&nbsp;r[1:]]``.&nbsp;&nbsp;Whatever&nbsp;the&nbsp;actual&nbsp;shape<br>
&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;``r``,&nbsp;it&nbsp;will&nbsp;be&nbsp;converted&nbsp;to&nbsp;a&nbsp;1-D&nbsp;array.<br>
b&nbsp;:&nbsp;(M,)&nbsp;or&nbsp;(M,&nbsp;K)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Right-hand&nbsp;side&nbsp;in&nbsp;``T&nbsp;x&nbsp;=&nbsp;b``.<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrices&nbsp;contain&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(result&nbsp;entirely&nbsp;NaNs)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
x&nbsp;:&nbsp;(M,)&nbsp;or&nbsp;(M,&nbsp;K)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;solution&nbsp;to&nbsp;the&nbsp;system&nbsp;``T&nbsp;x&nbsp;=&nbsp;b``.&nbsp;&nbsp;Shape&nbsp;of&nbsp;return&nbsp;matches&nbsp;shape<br>
&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;`b`.<br>
&nbsp;<br>
Notes<br>
-----<br>
The&nbsp;solution&nbsp;is&nbsp;computed&nbsp;using&nbsp;Levinson-Durbin&nbsp;recursion,&nbsp;which&nbsp;is&nbsp;faster<br>
than&nbsp;generic&nbsp;least-squares&nbsp;methods,&nbsp;but&nbsp;can&nbsp;be&nbsp;less&nbsp;numerically&nbsp;stable.</tt></dd></dl>
 <dl><dt><a name="-solve_triangular"><strong>solve_triangular</strong></a>(a, b, trans<font color="#909090">=0</font>, lower<font color="#909090">=False</font>, unit_diagonal<font color="#909090">=False</font>, overwrite_b<font color="#909090">=False</font>, debug<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Solve&nbsp;the&nbsp;equation&nbsp;`a&nbsp;x&nbsp;=&nbsp;b`&nbsp;for&nbsp;`x`,&nbsp;assuming&nbsp;a&nbsp;is&nbsp;a&nbsp;triangular&nbsp;matrix.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;triangular&nbsp;matrix<br>
b&nbsp;:&nbsp;(M,)&nbsp;or&nbsp;(M,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Right-hand&nbsp;side&nbsp;matrix&nbsp;in&nbsp;`a&nbsp;x&nbsp;=&nbsp;b`<br>
lower&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Use&nbsp;only&nbsp;data&nbsp;contained&nbsp;in&nbsp;the&nbsp;lower&nbsp;triangle&nbsp;of&nbsp;`a`.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Default&nbsp;is&nbsp;to&nbsp;use&nbsp;upper&nbsp;triangle.<br>
trans&nbsp;:&nbsp;{0,&nbsp;1,&nbsp;2,&nbsp;'N',&nbsp;'T',&nbsp;'C'},&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;of&nbsp;system&nbsp;to&nbsp;solve:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;========&nbsp;&nbsp;=========<br>
&nbsp;&nbsp;&nbsp;&nbsp;trans&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;system<br>
&nbsp;&nbsp;&nbsp;&nbsp;========&nbsp;&nbsp;=========<br>
&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;or&nbsp;'N'&nbsp;&nbsp;a&nbsp;x&nbsp;&nbsp;=&nbsp;b<br>
&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;or&nbsp;'T'&nbsp;&nbsp;a^T&nbsp;x&nbsp;=&nbsp;b<br>
&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;or&nbsp;'C'&nbsp;&nbsp;a^H&nbsp;x&nbsp;=&nbsp;b<br>
&nbsp;&nbsp;&nbsp;&nbsp;========&nbsp;&nbsp;=========<br>
unit_diagonal&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;diagonal&nbsp;elements&nbsp;of&nbsp;`a`&nbsp;are&nbsp;assumed&nbsp;to&nbsp;be&nbsp;1&nbsp;and<br>
&nbsp;&nbsp;&nbsp;&nbsp;will&nbsp;not&nbsp;be&nbsp;referenced.<br>
overwrite_b&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Allow&nbsp;overwriting&nbsp;data&nbsp;in&nbsp;`b`&nbsp;(may&nbsp;enhance&nbsp;performance)<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrices&nbsp;contain&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
x&nbsp;:&nbsp;(M,)&nbsp;or&nbsp;(M,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Solution&nbsp;to&nbsp;the&nbsp;system&nbsp;`a&nbsp;x&nbsp;=&nbsp;b`.&nbsp;&nbsp;Shape&nbsp;of&nbsp;return&nbsp;matches&nbsp;`b`.<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;`a`&nbsp;is&nbsp;singular<br>
&nbsp;<br>
Notes<br>
-----<br>
..&nbsp;versionadded::&nbsp;0.9.0</tt></dd></dl>
 <dl><dt><a name="-solveh_banded"><strong>solveh_banded</strong></a>(ab, b, overwrite_ab<font color="#909090">=False</font>, overwrite_b<font color="#909090">=False</font>, lower<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Solve&nbsp;equation&nbsp;a&nbsp;x&nbsp;=&nbsp;b.&nbsp;a&nbsp;is&nbsp;Hermitian&nbsp;positive-definite&nbsp;banded&nbsp;matrix.<br>
&nbsp;<br>
The&nbsp;matrix&nbsp;a&nbsp;is&nbsp;stored&nbsp;in&nbsp;`ab`&nbsp;either&nbsp;in&nbsp;lower&nbsp;diagonal&nbsp;or&nbsp;upper<br>
diagonal&nbsp;ordered&nbsp;form:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;ab[u&nbsp;+&nbsp;i&nbsp;-&nbsp;j,&nbsp;j]&nbsp;==&nbsp;a[i,j]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;upper&nbsp;form;&nbsp;i&nbsp;&lt;=&nbsp;j)<br>
&nbsp;&nbsp;&nbsp;&nbsp;ab[&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;-&nbsp;j,&nbsp;j]&nbsp;==&nbsp;a[i,j]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;lower&nbsp;form;&nbsp;i&nbsp;&gt;=&nbsp;j)<br>
&nbsp;<br>
Example&nbsp;of&nbsp;`ab`&nbsp;(shape&nbsp;of&nbsp;a&nbsp;is&nbsp;(6,&nbsp;6),&nbsp;`u`&nbsp;=2)::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;upper&nbsp;form:<br>
&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;a02&nbsp;a13&nbsp;a24&nbsp;a35<br>
&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;a01&nbsp;a12&nbsp;a23&nbsp;a34&nbsp;a45<br>
&nbsp;&nbsp;&nbsp;&nbsp;a00&nbsp;a11&nbsp;a22&nbsp;a33&nbsp;a44&nbsp;a55<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;lower&nbsp;form:<br>
&nbsp;&nbsp;&nbsp;&nbsp;a00&nbsp;a11&nbsp;a22&nbsp;a33&nbsp;a44&nbsp;a55<br>
&nbsp;&nbsp;&nbsp;&nbsp;a10&nbsp;a21&nbsp;a32&nbsp;a43&nbsp;a54&nbsp;*<br>
&nbsp;&nbsp;&nbsp;&nbsp;a20&nbsp;a31&nbsp;a42&nbsp;a53&nbsp;*&nbsp;&nbsp;&nbsp;*<br>
&nbsp;<br>
Cells&nbsp;marked&nbsp;with&nbsp;*&nbsp;are&nbsp;not&nbsp;used.<br>
&nbsp;<br>
Parameters<br>
----------<br>
ab&nbsp;:&nbsp;(`u`&nbsp;+&nbsp;1,&nbsp;M)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Banded&nbsp;matrix<br>
b&nbsp;:&nbsp;(M,)&nbsp;or&nbsp;(M,&nbsp;K)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Right-hand&nbsp;side<br>
overwrite_ab&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Discard&nbsp;data&nbsp;in&nbsp;`ab`&nbsp;(may&nbsp;enhance&nbsp;performance)<br>
overwrite_b&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Discard&nbsp;data&nbsp;in&nbsp;`b`&nbsp;(may&nbsp;enhance&nbsp;performance)<br>
lower&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Is&nbsp;the&nbsp;matrix&nbsp;in&nbsp;the&nbsp;lower&nbsp;form.&nbsp;(Default&nbsp;is&nbsp;upper&nbsp;form)<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrices&nbsp;contain&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
x&nbsp;:&nbsp;(M,)&nbsp;or&nbsp;(M,&nbsp;K)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;solution&nbsp;to&nbsp;the&nbsp;system&nbsp;a&nbsp;x&nbsp;=&nbsp;b.&nbsp;&nbsp;Shape&nbsp;of&nbsp;return&nbsp;matches&nbsp;shape<br>
&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;`b`.</tt></dd></dl>
 <dl><dt><a name="-sqrtm"><strong>sqrtm</strong></a>(A, disp<font color="#909090">=True</font>, blocksize<font color="#909090">=64</font>)</dt><dd><tt>Matrix&nbsp;square&nbsp;root.<br>
&nbsp;<br>
Parameters<br>
----------<br>
A&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;whose&nbsp;square&nbsp;root&nbsp;to&nbsp;evaluate<br>
disp&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Print&nbsp;warning&nbsp;if&nbsp;error&nbsp;in&nbsp;the&nbsp;result&nbsp;is&nbsp;estimated&nbsp;large<br>
&nbsp;&nbsp;&nbsp;&nbsp;instead&nbsp;of&nbsp;returning&nbsp;estimated&nbsp;error.&nbsp;(Default:&nbsp;True)<br>
blocksize&nbsp;:&nbsp;integer,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;the&nbsp;blocksize&nbsp;is&nbsp;not&nbsp;degenerate&nbsp;with&nbsp;respect&nbsp;to&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;of&nbsp;the&nbsp;input&nbsp;array,&nbsp;then&nbsp;use&nbsp;a&nbsp;blocked&nbsp;algorithm.&nbsp;(Default:&nbsp;64)<br>
&nbsp;<br>
Returns<br>
-------<br>
sqrtm&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Value&nbsp;of&nbsp;the&nbsp;sqrt&nbsp;function&nbsp;at&nbsp;`A`<br>
&nbsp;<br>
errest&nbsp;:&nbsp;float<br>
&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;disp&nbsp;==&nbsp;False)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Frobenius&nbsp;norm&nbsp;of&nbsp;the&nbsp;estimated&nbsp;error,&nbsp;||err||_F&nbsp;/&nbsp;||A||_F<br>
&nbsp;<br>
References<br>
----------<br>
..&nbsp;[1]&nbsp;Edvin&nbsp;Deadman,&nbsp;Nicholas&nbsp;J.&nbsp;Higham,&nbsp;Rui&nbsp;Ralha&nbsp;(2013)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Blocked&nbsp;Schur&nbsp;Algorithms&nbsp;for&nbsp;Computing&nbsp;the&nbsp;Matrix&nbsp;Square&nbsp;Root,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lecture&nbsp;Notes&nbsp;in&nbsp;Computer&nbsp;Science,&nbsp;7782.&nbsp;pp.&nbsp;171-182.<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;sqrtm<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([[1.0,&nbsp;3.0],&nbsp;[1.0,&nbsp;4.0]])<br>
&gt;&gt;&gt;&nbsp;r&nbsp;=&nbsp;<a href="#-sqrtm">sqrtm</a>(a)<br>
&gt;&gt;&gt;&nbsp;r<br>
array([[&nbsp;0.75592895,&nbsp;&nbsp;1.13389342],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.37796447,&nbsp;&nbsp;1.88982237]])<br>
&gt;&gt;&gt;&nbsp;r.dot(r)<br>
array([[&nbsp;1.,&nbsp;&nbsp;3.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;1.,&nbsp;&nbsp;4.]])</tt></dd></dl>
 <dl><dt><a name="-svd"><strong>svd</strong></a>(a, full_matrices<font color="#909090">=True</font>, compute_uv<font color="#909090">=True</font>, overwrite_a<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>, lapack_driver<font color="#909090">='gesdd'</font>)</dt><dd><tt>Singular&nbsp;Value&nbsp;Decomposition.<br>
&nbsp;<br>
Factorizes&nbsp;the&nbsp;matrix&nbsp;a&nbsp;into&nbsp;two&nbsp;unitary&nbsp;matrices&nbsp;U&nbsp;and&nbsp;Vh,&nbsp;and<br>
a&nbsp;1-D&nbsp;array&nbsp;s&nbsp;of&nbsp;singular&nbsp;values&nbsp;(real,&nbsp;non-negative)&nbsp;such&nbsp;that<br>
``a&nbsp;==&nbsp;U*S*Vh``,&nbsp;where&nbsp;S&nbsp;is&nbsp;a&nbsp;suitably&nbsp;shaped&nbsp;matrix&nbsp;of&nbsp;zeros&nbsp;with<br>
main&nbsp;diagonal&nbsp;s.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;to&nbsp;decompose.<br>
full_matrices&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;`U`&nbsp;and&nbsp;`Vh`&nbsp;are&nbsp;of&nbsp;shape&nbsp;``(M,M)``,&nbsp;``(N,N)``.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;False,&nbsp;the&nbsp;shapes&nbsp;are&nbsp;``(M,K)``&nbsp;and&nbsp;``(K,N)``,&nbsp;where<br>
&nbsp;&nbsp;&nbsp;&nbsp;``K&nbsp;=&nbsp;min(M,N)``.<br>
compute_uv&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;compute&nbsp;also&nbsp;`U`&nbsp;and&nbsp;`Vh`&nbsp;in&nbsp;addition&nbsp;to&nbsp;`s`.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Default&nbsp;is&nbsp;True.<br>
overwrite_a&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;overwrite&nbsp;`a`;&nbsp;may&nbsp;improve&nbsp;performance.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Default&nbsp;is&nbsp;False.<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
lapack_driver&nbsp;:&nbsp;{'gesdd',&nbsp;'gesvd'},&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;use&nbsp;the&nbsp;more&nbsp;efficient&nbsp;divide-and-conquer&nbsp;approach<br>
&nbsp;&nbsp;&nbsp;&nbsp;(``'gesdd'``)&nbsp;or&nbsp;general&nbsp;rectangular&nbsp;approach&nbsp;(``'gesvd'``)<br>
&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;compute&nbsp;the&nbsp;SVD.&nbsp;MATLAB&nbsp;and&nbsp;Octave&nbsp;use&nbsp;the&nbsp;``'gesvd'``&nbsp;approach.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Default&nbsp;is&nbsp;``'gesdd'``.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;..&nbsp;versionadded::&nbsp;0.18<br>
&nbsp;<br>
Returns<br>
-------<br>
U&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Unitary&nbsp;matrix&nbsp;having&nbsp;left&nbsp;singular&nbsp;vectors&nbsp;as&nbsp;columns.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Of&nbsp;shape&nbsp;``(M,M)``&nbsp;or&nbsp;``(M,K)``,&nbsp;depending&nbsp;on&nbsp;`full_matrices`.<br>
s&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;singular&nbsp;values,&nbsp;sorted&nbsp;in&nbsp;non-increasing&nbsp;order.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Of&nbsp;shape&nbsp;(K,),&nbsp;with&nbsp;``K&nbsp;=&nbsp;min(M,&nbsp;N)``.<br>
Vh&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Unitary&nbsp;matrix&nbsp;having&nbsp;right&nbsp;singular&nbsp;vectors&nbsp;as&nbsp;rows.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Of&nbsp;shape&nbsp;``(N,N)``&nbsp;or&nbsp;``(K,N)``&nbsp;depending&nbsp;on&nbsp;`full_matrices`.<br>
&nbsp;<br>
For&nbsp;``compute_uv=False``,&nbsp;only&nbsp;`s`&nbsp;is&nbsp;returned.<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;SVD&nbsp;computation&nbsp;does&nbsp;not&nbsp;converge.<br>
&nbsp;<br>
See&nbsp;also<br>
--------<br>
svdvals&nbsp;:&nbsp;Compute&nbsp;singular&nbsp;values&nbsp;of&nbsp;a&nbsp;matrix.<br>
diagsvd&nbsp;:&nbsp;Construct&nbsp;the&nbsp;Sigma&nbsp;matrix,&nbsp;given&nbsp;the&nbsp;vector&nbsp;s.<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy&nbsp;import&nbsp;linalg<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.random.randn(9,&nbsp;6)&nbsp;+&nbsp;1.j*np.random.randn(9,&nbsp;6)<br>
&gt;&gt;&gt;&nbsp;U,&nbsp;s,&nbsp;Vh&nbsp;=&nbsp;linalg.<a href="#-svd">svd</a>(a)<br>
&gt;&gt;&gt;&nbsp;U.shape,&nbsp;Vh.shape,&nbsp;s.shape<br>
((9,&nbsp;9),&nbsp;(6,&nbsp;6),&nbsp;(6,))<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;U,&nbsp;s,&nbsp;Vh&nbsp;=&nbsp;linalg.<a href="#-svd">svd</a>(a,&nbsp;full_matrices=False)<br>
&gt;&gt;&gt;&nbsp;U.shape,&nbsp;Vh.shape,&nbsp;s.shape<br>
((9,&nbsp;6),&nbsp;(6,&nbsp;6),&nbsp;(6,))<br>
&gt;&gt;&gt;&nbsp;S&nbsp;=&nbsp;linalg.<a href="#-diagsvd">diagsvd</a>(s,&nbsp;6,&nbsp;6)<br>
&gt;&gt;&gt;&nbsp;np.allclose(a,&nbsp;np.dot(U,&nbsp;np.dot(S,&nbsp;Vh)))<br>
True<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;s2&nbsp;=&nbsp;linalg.<a href="#-svd">svd</a>(a,&nbsp;compute_uv=False)<br>
&gt;&gt;&gt;&nbsp;np.allclose(s,&nbsp;s2)<br>
True</tt></dd></dl>
 <dl><dt><a name="-svdvals"><strong>svdvals</strong></a>(a, overwrite_a<font color="#909090">=False</font>, check_finite<font color="#909090">=True</font>)</dt><dd><tt>Compute&nbsp;singular&nbsp;values&nbsp;of&nbsp;a&nbsp;matrix.<br>
&nbsp;<br>
Parameters<br>
----------<br>
a&nbsp;:&nbsp;(M,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;to&nbsp;decompose.<br>
overwrite_a&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;overwrite&nbsp;`a`;&nbsp;may&nbsp;improve&nbsp;performance.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Default&nbsp;is&nbsp;False.<br>
check_finite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Whether&nbsp;to&nbsp;check&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;contains&nbsp;only&nbsp;finite&nbsp;numbers.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Disabling&nbsp;may&nbsp;give&nbsp;a&nbsp;performance&nbsp;gain,&nbsp;but&nbsp;may&nbsp;result&nbsp;in&nbsp;problems<br>
&nbsp;&nbsp;&nbsp;&nbsp;(crashes,&nbsp;non-termination)&nbsp;if&nbsp;the&nbsp;inputs&nbsp;do&nbsp;contain&nbsp;infinities&nbsp;or&nbsp;NaNs.<br>
&nbsp;<br>
Returns<br>
-------<br>
s&nbsp;:&nbsp;(min(M,&nbsp;N),)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;singular&nbsp;values,&nbsp;sorted&nbsp;in&nbsp;decreasing&nbsp;order.<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#LinAlgError">LinAlgError</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;SVD&nbsp;computation&nbsp;does&nbsp;not&nbsp;converge.<br>
&nbsp;<br>
Notes<br>
-----<br>
``<a href="#-svdvals">svdvals</a>(a)``&nbsp;only&nbsp;differs&nbsp;from&nbsp;``<a href="#-svd">svd</a>(a,&nbsp;compute_uv=False)``&nbsp;by&nbsp;its<br>
handling&nbsp;of&nbsp;the&nbsp;edge&nbsp;case&nbsp;of&nbsp;empty&nbsp;``a``,&nbsp;where&nbsp;it&nbsp;returns&nbsp;an<br>
empty&nbsp;sequence:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.empty((0,&nbsp;2))<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;svdvals<br>
&gt;&gt;&gt;&nbsp;<a href="#-svdvals">svdvals</a>(a)<br>
array([],&nbsp;dtype=float64)<br>
&nbsp;<br>
See&nbsp;also<br>
--------<br>
svd&nbsp;:&nbsp;Compute&nbsp;the&nbsp;full&nbsp;singular&nbsp;value&nbsp;decomposition&nbsp;of&nbsp;a&nbsp;matrix.<br>
diagsvd&nbsp;:&nbsp;Construct&nbsp;the&nbsp;Sigma&nbsp;matrix,&nbsp;given&nbsp;the&nbsp;vector&nbsp;s.</tt></dd></dl>
 <dl><dt><a name="-tanhm"><strong>tanhm</strong></a>(A)</dt><dd><tt>Compute&nbsp;the&nbsp;hyperbolic&nbsp;matrix&nbsp;tangent.<br>
&nbsp;<br>
This&nbsp;routine&nbsp;uses&nbsp;expm&nbsp;to&nbsp;compute&nbsp;the&nbsp;matrix&nbsp;exponentials.<br>
&nbsp;<br>
Parameters<br>
----------<br>
A&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Input&nbsp;array<br>
&nbsp;<br>
Returns<br>
-------<br>
tanhm&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Hyperbolic&nbsp;matrix&nbsp;tangent&nbsp;of&nbsp;`A`<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;tanhm,&nbsp;sinhm,&nbsp;coshm<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([[1.0,&nbsp;3.0],&nbsp;[1.0,&nbsp;4.0]])<br>
&gt;&gt;&gt;&nbsp;t&nbsp;=&nbsp;<a href="#-tanhm">tanhm</a>(a)<br>
&gt;&gt;&gt;&nbsp;t<br>
array([[&nbsp;0.3428582&nbsp;,&nbsp;&nbsp;0.51987926],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.17329309,&nbsp;&nbsp;0.86273746]])<br>
&nbsp;<br>
Verify&nbsp;<a href="#-tanhm">tanhm</a>(a)&nbsp;=&nbsp;<a href="#-sinhm">sinhm</a>(a).dot(<a href="#-inv">inv</a>(<a href="#-coshm">coshm</a>(a)))<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;s&nbsp;=&nbsp;<a href="#-sinhm">sinhm</a>(a)<br>
&gt;&gt;&gt;&nbsp;c&nbsp;=&nbsp;<a href="#-coshm">coshm</a>(a)<br>
&gt;&gt;&gt;&nbsp;t&nbsp;-&nbsp;s.dot(np.linalg.<a href="#-inv">inv</a>(c))<br>
array([[&nbsp;&nbsp;2.72004641e-15,&nbsp;&nbsp;&nbsp;4.55191440e-15],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0.00000000e+00,&nbsp;&nbsp;-5.55111512e-16]])</tt></dd></dl>
 <dl><dt><a name="-tanm"><strong>tanm</strong></a>(A)</dt><dd><tt>Compute&nbsp;the&nbsp;matrix&nbsp;tangent.<br>
&nbsp;<br>
This&nbsp;routine&nbsp;uses&nbsp;expm&nbsp;to&nbsp;compute&nbsp;the&nbsp;matrix&nbsp;exponentials.<br>
&nbsp;<br>
Parameters<br>
----------<br>
A&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Input&nbsp;array.<br>
&nbsp;<br>
Returns<br>
-------<br>
tanm&nbsp;:&nbsp;(N,&nbsp;N)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;tangent&nbsp;of&nbsp;`A`<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;tanm,&nbsp;sinm,&nbsp;cosm<br>
&gt;&gt;&gt;&nbsp;a&nbsp;=&nbsp;np.array([[1.0,&nbsp;3.0],&nbsp;[1.0,&nbsp;4.0]])<br>
&gt;&gt;&gt;&nbsp;t&nbsp;=&nbsp;<a href="#-tanm">tanm</a>(a)<br>
&gt;&gt;&gt;&nbsp;t<br>
array([[&nbsp;-2.00876993,&nbsp;&nbsp;-8.41880636],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-2.80626879,&nbsp;-10.42757629]])<br>
&nbsp;<br>
Verify&nbsp;<a href="#-tanm">tanm</a>(a)&nbsp;=&nbsp;<a href="#-sinm">sinm</a>(a).dot(<a href="#-inv">inv</a>(<a href="#-cosm">cosm</a>(a)))<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;s&nbsp;=&nbsp;<a href="#-sinm">sinm</a>(a)<br>
&gt;&gt;&gt;&nbsp;c&nbsp;=&nbsp;<a href="#-cosm">cosm</a>(a)<br>
&gt;&gt;&gt;&nbsp;s.dot(np.linalg.<a href="#-inv">inv</a>(c))<br>
array([[&nbsp;-2.00876993,&nbsp;&nbsp;-8.41880636],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-2.80626879,&nbsp;-10.42757629]])</tt></dd></dl>
 <dl><dt><a name="-toeplitz"><strong>toeplitz</strong></a>(c, r<font color="#909090">=None</font>)</dt><dd><tt>Construct&nbsp;a&nbsp;Toeplitz&nbsp;matrix.<br>
&nbsp;<br>
The&nbsp;Toeplitz&nbsp;matrix&nbsp;has&nbsp;constant&nbsp;diagonals,&nbsp;with&nbsp;c&nbsp;as&nbsp;its&nbsp;first&nbsp;column<br>
and&nbsp;r&nbsp;as&nbsp;its&nbsp;first&nbsp;row.&nbsp;&nbsp;If&nbsp;r&nbsp;is&nbsp;not&nbsp;given,&nbsp;``r&nbsp;==&nbsp;conjugate(c)``&nbsp;is<br>
assumed.<br>
&nbsp;<br>
Parameters<br>
----------<br>
c&nbsp;:&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;First&nbsp;column&nbsp;of&nbsp;the&nbsp;matrix.&nbsp;&nbsp;Whatever&nbsp;the&nbsp;actual&nbsp;shape&nbsp;of&nbsp;`c`,&nbsp;it<br>
&nbsp;&nbsp;&nbsp;&nbsp;will&nbsp;be&nbsp;converted&nbsp;to&nbsp;a&nbsp;1-D&nbsp;array.<br>
r&nbsp;:&nbsp;array_like,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;First&nbsp;row&nbsp;of&nbsp;the&nbsp;matrix.&nbsp;If&nbsp;None,&nbsp;``r&nbsp;=&nbsp;conjugate(c)``&nbsp;is&nbsp;assumed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;this&nbsp;case,&nbsp;if&nbsp;c[0]&nbsp;is&nbsp;real,&nbsp;the&nbsp;result&nbsp;is&nbsp;a&nbsp;Hermitian&nbsp;matrix.<br>
&nbsp;&nbsp;&nbsp;&nbsp;r[0]&nbsp;is&nbsp;ignored;&nbsp;the&nbsp;first&nbsp;row&nbsp;of&nbsp;the&nbsp;returned&nbsp;matrix&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;``[c[0],&nbsp;r[1:]]``.&nbsp;&nbsp;Whatever&nbsp;the&nbsp;actual&nbsp;shape&nbsp;of&nbsp;`r`,&nbsp;it&nbsp;will&nbsp;be<br>
&nbsp;&nbsp;&nbsp;&nbsp;converted&nbsp;to&nbsp;a&nbsp;1-D&nbsp;array.<br>
&nbsp;<br>
Returns<br>
-------<br>
A&nbsp;:&nbsp;(len(c),&nbsp;len(r))&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;Toeplitz&nbsp;matrix.&nbsp;Dtype&nbsp;is&nbsp;the&nbsp;same&nbsp;as&nbsp;``(c[0]&nbsp;+&nbsp;r[0]).dtype``.<br>
&nbsp;<br>
See&nbsp;also<br>
--------<br>
circulant&nbsp;:&nbsp;circulant&nbsp;matrix<br>
hankel&nbsp;:&nbsp;Hankel&nbsp;matrix<br>
&nbsp;<br>
Notes<br>
-----<br>
The&nbsp;behavior&nbsp;when&nbsp;`c`&nbsp;or&nbsp;`r`&nbsp;is&nbsp;a&nbsp;scalar,&nbsp;or&nbsp;when&nbsp;`c`&nbsp;is&nbsp;complex&nbsp;and<br>
`r`&nbsp;is&nbsp;None,&nbsp;was&nbsp;changed&nbsp;in&nbsp;version&nbsp;0.8.0.&nbsp;&nbsp;The&nbsp;behavior&nbsp;in&nbsp;previous<br>
versions&nbsp;was&nbsp;undocumented&nbsp;and&nbsp;is&nbsp;no&nbsp;longer&nbsp;supported.<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;toeplitz<br>
&gt;&gt;&gt;&nbsp;<a href="#-toeplitz">toeplitz</a>([1,2,3],&nbsp;[1,4,5,6])<br>
array([[1,&nbsp;4,&nbsp;5,&nbsp;6],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[2,&nbsp;1,&nbsp;4,&nbsp;5],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,&nbsp;2,&nbsp;1,&nbsp;4]])<br>
&gt;&gt;&gt;&nbsp;<a href="#-toeplitz">toeplitz</a>([1.0,&nbsp;2+3j,&nbsp;4-1j])<br>
array([[&nbsp;1.+0.j,&nbsp;&nbsp;2.-3.j,&nbsp;&nbsp;4.+1.j],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;2.+3.j,&nbsp;&nbsp;1.+0.j,&nbsp;&nbsp;2.-3.j],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;4.-1.j,&nbsp;&nbsp;2.+3.j,&nbsp;&nbsp;1.+0.j]])</tt></dd></dl>
 <dl><dt><a name="-tri"><strong>tri</strong></a>(N, M<font color="#909090">=None</font>, k<font color="#909090">=0</font>, dtype<font color="#909090">=None</font>)</dt><dd><tt>Construct&nbsp;(N,&nbsp;M)&nbsp;matrix&nbsp;filled&nbsp;with&nbsp;ones&nbsp;at&nbsp;and&nbsp;below&nbsp;the&nbsp;k-th&nbsp;diagonal.<br>
&nbsp;<br>
The&nbsp;matrix&nbsp;has&nbsp;A[i,j]&nbsp;==&nbsp;1&nbsp;for&nbsp;i&nbsp;&lt;=&nbsp;j&nbsp;+&nbsp;k<br>
&nbsp;<br>
Parameters<br>
----------<br>
N&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;size&nbsp;of&nbsp;the&nbsp;first&nbsp;dimension&nbsp;of&nbsp;the&nbsp;matrix.<br>
M&nbsp;:&nbsp;int&nbsp;or&nbsp;None,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;size&nbsp;of&nbsp;the&nbsp;second&nbsp;dimension&nbsp;of&nbsp;the&nbsp;matrix.&nbsp;If&nbsp;`M`&nbsp;is&nbsp;None,<br>
&nbsp;&nbsp;&nbsp;&nbsp;`M&nbsp;=&nbsp;N`&nbsp;is&nbsp;assumed.<br>
k&nbsp;:&nbsp;int,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Number&nbsp;of&nbsp;subdiagonal&nbsp;below&nbsp;which&nbsp;matrix&nbsp;is&nbsp;filled&nbsp;with&nbsp;ones.<br>
&nbsp;&nbsp;&nbsp;&nbsp;`k`&nbsp;=&nbsp;0&nbsp;is&nbsp;the&nbsp;main&nbsp;diagonal,&nbsp;`k`&nbsp;&lt;&nbsp;0&nbsp;subdiagonal&nbsp;and&nbsp;`k`&nbsp;&gt;&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;superdiagonal.<br>
dtype&nbsp;:&nbsp;dtype,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Data&nbsp;type&nbsp;of&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Returns<br>
-------<br>
tri&nbsp;:&nbsp;(N,&nbsp;M)&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Tri&nbsp;matrix.<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;tri<br>
&gt;&gt;&gt;&nbsp;<a href="#-tri">tri</a>(3,&nbsp;5,&nbsp;2,&nbsp;dtype=int)<br>
array([[1,&nbsp;1,&nbsp;1,&nbsp;0,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1,&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1,&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;1]])<br>
&gt;&gt;&gt;&nbsp;<a href="#-tri">tri</a>(3,&nbsp;5,&nbsp;-1,&nbsp;dtype=int)<br>
array([[0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1,&nbsp;1,&nbsp;0,&nbsp;0,&nbsp;0]])</tt></dd></dl>
 <dl><dt><a name="-tril"><strong>tril</strong></a>(m, k<font color="#909090">=0</font>)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;a&nbsp;matrix&nbsp;with&nbsp;elements&nbsp;above&nbsp;the&nbsp;k-th&nbsp;diagonal&nbsp;zeroed.<br>
&nbsp;<br>
Parameters<br>
----------<br>
m&nbsp;:&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;whose&nbsp;elements&nbsp;to&nbsp;return<br>
k&nbsp;:&nbsp;int,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Diagonal&nbsp;above&nbsp;which&nbsp;to&nbsp;zero&nbsp;elements.<br>
&nbsp;&nbsp;&nbsp;&nbsp;`k`&nbsp;==&nbsp;0&nbsp;is&nbsp;the&nbsp;main&nbsp;diagonal,&nbsp;`k`&nbsp;&lt;&nbsp;0&nbsp;subdiagonal&nbsp;and<br>
&nbsp;&nbsp;&nbsp;&nbsp;`k`&nbsp;&gt;&nbsp;0&nbsp;superdiagonal.<br>
&nbsp;<br>
Returns<br>
-------<br>
tril&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Return&nbsp;is&nbsp;the&nbsp;same&nbsp;shape&nbsp;and&nbsp;type&nbsp;as&nbsp;`m`.<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;tril<br>
&gt;&gt;&gt;&nbsp;<a href="#-tril">tril</a>([[1,2,3],[4,5,6],[7,8,9],[10,11,12]],&nbsp;-1)<br>
array([[&nbsp;0,&nbsp;&nbsp;0,&nbsp;&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;4,&nbsp;&nbsp;0,&nbsp;&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;7,&nbsp;&nbsp;8,&nbsp;&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[10,&nbsp;11,&nbsp;12]])</tt></dd></dl>
 <dl><dt><a name="-triu"><strong>triu</strong></a>(m, k<font color="#909090">=0</font>)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;a&nbsp;matrix&nbsp;with&nbsp;elements&nbsp;below&nbsp;the&nbsp;k-th&nbsp;diagonal&nbsp;zeroed.<br>
&nbsp;<br>
Parameters<br>
----------<br>
m&nbsp;:&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Matrix&nbsp;whose&nbsp;elements&nbsp;to&nbsp;return<br>
k&nbsp;:&nbsp;int,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Diagonal&nbsp;below&nbsp;which&nbsp;to&nbsp;zero&nbsp;elements.<br>
&nbsp;&nbsp;&nbsp;&nbsp;`k`&nbsp;==&nbsp;0&nbsp;is&nbsp;the&nbsp;main&nbsp;diagonal,&nbsp;`k`&nbsp;&lt;&nbsp;0&nbsp;subdiagonal&nbsp;and<br>
&nbsp;&nbsp;&nbsp;&nbsp;`k`&nbsp;&gt;&nbsp;0&nbsp;superdiagonal.<br>
&nbsp;<br>
Returns<br>
-------<br>
triu&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Return&nbsp;matrix&nbsp;with&nbsp;zeroed&nbsp;elements&nbsp;below&nbsp;the&nbsp;k-th&nbsp;diagonal&nbsp;and&nbsp;has<br>
&nbsp;&nbsp;&nbsp;&nbsp;same&nbsp;shape&nbsp;and&nbsp;type&nbsp;as&nbsp;`m`.<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.linalg&nbsp;import&nbsp;triu<br>
&gt;&gt;&gt;&nbsp;<a href="#-triu">triu</a>([[1,2,3],[4,5,6],[7,8,9],[10,11,12]],&nbsp;-1)<br>
array([[&nbsp;1,&nbsp;&nbsp;2,&nbsp;&nbsp;3],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;4,&nbsp;&nbsp;5,&nbsp;&nbsp;6],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0,&nbsp;&nbsp;8,&nbsp;&nbsp;9],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0,&nbsp;&nbsp;0,&nbsp;12]])</tt></dd></dl>
</td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#55aa55">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Data</strong></big></font></td></tr>
    
<tr><td bgcolor="#55aa55"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><strong>__all__</strong> = ['LinAlgError', 'absolute_import', 'basic', 'blas', 'block_diag', 'cho_factor', 'cho_solve', 'cho_solve_banded', 'cholesky', 'cholesky_banded', 'circulant', 'companion', 'coshm', 'cosm', 'cython_blas', 'cython_lapack', 'decomp', 'decomp_cholesky', 'decomp_lu', 'decomp_qr', ...]<br>
<strong>__version__</strong> = '0.4.9'<br>
<strong>__warningregistry__</strong> = {('numpy.dtype size changed, may indicate binary incompatibility. Expected 96, got 88', &lt;type 'exceptions.RuntimeWarning'&gt;, 190): True, ('numpy.ufunc size changed, may indicate binary incompatibility. Expected 192, got 176', &lt;type 'exceptions.RuntimeWarning'&gt;, 190): True}<br>
<strong>absolute_import</strong> = _Feature((2, 5, 0, 'alpha', 1), (3, 0, 0, 'alpha', 0), 16384)<br>
<strong>division</strong> = _Feature((2, 2, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 8192)<br>
<strong>print_function</strong> = _Feature((2, 6, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 65536)</td></tr></table>
</body></html>