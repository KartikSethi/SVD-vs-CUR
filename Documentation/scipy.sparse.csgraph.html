
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: package scipy.sparse.csgraph</title>
<meta charset="utf-8">
</head><body bgcolor="#f0f0f8">

<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="#7799ee">
<td valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial">&nbsp;<br><big><big><strong><a href="scipy.html"><font color="#ffffff">scipy</font></a>.<a href="scipy.sparse.html"><font color="#ffffff">sparse</font></a>.csgraph</strong></big></big></font></td
><td align=right valign=bottom
><font color="#ffffff" face="helvetica, arial"><a href=".">index</a><br><a href="file:/usr/local/lib/python2.7/dist-packages/scipy/sparse/csgraph/__init__.py">/usr/local/lib/python2.7/dist-packages/scipy/sparse/csgraph/__init__.py</a></font></td></tr></table>
    <p><tt>==============================================================<br>
Compressed&nbsp;Sparse&nbsp;Graph&nbsp;Routines&nbsp;(:mod:`scipy.sparse.csgraph`)<br>
==============================================================<br>
&nbsp;<br>
..&nbsp;currentmodule::&nbsp;scipy.sparse.csgraph<br>
&nbsp;<br>
Fast&nbsp;graph&nbsp;algorithms&nbsp;based&nbsp;on&nbsp;sparse&nbsp;matrix&nbsp;representations.<br>
&nbsp;<br>
Contents<br>
========<br>
&nbsp;<br>
..&nbsp;autosummary::<br>
&nbsp;&nbsp;&nbsp;:toctree:&nbsp;generated/<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;connected_components&nbsp;--&nbsp;determine&nbsp;connected&nbsp;components&nbsp;of&nbsp;a&nbsp;graph<br>
&nbsp;&nbsp;&nbsp;laplacian&nbsp;--&nbsp;compute&nbsp;the&nbsp;laplacian&nbsp;of&nbsp;a&nbsp;graph<br>
&nbsp;&nbsp;&nbsp;shortest_path&nbsp;--&nbsp;compute&nbsp;the&nbsp;shortest&nbsp;path&nbsp;between&nbsp;points&nbsp;on&nbsp;a&nbsp;positive&nbsp;graph<br>
&nbsp;&nbsp;&nbsp;dijkstra&nbsp;--&nbsp;use&nbsp;Dijkstra's&nbsp;algorithm&nbsp;for&nbsp;shortest&nbsp;path<br>
&nbsp;&nbsp;&nbsp;floyd_warshall&nbsp;--&nbsp;use&nbsp;the&nbsp;Floyd-Warshall&nbsp;algorithm&nbsp;for&nbsp;shortest&nbsp;path<br>
&nbsp;&nbsp;&nbsp;bellman_ford&nbsp;--&nbsp;use&nbsp;the&nbsp;Bellman-Ford&nbsp;algorithm&nbsp;for&nbsp;shortest&nbsp;path<br>
&nbsp;&nbsp;&nbsp;johnson&nbsp;--&nbsp;use&nbsp;Johnson's&nbsp;algorithm&nbsp;for&nbsp;shortest&nbsp;path<br>
&nbsp;&nbsp;&nbsp;breadth_first_order&nbsp;--&nbsp;compute&nbsp;a&nbsp;breadth-first&nbsp;order&nbsp;of&nbsp;nodes<br>
&nbsp;&nbsp;&nbsp;depth_first_order&nbsp;--&nbsp;compute&nbsp;a&nbsp;depth-first&nbsp;order&nbsp;of&nbsp;nodes<br>
&nbsp;&nbsp;&nbsp;breadth_first_tree&nbsp;--&nbsp;construct&nbsp;the&nbsp;breadth-first&nbsp;tree&nbsp;from&nbsp;a&nbsp;given&nbsp;node<br>
&nbsp;&nbsp;&nbsp;depth_first_tree&nbsp;--&nbsp;construct&nbsp;a&nbsp;depth-first&nbsp;tree&nbsp;from&nbsp;a&nbsp;given&nbsp;node<br>
&nbsp;&nbsp;&nbsp;minimum_spanning_tree&nbsp;--&nbsp;construct&nbsp;the&nbsp;minimum&nbsp;spanning&nbsp;tree&nbsp;of&nbsp;a&nbsp;graph<br>
&nbsp;&nbsp;&nbsp;reverse_cuthill_mckee&nbsp;--&nbsp;compute&nbsp;permutation&nbsp;for&nbsp;reverse&nbsp;Cuthill-McKee&nbsp;ordering<br>
&nbsp;&nbsp;&nbsp;maximum_bipartite_matching&nbsp;--&nbsp;compute&nbsp;permutation&nbsp;to&nbsp;make&nbsp;diagonal&nbsp;zero&nbsp;free<br>
&nbsp;&nbsp;&nbsp;<a href="#NegativeCycleError">NegativeCycleError</a><br>
&nbsp;<br>
..&nbsp;autosummary::<br>
&nbsp;&nbsp;&nbsp;:toctree:&nbsp;generated/<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;construct_dist_matrix<br>
&nbsp;&nbsp;&nbsp;csgraph_from_dense<br>
&nbsp;&nbsp;&nbsp;csgraph_from_masked<br>
&nbsp;&nbsp;&nbsp;csgraph_masked_from_dense<br>
&nbsp;&nbsp;&nbsp;csgraph_to_dense<br>
&nbsp;&nbsp;&nbsp;csgraph_to_masked<br>
&nbsp;&nbsp;&nbsp;reconstruct_path<br>
&nbsp;<br>
Graph&nbsp;Representations<br>
=====================<br>
This&nbsp;module&nbsp;uses&nbsp;graphs&nbsp;which&nbsp;are&nbsp;stored&nbsp;in&nbsp;a&nbsp;matrix&nbsp;format.&nbsp;&nbsp;A<br>
graph&nbsp;with&nbsp;N&nbsp;nodes&nbsp;can&nbsp;be&nbsp;represented&nbsp;by&nbsp;an&nbsp;(N&nbsp;x&nbsp;N)&nbsp;adjacency&nbsp;matrix&nbsp;G.<br>
If&nbsp;there&nbsp;is&nbsp;a&nbsp;connection&nbsp;from&nbsp;node&nbsp;i&nbsp;to&nbsp;node&nbsp;j,&nbsp;then&nbsp;G[i,&nbsp;j]&nbsp;=&nbsp;w,&nbsp;where<br>
w&nbsp;is&nbsp;the&nbsp;weight&nbsp;of&nbsp;the&nbsp;connection.&nbsp;&nbsp;For&nbsp;nodes&nbsp;i&nbsp;and&nbsp;j&nbsp;which&nbsp;are<br>
not&nbsp;connected,&nbsp;the&nbsp;value&nbsp;depends&nbsp;on&nbsp;the&nbsp;representation:<br>
&nbsp;<br>
-&nbsp;for&nbsp;dense&nbsp;array&nbsp;representations,&nbsp;non-edges&nbsp;are&nbsp;represented&nbsp;by<br>
&nbsp;&nbsp;G[i,&nbsp;j]&nbsp;=&nbsp;0,&nbsp;infinity,&nbsp;or&nbsp;NaN.<br>
&nbsp;<br>
-&nbsp;for&nbsp;dense&nbsp;masked&nbsp;representations&nbsp;(of&nbsp;type&nbsp;np.ma.MaskedArray),&nbsp;non-edges<br>
&nbsp;&nbsp;are&nbsp;represented&nbsp;by&nbsp;masked&nbsp;values.&nbsp;&nbsp;This&nbsp;can&nbsp;be&nbsp;useful&nbsp;when&nbsp;graphs&nbsp;with<br>
&nbsp;&nbsp;zero-weight&nbsp;edges&nbsp;are&nbsp;desired.<br>
&nbsp;<br>
-&nbsp;for&nbsp;sparse&nbsp;array&nbsp;representations,&nbsp;non-edges&nbsp;are&nbsp;represented&nbsp;by<br>
&nbsp;&nbsp;non-entries&nbsp;in&nbsp;the&nbsp;matrix.&nbsp;&nbsp;This&nbsp;sort&nbsp;of&nbsp;sparse&nbsp;representation&nbsp;also<br>
&nbsp;&nbsp;allows&nbsp;for&nbsp;edges&nbsp;with&nbsp;zero&nbsp;weights.<br>
&nbsp;<br>
As&nbsp;a&nbsp;concrete&nbsp;example,&nbsp;imagine&nbsp;that&nbsp;you&nbsp;would&nbsp;like&nbsp;to&nbsp;represent&nbsp;the&nbsp;following<br>
undirected&nbsp;graph::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)<br>
&nbsp;<br>
This&nbsp;graph&nbsp;has&nbsp;three&nbsp;nodes,&nbsp;where&nbsp;node&nbsp;0&nbsp;and&nbsp;1&nbsp;are&nbsp;connected&nbsp;by&nbsp;an&nbsp;edge&nbsp;of<br>
weight&nbsp;2,&nbsp;and&nbsp;nodes&nbsp;0&nbsp;and&nbsp;2&nbsp;are&nbsp;connected&nbsp;by&nbsp;an&nbsp;edge&nbsp;of&nbsp;weight&nbsp;1.<br>
We&nbsp;can&nbsp;construct&nbsp;the&nbsp;dense,&nbsp;masked,&nbsp;and&nbsp;sparse&nbsp;representations&nbsp;as&nbsp;follows,<br>
keeping&nbsp;in&nbsp;mind&nbsp;that&nbsp;an&nbsp;undirected&nbsp;graph&nbsp;is&nbsp;represented&nbsp;by&nbsp;a&nbsp;symmetric&nbsp;matrix::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;G_dense&nbsp;=&nbsp;np.array([[0,&nbsp;2,&nbsp;1],<br>
&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[2,&nbsp;0,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1,&nbsp;0,&nbsp;0]])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;G_masked&nbsp;=&nbsp;np.ma.masked_values(G_dense,&nbsp;0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;from&nbsp;scipy.sparse&nbsp;import&nbsp;csr_matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;G_sparse&nbsp;=&nbsp;csr_matrix(G_dense)<br>
&nbsp;<br>
This&nbsp;becomes&nbsp;more&nbsp;difficult&nbsp;when&nbsp;zero&nbsp;edges&nbsp;are&nbsp;significant.&nbsp;&nbsp;For&nbsp;example,<br>
consider&nbsp;the&nbsp;situation&nbsp;when&nbsp;we&nbsp;slightly&nbsp;modify&nbsp;the&nbsp;above&nbsp;graph::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G2<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)<br>
&nbsp;<br>
This&nbsp;is&nbsp;identical&nbsp;to&nbsp;the&nbsp;previous&nbsp;graph,&nbsp;except&nbsp;nodes&nbsp;0&nbsp;and&nbsp;2&nbsp;are&nbsp;connected<br>
by&nbsp;an&nbsp;edge&nbsp;of&nbsp;zero&nbsp;weight.&nbsp;&nbsp;In&nbsp;this&nbsp;case,&nbsp;the&nbsp;dense&nbsp;representation&nbsp;above<br>
leads&nbsp;to&nbsp;ambiguities:&nbsp;how&nbsp;can&nbsp;non-edges&nbsp;be&nbsp;represented&nbsp;if&nbsp;zero&nbsp;is&nbsp;a&nbsp;meaningful<br>
value?&nbsp;&nbsp;In&nbsp;this&nbsp;case,&nbsp;either&nbsp;a&nbsp;masked&nbsp;or&nbsp;sparse&nbsp;representation&nbsp;must&nbsp;be&nbsp;used<br>
to&nbsp;eliminate&nbsp;the&nbsp;ambiguity::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;G2_data&nbsp;=&nbsp;np.array([[np.inf,&nbsp;2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],<br>
&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np.inf,&nbsp;np.inf],<br>
&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;np.inf,&nbsp;np.inf]])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;G2_masked&nbsp;=&nbsp;np.ma.masked_invalid(G2_data)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;from&nbsp;scipy.sparse.csgraph&nbsp;import&nbsp;csgraph_from_dense<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;#&nbsp;G2_sparse&nbsp;=&nbsp;csr_matrix(G2_data)&nbsp;would&nbsp;give&nbsp;the&nbsp;wrong&nbsp;result<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;G2_sparse&nbsp;=&nbsp;<a href="#-csgraph_from_dense">csgraph_from_dense</a>(G2_data,&nbsp;null_value=np.inf)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;G2_sparse.data<br>
&nbsp;&nbsp;&nbsp;&nbsp;array([&nbsp;2.,&nbsp;&nbsp;0.,&nbsp;&nbsp;2.,&nbsp;&nbsp;0.])<br>
&nbsp;<br>
Here&nbsp;we&nbsp;have&nbsp;used&nbsp;a&nbsp;utility&nbsp;routine&nbsp;from&nbsp;the&nbsp;csgraph&nbsp;submodule&nbsp;in&nbsp;order&nbsp;to<br>
convert&nbsp;the&nbsp;dense&nbsp;representation&nbsp;to&nbsp;a&nbsp;sparse&nbsp;representation&nbsp;which&nbsp;can&nbsp;be<br>
understood&nbsp;by&nbsp;the&nbsp;algorithms&nbsp;in&nbsp;submodule.&nbsp;&nbsp;By&nbsp;viewing&nbsp;the&nbsp;data&nbsp;array,&nbsp;we<br>
can&nbsp;see&nbsp;that&nbsp;the&nbsp;zero&nbsp;values&nbsp;are&nbsp;explicitly&nbsp;encoded&nbsp;in&nbsp;the&nbsp;graph.<br>
&nbsp;<br>
Directed&nbsp;vs.&nbsp;Undirected<br>
-----------------------<br>
Matrices&nbsp;may&nbsp;represent&nbsp;either&nbsp;directed&nbsp;or&nbsp;undirected&nbsp;graphs.&nbsp;&nbsp;This&nbsp;is<br>
specified&nbsp;throughout&nbsp;the&nbsp;csgraph&nbsp;module&nbsp;by&nbsp;a&nbsp;boolean&nbsp;keyword.&nbsp;&nbsp;Graphs&nbsp;are<br>
assumed&nbsp;to&nbsp;be&nbsp;directed&nbsp;by&nbsp;default.&nbsp;In&nbsp;a&nbsp;directed&nbsp;graph,&nbsp;traversal&nbsp;from&nbsp;node<br>
i&nbsp;to&nbsp;node&nbsp;j&nbsp;can&nbsp;be&nbsp;accomplished&nbsp;over&nbsp;the&nbsp;edge&nbsp;G[i,&nbsp;j],&nbsp;but&nbsp;not&nbsp;the&nbsp;edge<br>
G[j,&nbsp;i].&nbsp;&nbsp;In&nbsp;a&nbsp;non-directed&nbsp;graph,&nbsp;traversal&nbsp;from&nbsp;node&nbsp;i&nbsp;to&nbsp;node&nbsp;j&nbsp;can&nbsp;be<br>
accomplished&nbsp;over&nbsp;either&nbsp;G[i,&nbsp;j]&nbsp;or&nbsp;G[j,&nbsp;i].&nbsp;&nbsp;If&nbsp;both&nbsp;edges&nbsp;are&nbsp;not&nbsp;null,<br>
and&nbsp;the&nbsp;two&nbsp;have&nbsp;unequal&nbsp;weights,&nbsp;then&nbsp;the&nbsp;smaller&nbsp;of&nbsp;the&nbsp;two&nbsp;is&nbsp;used.<br>
Note&nbsp;that&nbsp;a&nbsp;symmetric&nbsp;matrix&nbsp;will&nbsp;represent&nbsp;an&nbsp;undirected&nbsp;graph,&nbsp;regardless<br>
of&nbsp;whether&nbsp;the&nbsp;'directed'&nbsp;keyword&nbsp;is&nbsp;set&nbsp;to&nbsp;True&nbsp;or&nbsp;False.&nbsp;&nbsp;In&nbsp;this&nbsp;case,<br>
using&nbsp;``directed=True``&nbsp;generally&nbsp;leads&nbsp;to&nbsp;more&nbsp;efficient&nbsp;computation.<br>
&nbsp;<br>
The&nbsp;routines&nbsp;in&nbsp;this&nbsp;module&nbsp;accept&nbsp;as&nbsp;input&nbsp;either&nbsp;scipy.sparse&nbsp;representations<br>
(csr,&nbsp;csc,&nbsp;or&nbsp;lil&nbsp;format),&nbsp;masked&nbsp;representations,&nbsp;or&nbsp;dense&nbsp;representations<br>
with&nbsp;non-edges&nbsp;indicated&nbsp;by&nbsp;zeros,&nbsp;infinities,&nbsp;and&nbsp;NaN&nbsp;entries.</tt></p>
<p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#aa55cc">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Package Contents</strong></big></font></td></tr>
    
<tr><td bgcolor="#aa55cc"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><table width="100%" summary="list"><tr><td width="25%" valign=top><a href="scipy.sparse.csgraph._components.html">_components</a><br>
<a href="scipy.sparse.csgraph._laplacian.html">_laplacian</a><br>
<a href="scipy.sparse.csgraph._min_spanning_tree.html">_min_spanning_tree</a><br>
</td><td width="25%" valign=top><a href="scipy.sparse.csgraph._reordering.html">_reordering</a><br>
<a href="scipy.sparse.csgraph._shortest_path.html">_shortest_path</a><br>
<a href="scipy.sparse.csgraph._tools.html">_tools</a><br>
</td><td width="25%" valign=top><a href="scipy.sparse.csgraph._traversal.html">_traversal</a><br>
<a href="scipy.sparse.csgraph._validation.html">_validation</a><br>
<a href="scipy.sparse.csgraph.setup.html">setup</a><br>
</td><td width="25%" valign=top></td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ee77aa">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Classes</strong></big></font></td></tr>
    
<tr><td bgcolor="#ee77aa"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl>
<dt><font face="helvetica, arial"><a href="exceptions.html#Exception">exceptions.Exception</a>(<a href="exceptions.html#BaseException">exceptions.BaseException</a>)
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="scipy.sparse.csgraph._shortest_path.html#NegativeCycleError">scipy.sparse.csgraph._shortest_path.NegativeCycleError</a>
</font></dt></dl>
</dd>
</dl>
 <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="NegativeCycleError">class <strong>NegativeCycleError</strong></a>(<a href="exceptions.html#Exception">exceptions.Exception</a>)</font></td></tr>
    
<tr><td bgcolor="#ffc8d8"><tt>&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="scipy.sparse.csgraph._shortest_path.html#NegativeCycleError">NegativeCycleError</a></dd>
<dd><a href="exceptions.html#Exception">exceptions.Exception</a></dd>
<dd><a href="exceptions.html#BaseException">exceptions.BaseException</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="NegativeCycleError-__init__"><strong>__init__</strong></a>(...)</dt></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>__qualname__</strong> = 'NegativeCycleError'</dl>

<hr>
Data and other attributes inherited from <a href="exceptions.html#Exception">exceptions.Exception</a>:<br>
<dl><dt><strong>__new__</strong> = &lt;built-in method __new__ of type object&gt;<dd><tt>T.<a href="#NegativeCycleError-__new__">__new__</a>(S,&nbsp;...)&nbsp;-&gt;&nbsp;a&nbsp;new&nbsp;object&nbsp;with&nbsp;type&nbsp;S,&nbsp;a&nbsp;subtype&nbsp;of&nbsp;T</tt></dl>

<hr>
Methods inherited from <a href="exceptions.html#BaseException">exceptions.BaseException</a>:<br>
<dl><dt><a name="NegativeCycleError-__delattr__"><strong>__delattr__</strong></a>(...)</dt><dd><tt>x.<a href="#NegativeCycleError-__delattr__">__delattr__</a>('name')&nbsp;&lt;==&gt;&nbsp;del&nbsp;x.name</tt></dd></dl>

<dl><dt><a name="NegativeCycleError-__getattribute__"><strong>__getattribute__</strong></a>(...)</dt><dd><tt>x.<a href="#NegativeCycleError-__getattribute__">__getattribute__</a>('name')&nbsp;&lt;==&gt;&nbsp;x.name</tt></dd></dl>

<dl><dt><a name="NegativeCycleError-__getitem__"><strong>__getitem__</strong></a>(...)</dt><dd><tt>x.<a href="#NegativeCycleError-__getitem__">__getitem__</a>(y)&nbsp;&lt;==&gt;&nbsp;x[y]</tt></dd></dl>

<dl><dt><a name="NegativeCycleError-__getslice__"><strong>__getslice__</strong></a>(...)</dt><dd><tt>x.<a href="#NegativeCycleError-__getslice__">__getslice__</a>(i,&nbsp;j)&nbsp;&lt;==&gt;&nbsp;x[i:j]<br>
&nbsp;<br>
Use&nbsp;of&nbsp;negative&nbsp;indices&nbsp;is&nbsp;not&nbsp;supported.</tt></dd></dl>

<dl><dt><a name="NegativeCycleError-__reduce__"><strong>__reduce__</strong></a>(...)</dt></dl>

<dl><dt><a name="NegativeCycleError-__repr__"><strong>__repr__</strong></a>(...)</dt><dd><tt>x.<a href="#NegativeCycleError-__repr__">__repr__</a>()&nbsp;&lt;==&gt;&nbsp;repr(x)</tt></dd></dl>

<dl><dt><a name="NegativeCycleError-__setattr__"><strong>__setattr__</strong></a>(...)</dt><dd><tt>x.<a href="#NegativeCycleError-__setattr__">__setattr__</a>('name',&nbsp;value)&nbsp;&lt;==&gt;&nbsp;x.name&nbsp;=&nbsp;value</tt></dd></dl>

<dl><dt><a name="NegativeCycleError-__setstate__"><strong>__setstate__</strong></a>(...)</dt></dl>

<dl><dt><a name="NegativeCycleError-__str__"><strong>__str__</strong></a>(...)</dt><dd><tt>x.<a href="#NegativeCycleError-__str__">__str__</a>()&nbsp;&lt;==&gt;&nbsp;str(x)</tt></dd></dl>

<dl><dt><a name="NegativeCycleError-__unicode__"><strong>__unicode__</strong></a>(...)</dt></dl>

<hr>
Data descriptors inherited from <a href="exceptions.html#BaseException">exceptions.BaseException</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
</dl>
<dl><dt><strong>args</strong></dt>
</dl>
<dl><dt><strong>message</strong></dt>
</dl>
</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#eeaa77">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Functions</strong></big></font></td></tr>
    
<tr><td bgcolor="#eeaa77"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl><dt><a name="-bellman_ford"><strong>bellman_ford</strong></a>(...)</dt><dd><tt><a href="#-bellman_ford">bellman_ford</a>(csgraph,&nbsp;directed=True,&nbsp;indices=None,&nbsp;return_predecessors=False,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unweighted=False)<br>
&nbsp;<br>
Compute&nbsp;the&nbsp;shortest&nbsp;path&nbsp;lengths&nbsp;using&nbsp;the&nbsp;Bellman-Ford&nbsp;algorithm.<br>
&nbsp;<br>
The&nbsp;Bellman-ford&nbsp;algorithm&nbsp;can&nbsp;robustly&nbsp;deal&nbsp;with&nbsp;graphs&nbsp;with&nbsp;negative<br>
weights.&nbsp;&nbsp;If&nbsp;a&nbsp;negative&nbsp;cycle&nbsp;is&nbsp;detected,&nbsp;an&nbsp;error&nbsp;is&nbsp;raised.&nbsp;&nbsp;For<br>
graphs&nbsp;without&nbsp;negative&nbsp;edge&nbsp;weights,&nbsp;dijkstra's&nbsp;algorithm&nbsp;may&nbsp;be&nbsp;faster.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0<br>
&nbsp;<br>
Parameters<br>
----------<br>
csgraph&nbsp;:&nbsp;array,&nbsp;matrix,&nbsp;or&nbsp;sparse&nbsp;matrix,&nbsp;2&nbsp;dimensions<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;array&nbsp;of&nbsp;distances&nbsp;representing&nbsp;the&nbsp;input&nbsp;graph.<br>
directed&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True&nbsp;(default),&nbsp;then&nbsp;find&nbsp;the&nbsp;shortest&nbsp;path&nbsp;on&nbsp;a&nbsp;directed&nbsp;graph:<br>
&nbsp;&nbsp;&nbsp;&nbsp;only&nbsp;move&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j&nbsp;along&nbsp;paths&nbsp;csgraph[i,&nbsp;j].<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;False,&nbsp;then&nbsp;find&nbsp;the&nbsp;shortest&nbsp;path&nbsp;on&nbsp;an&nbsp;undirected&nbsp;graph:&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;algorithm&nbsp;can&nbsp;progress&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;j&nbsp;along&nbsp;csgraph[i,&nbsp;j]&nbsp;or<br>
&nbsp;&nbsp;&nbsp;&nbsp;csgraph[j,&nbsp;i]<br>
indices&nbsp;:&nbsp;array_like&nbsp;or&nbsp;int,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;specified,&nbsp;only&nbsp;compute&nbsp;the&nbsp;paths&nbsp;for&nbsp;the&nbsp;points&nbsp;at&nbsp;the&nbsp;given<br>
&nbsp;&nbsp;&nbsp;&nbsp;indices.<br>
return_predecessors&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;return&nbsp;the&nbsp;size&nbsp;(N,&nbsp;N)&nbsp;predecesor&nbsp;matrix<br>
unweighted&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;then&nbsp;find&nbsp;unweighted&nbsp;distances.&nbsp;&nbsp;That&nbsp;is,&nbsp;rather&nbsp;than&nbsp;finding<br>
&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;path&nbsp;between&nbsp;each&nbsp;point&nbsp;such&nbsp;that&nbsp;the&nbsp;sum&nbsp;of&nbsp;weights&nbsp;is&nbsp;minimized,<br>
&nbsp;&nbsp;&nbsp;&nbsp;find&nbsp;the&nbsp;path&nbsp;such&nbsp;that&nbsp;the&nbsp;number&nbsp;of&nbsp;edges&nbsp;is&nbsp;minimized.<br>
&nbsp;<br>
Returns<br>
-------<br>
dist_matrix&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;matrix&nbsp;of&nbsp;distances&nbsp;between&nbsp;graph&nbsp;nodes.&nbsp;dist_matrix[i,j]<br>
&nbsp;&nbsp;&nbsp;&nbsp;gives&nbsp;the&nbsp;shortest&nbsp;distance&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j&nbsp;along&nbsp;the&nbsp;graph.<br>
&nbsp;<br>
predecessors&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returned&nbsp;only&nbsp;if&nbsp;return_predecessors&nbsp;==&nbsp;True.<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;matrix&nbsp;of&nbsp;predecessors,&nbsp;which&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;reconstruct<br>
&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;shortest&nbsp;paths.&nbsp;&nbsp;Row&nbsp;i&nbsp;of&nbsp;the&nbsp;predecessor&nbsp;matrix&nbsp;contains<br>
&nbsp;&nbsp;&nbsp;&nbsp;information&nbsp;on&nbsp;the&nbsp;shortest&nbsp;paths&nbsp;from&nbsp;point&nbsp;i:&nbsp;each&nbsp;entry<br>
&nbsp;&nbsp;&nbsp;&nbsp;predecessors[i,&nbsp;j]&nbsp;gives&nbsp;the&nbsp;index&nbsp;of&nbsp;the&nbsp;previous&nbsp;node&nbsp;in&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j.&nbsp;&nbsp;If&nbsp;no&nbsp;path&nbsp;exists&nbsp;between&nbsp;point<br>
&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;and&nbsp;j,&nbsp;then&nbsp;predecessors[i,&nbsp;j]&nbsp;=&nbsp;-9999<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#NegativeCycleError">NegativeCycleError</a>:<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;there&nbsp;are&nbsp;negative&nbsp;cycles&nbsp;in&nbsp;the&nbsp;graph<br>
&nbsp;<br>
Notes<br>
-----<br>
This&nbsp;routine&nbsp;is&nbsp;specially&nbsp;designed&nbsp;for&nbsp;graphs&nbsp;with&nbsp;negative&nbsp;edge&nbsp;weights.<br>
If&nbsp;all&nbsp;edge&nbsp;weights&nbsp;are&nbsp;positive,&nbsp;then&nbsp;Dijkstra's&nbsp;algorithm&nbsp;is&nbsp;a&nbsp;better<br>
choice.</tt></dd></dl>
 <dl><dt><a name="-breadth_first_order"><strong>breadth_first_order</strong></a>(...)</dt><dd><tt><a href="#-breadth_first_order">breadth_first_order</a>(csgraph,&nbsp;i_start,&nbsp;directed=True,&nbsp;return_predecessors=True)<br>
&nbsp;<br>
Return&nbsp;a&nbsp;breadth-first&nbsp;ordering&nbsp;starting&nbsp;with&nbsp;specified&nbsp;node.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;a&nbsp;breadth-first&nbsp;order&nbsp;is&nbsp;not&nbsp;unique,&nbsp;but&nbsp;the&nbsp;tree&nbsp;which&nbsp;it<br>
generates&nbsp;is&nbsp;unique.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0<br>
&nbsp;<br>
Parameters<br>
----------<br>
csgraph&nbsp;:&nbsp;array_like&nbsp;or&nbsp;sparse&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;compressed&nbsp;sparse&nbsp;graph.&nbsp;&nbsp;The&nbsp;input&nbsp;csgraph&nbsp;will&nbsp;be<br>
&nbsp;&nbsp;&nbsp;&nbsp;converted&nbsp;to&nbsp;csr&nbsp;format&nbsp;for&nbsp;the&nbsp;calculation.<br>
i_start&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;index&nbsp;of&nbsp;starting&nbsp;node.<br>
directed&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True&nbsp;(default),&nbsp;then&nbsp;operate&nbsp;on&nbsp;a&nbsp;directed&nbsp;graph:&nbsp;only<br>
&nbsp;&nbsp;&nbsp;&nbsp;move&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j&nbsp;along&nbsp;paths&nbsp;csgraph[i,&nbsp;j].<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;False,&nbsp;then&nbsp;find&nbsp;the&nbsp;shortest&nbsp;path&nbsp;on&nbsp;an&nbsp;undirected&nbsp;graph:&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;algorithm&nbsp;can&nbsp;progress&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;j&nbsp;along&nbsp;csgraph[i,&nbsp;j]&nbsp;or<br>
&nbsp;&nbsp;&nbsp;&nbsp;csgraph[j,&nbsp;i].<br>
return_predecessors&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True&nbsp;(default),&nbsp;then&nbsp;return&nbsp;the&nbsp;predecesor&nbsp;array&nbsp;(see&nbsp;below).<br>
&nbsp;<br>
Returns<br>
-------<br>
node_array&nbsp;:&nbsp;ndarray,&nbsp;one&nbsp;dimension<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;breadth-first&nbsp;list&nbsp;of&nbsp;nodes,&nbsp;starting&nbsp;with&nbsp;specified&nbsp;node.&nbsp;&nbsp;The<br>
&nbsp;&nbsp;&nbsp;&nbsp;length&nbsp;of&nbsp;node_array&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes&nbsp;reachable&nbsp;from&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;specified&nbsp;node.<br>
predecessors&nbsp;:&nbsp;ndarray,&nbsp;one&nbsp;dimension<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returned&nbsp;only&nbsp;if&nbsp;return_predecessors&nbsp;is&nbsp;True.<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;length-N&nbsp;list&nbsp;of&nbsp;predecessors&nbsp;of&nbsp;each&nbsp;node&nbsp;in&nbsp;a&nbsp;breadth-first<br>
&nbsp;&nbsp;&nbsp;&nbsp;tree.&nbsp;&nbsp;If&nbsp;node&nbsp;i&nbsp;is&nbsp;in&nbsp;the&nbsp;tree,&nbsp;then&nbsp;its&nbsp;parent&nbsp;is&nbsp;given&nbsp;by<br>
&nbsp;&nbsp;&nbsp;&nbsp;predecessors[i].&nbsp;If&nbsp;node&nbsp;i&nbsp;is&nbsp;not&nbsp;in&nbsp;the&nbsp;tree&nbsp;(and&nbsp;for&nbsp;the&nbsp;parent<br>
&nbsp;&nbsp;&nbsp;&nbsp;node)&nbsp;then&nbsp;predecessors[i]&nbsp;=&nbsp;-9999.</tt></dd></dl>
 <dl><dt><a name="-breadth_first_tree"><strong>breadth_first_tree</strong></a>(...)</dt><dd><tt><a href="#-breadth_first_tree">breadth_first_tree</a>(csgraph,&nbsp;i_start,&nbsp;directed=True)<br>
&nbsp;<br>
Return&nbsp;the&nbsp;tree&nbsp;generated&nbsp;by&nbsp;a&nbsp;breadth-first&nbsp;search<br>
&nbsp;<br>
Note&nbsp;that&nbsp;a&nbsp;breadth-first&nbsp;tree&nbsp;from&nbsp;a&nbsp;specified&nbsp;node&nbsp;is&nbsp;unique.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0<br>
&nbsp;<br>
Parameters<br>
----------<br>
csgraph&nbsp;:&nbsp;array_like&nbsp;or&nbsp;sparse&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;matrix&nbsp;representing&nbsp;the&nbsp;compressed&nbsp;sparse&nbsp;graph.&nbsp;&nbsp;The&nbsp;input<br>
&nbsp;&nbsp;&nbsp;&nbsp;csgraph&nbsp;will&nbsp;be&nbsp;converted&nbsp;to&nbsp;csr&nbsp;format&nbsp;for&nbsp;the&nbsp;calculation.<br>
i_start&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;index&nbsp;of&nbsp;starting&nbsp;node.<br>
directed&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True&nbsp;(default),&nbsp;then&nbsp;operate&nbsp;on&nbsp;a&nbsp;directed&nbsp;graph:&nbsp;only<br>
&nbsp;&nbsp;&nbsp;&nbsp;move&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j&nbsp;along&nbsp;paths&nbsp;csgraph[i,&nbsp;j].<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;False,&nbsp;then&nbsp;find&nbsp;the&nbsp;shortest&nbsp;path&nbsp;on&nbsp;an&nbsp;undirected&nbsp;graph:&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;algorithm&nbsp;can&nbsp;progress&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;j&nbsp;along&nbsp;csgraph[i,&nbsp;j]&nbsp;or<br>
&nbsp;&nbsp;&nbsp;&nbsp;csgraph[j,&nbsp;i].<br>
&nbsp;<br>
Returns<br>
-------<br>
cstree&nbsp;:&nbsp;csr&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;directed&nbsp;compressed-sparse&nbsp;representation&nbsp;of&nbsp;the&nbsp;breadth-<br>
&nbsp;&nbsp;&nbsp;&nbsp;first&nbsp;tree&nbsp;drawn&nbsp;from&nbsp;csgraph,&nbsp;starting&nbsp;at&nbsp;the&nbsp;specified&nbsp;node.<br>
&nbsp;<br>
Examples<br>
--------<br>
The&nbsp;following&nbsp;example&nbsp;shows&nbsp;the&nbsp;computation&nbsp;of&nbsp;a&nbsp;depth-first&nbsp;tree<br>
over&nbsp;a&nbsp;simple&nbsp;four-component&nbsp;graph,&nbsp;starting&nbsp;at&nbsp;node&nbsp;0::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input&nbsp;graph&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;breadth&nbsp;first&nbsp;tree&nbsp;from&nbsp;(0)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>
&nbsp;&nbsp;&nbsp;&nbsp;(3)---5---(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)<br>
&nbsp;<br>
In&nbsp;compressed&nbsp;sparse&nbsp;representation,&nbsp;the&nbsp;solution&nbsp;looks&nbsp;like&nbsp;this:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.sparse&nbsp;import&nbsp;csr_matrix<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.sparse.csgraph&nbsp;import&nbsp;breadth_first_tree<br>
&gt;&gt;&gt;&nbsp;X&nbsp;=&nbsp;csr_matrix([[0,&nbsp;8,&nbsp;0,&nbsp;3],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;2,&nbsp;5],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;0,&nbsp;6],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;0,&nbsp;0]])<br>
&gt;&gt;&gt;&nbsp;Tcsr&nbsp;=&nbsp;<a href="#-breadth_first_tree">breadth_first_tree</a>(X,&nbsp;0,&nbsp;directed=False)<br>
&gt;&gt;&gt;&nbsp;Tcsr.toarray().astype(int)<br>
array([[0,&nbsp;8,&nbsp;0,&nbsp;3],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;2,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;0,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;0,&nbsp;0]])<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;resulting&nbsp;graph&nbsp;is&nbsp;a&nbsp;Directed&nbsp;Acyclic&nbsp;Graph&nbsp;which&nbsp;spans<br>
the&nbsp;graph.&nbsp;&nbsp;A&nbsp;breadth-first&nbsp;tree&nbsp;from&nbsp;a&nbsp;given&nbsp;node&nbsp;is&nbsp;unique.</tt></dd></dl>
 <dl><dt><a name="-connected_components"><strong>connected_components</strong></a>(...)</dt><dd><tt><a href="#-connected_components">connected_components</a>(csgraph,&nbsp;directed=True,&nbsp;connection='weak',<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return_labels=True)<br>
&nbsp;<br>
Analyze&nbsp;the&nbsp;connected&nbsp;components&nbsp;of&nbsp;a&nbsp;sparse&nbsp;graph<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0<br>
&nbsp;<br>
Parameters<br>
----------<br>
csgraph&nbsp;:&nbsp;array_like&nbsp;or&nbsp;sparse&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;matrix&nbsp;representing&nbsp;the&nbsp;compressed&nbsp;sparse&nbsp;graph.&nbsp;&nbsp;The&nbsp;input<br>
&nbsp;&nbsp;&nbsp;&nbsp;csgraph&nbsp;will&nbsp;be&nbsp;converted&nbsp;to&nbsp;csr&nbsp;format&nbsp;for&nbsp;the&nbsp;calculation.<br>
directed&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True&nbsp;(default),&nbsp;then&nbsp;operate&nbsp;on&nbsp;a&nbsp;directed&nbsp;graph:&nbsp;only<br>
&nbsp;&nbsp;&nbsp;&nbsp;move&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j&nbsp;along&nbsp;paths&nbsp;csgraph[i,&nbsp;j].<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;False,&nbsp;then&nbsp;find&nbsp;the&nbsp;shortest&nbsp;path&nbsp;on&nbsp;an&nbsp;undirected&nbsp;graph:&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;algorithm&nbsp;can&nbsp;progress&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;j&nbsp;along&nbsp;csgraph[i,&nbsp;j]&nbsp;or<br>
&nbsp;&nbsp;&nbsp;&nbsp;csgraph[j,&nbsp;i].<br>
connection&nbsp;:&nbsp;str,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;['weak'|'strong'].&nbsp;&nbsp;For&nbsp;directed&nbsp;graphs,&nbsp;the&nbsp;type&nbsp;of&nbsp;connection&nbsp;to<br>
&nbsp;&nbsp;&nbsp;&nbsp;use.&nbsp;&nbsp;Nodes&nbsp;i&nbsp;and&nbsp;j&nbsp;are&nbsp;strongly&nbsp;connected&nbsp;if&nbsp;a&nbsp;path&nbsp;exists&nbsp;both<br>
&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;i&nbsp;to&nbsp;j&nbsp;and&nbsp;from&nbsp;j&nbsp;to&nbsp;i.&nbsp;&nbsp;Nodes&nbsp;i&nbsp;and&nbsp;j&nbsp;are&nbsp;weakly&nbsp;connected&nbsp;if<br>
&nbsp;&nbsp;&nbsp;&nbsp;only&nbsp;one&nbsp;of&nbsp;these&nbsp;paths&nbsp;exists.&nbsp;&nbsp;If&nbsp;directed&nbsp;==&nbsp;False,&nbsp;this&nbsp;keyword<br>
&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;not&nbsp;referenced.<br>
return_labels&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True&nbsp;(default),&nbsp;then&nbsp;return&nbsp;the&nbsp;labels&nbsp;for&nbsp;each&nbsp;of&nbsp;the&nbsp;connected<br>
&nbsp;&nbsp;&nbsp;&nbsp;components.<br>
&nbsp;<br>
Returns<br>
-------<br>
n_components:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;number&nbsp;of&nbsp;connected&nbsp;components.<br>
labels:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;length-N&nbsp;array&nbsp;of&nbsp;labels&nbsp;of&nbsp;the&nbsp;connected&nbsp;components.<br>
&nbsp;<br>
References<br>
----------<br>
..&nbsp;[1]&nbsp;D.&nbsp;J.&nbsp;Pearce,&nbsp;"An&nbsp;Improved&nbsp;Algorithm&nbsp;for&nbsp;Finding&nbsp;the&nbsp;Strongly<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Connected&nbsp;Components&nbsp;of&nbsp;a&nbsp;Directed&nbsp;Graph",&nbsp;Technical&nbsp;Report,&nbsp;2005</tt></dd></dl>
 <dl><dt><a name="-construct_dist_matrix"><strong>construct_dist_matrix</strong></a>(...)</dt><dd><tt><a href="#-construct_dist_matrix">construct_dist_matrix</a>(graph,&nbsp;predecessors,&nbsp;directed=True,&nbsp;null_value=np.inf)<br>
&nbsp;<br>
Construct&nbsp;distance&nbsp;matrix&nbsp;from&nbsp;a&nbsp;predecessor&nbsp;matrix<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0<br>
&nbsp;<br>
Parameters<br>
----------<br>
graph&nbsp;:&nbsp;array_like&nbsp;or&nbsp;sparse<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;matrix&nbsp;representation&nbsp;of&nbsp;a&nbsp;directed&nbsp;or&nbsp;undirected&nbsp;graph.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;dense,&nbsp;then&nbsp;non-edges&nbsp;are&nbsp;indicated&nbsp;by&nbsp;zeros&nbsp;or&nbsp;infinities.<br>
predecessors&nbsp;:&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;matrix&nbsp;of&nbsp;predecessors&nbsp;of&nbsp;each&nbsp;node&nbsp;(see&nbsp;Notes&nbsp;below).<br>
directed&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True&nbsp;(default),&nbsp;then&nbsp;operate&nbsp;on&nbsp;a&nbsp;directed&nbsp;graph:&nbsp;only&nbsp;move&nbsp;from<br>
&nbsp;&nbsp;&nbsp;&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j&nbsp;along&nbsp;paths&nbsp;csgraph[i,&nbsp;j].<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;False,&nbsp;then&nbsp;operate&nbsp;on&nbsp;an&nbsp;undirected&nbsp;graph:&nbsp;the&nbsp;algorithm&nbsp;can<br>
&nbsp;&nbsp;&nbsp;&nbsp;progress&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;j&nbsp;along&nbsp;csgraph[i,&nbsp;j]&nbsp;or&nbsp;csgraph[j,&nbsp;i].<br>
null_value&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;to&nbsp;use&nbsp;for&nbsp;distances&nbsp;between&nbsp;unconnected&nbsp;nodes.&nbsp;&nbsp;Default&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;np.inf<br>
&nbsp;<br>
Returns<br>
-------<br>
dist_matrix&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;matrix&nbsp;of&nbsp;distances&nbsp;between&nbsp;nodes&nbsp;along&nbsp;the&nbsp;path&nbsp;specified<br>
&nbsp;&nbsp;&nbsp;&nbsp;by&nbsp;the&nbsp;predecessor&nbsp;matrix.&nbsp;&nbsp;If&nbsp;no&nbsp;path&nbsp;exists,&nbsp;the&nbsp;distance&nbsp;is&nbsp;zero.<br>
&nbsp;<br>
Notes<br>
-----<br>
The&nbsp;predecessor&nbsp;matrix&nbsp;is&nbsp;of&nbsp;the&nbsp;form&nbsp;returned&nbsp;by<br>
:func:`graph_shortest_path`.&nbsp;&nbsp;Row&nbsp;i&nbsp;of&nbsp;the&nbsp;predecessor&nbsp;matrix&nbsp;contains<br>
information&nbsp;on&nbsp;the&nbsp;shortest&nbsp;paths&nbsp;from&nbsp;point&nbsp;i:&nbsp;each&nbsp;entry<br>
predecessors[i,&nbsp;j]&nbsp;gives&nbsp;the&nbsp;index&nbsp;of&nbsp;the&nbsp;previous&nbsp;node&nbsp;in&nbsp;the&nbsp;path&nbsp;from<br>
point&nbsp;i&nbsp;to&nbsp;point&nbsp;j.&nbsp;&nbsp;If&nbsp;no&nbsp;path&nbsp;exists&nbsp;between&nbsp;point&nbsp;i&nbsp;and&nbsp;j,&nbsp;then<br>
predecessors[i,&nbsp;j]&nbsp;=&nbsp;-9999</tt></dd></dl>
 <dl><dt><a name="-cs_graph_components"><strong>cs_graph_components</strong></a>(*args, **kwds)</dt><dd><tt>`cs_graph_components`&nbsp;is&nbsp;deprecated!<br>
In&nbsp;the&nbsp;future,&nbsp;use&nbsp;csgraph.connected_components.&nbsp;Note&nbsp;that&nbsp;this&nbsp;new&nbsp;function&nbsp;has&nbsp;a&nbsp;slightly&nbsp;different&nbsp;interface:&nbsp;see&nbsp;the&nbsp;docstring&nbsp;for&nbsp;more&nbsp;information.<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Determine&nbsp;connected&nbsp;components&nbsp;of&nbsp;a&nbsp;graph&nbsp;stored&nbsp;as&nbsp;a&nbsp;compressed<br>
&nbsp;&nbsp;&nbsp;&nbsp;sparse&nbsp;row&nbsp;or&nbsp;column&nbsp;matrix.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;For&nbsp;speed&nbsp;reasons,&nbsp;the&nbsp;symmetry&nbsp;of&nbsp;the&nbsp;matrix&nbsp;x&nbsp;is&nbsp;not&nbsp;checked.&nbsp;A<br>
&nbsp;&nbsp;&nbsp;&nbsp;nonzero&nbsp;at&nbsp;index&nbsp;`(i,&nbsp;j)`&nbsp;means&nbsp;that&nbsp;node&nbsp;`i`&nbsp;is&nbsp;connected&nbsp;to&nbsp;node<br>
&nbsp;&nbsp;&nbsp;&nbsp;`j`&nbsp;by&nbsp;an&nbsp;edge.&nbsp;The&nbsp;number&nbsp;of&nbsp;rows/columns&nbsp;of&nbsp;the&nbsp;matrix&nbsp;thus<br>
&nbsp;&nbsp;&nbsp;&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes&nbsp;in&nbsp;the&nbsp;graph.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Parameters<br>
&nbsp;&nbsp;&nbsp;&nbsp;-----------<br>
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;:&nbsp;array_like&nbsp;or&nbsp;sparse&nbsp;matrix,&nbsp;2&nbsp;dimensions<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;adjacency&nbsp;matrix&nbsp;of&nbsp;the&nbsp;graph.&nbsp;Only&nbsp;the&nbsp;upper&nbsp;triangular&nbsp;part<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;used.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns<br>
&nbsp;&nbsp;&nbsp;&nbsp;--------<br>
&nbsp;&nbsp;&nbsp;&nbsp;n_comp&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;number&nbsp;of&nbsp;connected&nbsp;components.<br>
&nbsp;&nbsp;&nbsp;&nbsp;label&nbsp;:&nbsp;ndarray&nbsp;(ints,&nbsp;1&nbsp;dimension):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;label&nbsp;array&nbsp;of&nbsp;each&nbsp;connected&nbsp;component&nbsp;(-2&nbsp;is&nbsp;used&nbsp;to<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indicate&nbsp;empty&nbsp;rows&nbsp;in&nbsp;the&nbsp;matrix:&nbsp;0&nbsp;everywhere,&nbsp;including<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diagonal).&nbsp;This&nbsp;array&nbsp;has&nbsp;the&nbsp;length&nbsp;of&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.e.&nbsp;one&nbsp;label&nbsp;for&nbsp;each&nbsp;node&nbsp;of&nbsp;the&nbsp;graph.&nbsp;Nodes&nbsp;having&nbsp;the&nbsp;same<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label&nbsp;belong&nbsp;to&nbsp;the&nbsp;same&nbsp;connected&nbsp;component.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Notes<br>
&nbsp;&nbsp;&nbsp;&nbsp;------<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;matrix&nbsp;is&nbsp;assumed&nbsp;to&nbsp;be&nbsp;symmetric&nbsp;and&nbsp;the&nbsp;upper&nbsp;triangular&nbsp;part<br>
&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;the&nbsp;matrix&nbsp;is&nbsp;used.&nbsp;The&nbsp;matrix&nbsp;is&nbsp;converted&nbsp;to&nbsp;a&nbsp;CSR&nbsp;matrix&nbsp;unless<br>
&nbsp;&nbsp;&nbsp;&nbsp;it&nbsp;is&nbsp;already&nbsp;a&nbsp;CSR.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Examples<br>
&nbsp;&nbsp;&nbsp;&nbsp;--------<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;from&nbsp;scipy.sparse.csgraph&nbsp;import&nbsp;connected_components<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;D&nbsp;=&nbsp;np.eye(4)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;D[0,1]&nbsp;=&nbsp;D[1,0]&nbsp;=&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;<a href="#-cs_graph_components">cs_graph_components</a>(D)<br>
&nbsp;&nbsp;&nbsp;&nbsp;(3,&nbsp;array([0,&nbsp;0,&nbsp;1,&nbsp;2]))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;from&nbsp;scipy.sparse&nbsp;import&nbsp;dok_matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&gt;&nbsp;<a href="#-cs_graph_components">cs_graph_components</a>(dok_matrix(D))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(3,&nbsp;array([0,&nbsp;0,&nbsp;1,&nbsp;2]))</tt></dd></dl>
 <dl><dt><a name="-csgraph_from_dense"><strong>csgraph_from_dense</strong></a>(...)</dt><dd><tt><a href="#-csgraph_from_dense">csgraph_from_dense</a>(graph,&nbsp;null_value=0,&nbsp;nan_null=True,&nbsp;infinity_null=True)<br>
&nbsp;<br>
Construct&nbsp;a&nbsp;CSR-format&nbsp;sparse&nbsp;graph&nbsp;from&nbsp;a&nbsp;dense&nbsp;matrix.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0<br>
&nbsp;<br>
Parameters<br>
----------<br>
graph&nbsp;:&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Input&nbsp;graph.&nbsp;&nbsp;Shape&nbsp;should&nbsp;be&nbsp;(n_nodes,&nbsp;n_nodes).<br>
null_value&nbsp;:&nbsp;float&nbsp;or&nbsp;None&nbsp;(optional)<br>
&nbsp;&nbsp;&nbsp;&nbsp;Value&nbsp;that&nbsp;denotes&nbsp;non-edges&nbsp;in&nbsp;the&nbsp;graph.&nbsp;&nbsp;Default&nbsp;is&nbsp;zero.<br>
infinity_null&nbsp;:&nbsp;bool<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True&nbsp;(default),&nbsp;then&nbsp;infinite&nbsp;entries&nbsp;(both&nbsp;positive&nbsp;and&nbsp;negative)<br>
&nbsp;&nbsp;&nbsp;&nbsp;are&nbsp;treated&nbsp;as&nbsp;null&nbsp;edges.<br>
nan_null&nbsp;:&nbsp;bool<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True&nbsp;(default),&nbsp;then&nbsp;NaN&nbsp;entries&nbsp;are&nbsp;treated&nbsp;as&nbsp;non-edges<br>
&nbsp;<br>
Returns<br>
-------<br>
csgraph&nbsp;:&nbsp;csr_matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;Compressed&nbsp;sparse&nbsp;representation&nbsp;of&nbsp;graph,</tt></dd></dl>
 <dl><dt><a name="-csgraph_from_masked"><strong>csgraph_from_masked</strong></a>(...)</dt><dd><tt><a href="#-csgraph_from_masked">csgraph_from_masked</a>(graph)<br>
&nbsp;<br>
Construct&nbsp;a&nbsp;CSR-format&nbsp;graph&nbsp;from&nbsp;a&nbsp;masked&nbsp;array.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0<br>
&nbsp;<br>
Parameters<br>
----------<br>
graph&nbsp;:&nbsp;MaskedArray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Input&nbsp;graph.&nbsp;&nbsp;Shape&nbsp;should&nbsp;be&nbsp;(n_nodes,&nbsp;n_nodes).<br>
&nbsp;<br>
Returns<br>
-------<br>
csgraph&nbsp;:&nbsp;csr_matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;Compressed&nbsp;sparse&nbsp;representation&nbsp;of&nbsp;graph,</tt></dd></dl>
 <dl><dt><a name="-csgraph_masked_from_dense"><strong>csgraph_masked_from_dense</strong></a>(...)</dt><dd><tt><a href="#-csgraph_masked_from_dense">csgraph_masked_from_dense</a>(graph,&nbsp;null_value=0,&nbsp;nan_null=True,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;infinity_null=True,&nbsp;copy=True)<br>
&nbsp;<br>
Construct&nbsp;a&nbsp;masked&nbsp;array&nbsp;graph&nbsp;representation&nbsp;from&nbsp;a&nbsp;dense&nbsp;matrix.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0<br>
&nbsp;<br>
Parameters<br>
----------<br>
graph&nbsp;:&nbsp;array_like<br>
&nbsp;&nbsp;&nbsp;&nbsp;Input&nbsp;graph.&nbsp;&nbsp;Shape&nbsp;should&nbsp;be&nbsp;(n_nodes,&nbsp;n_nodes).<br>
null_value&nbsp;:&nbsp;float&nbsp;or&nbsp;None&nbsp;(optional)<br>
&nbsp;&nbsp;&nbsp;&nbsp;Value&nbsp;that&nbsp;denotes&nbsp;non-edges&nbsp;in&nbsp;the&nbsp;graph.&nbsp;&nbsp;Default&nbsp;is&nbsp;zero.<br>
infinity_null&nbsp;:&nbsp;bool<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True&nbsp;(default),&nbsp;then&nbsp;infinite&nbsp;entries&nbsp;(both&nbsp;positive&nbsp;and&nbsp;negative)<br>
&nbsp;&nbsp;&nbsp;&nbsp;are&nbsp;treated&nbsp;as&nbsp;null&nbsp;edges.<br>
nan_null&nbsp;:&nbsp;bool<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True&nbsp;(default),&nbsp;then&nbsp;NaN&nbsp;entries&nbsp;are&nbsp;treated&nbsp;as&nbsp;non-edges<br>
&nbsp;<br>
Returns<br>
-------<br>
csgraph&nbsp;:&nbsp;MaskedArray<br>
&nbsp;&nbsp;&nbsp;&nbsp;masked&nbsp;array&nbsp;representation&nbsp;of&nbsp;graph</tt></dd></dl>
 <dl><dt><a name="-csgraph_to_dense"><strong>csgraph_to_dense</strong></a>(...)</dt><dd><tt><a href="#-csgraph_to_dense">csgraph_to_dense</a>(csgraph,&nbsp;null_value=0)<br>
&nbsp;<br>
Convert&nbsp;a&nbsp;sparse&nbsp;graph&nbsp;representation&nbsp;to&nbsp;a&nbsp;dense&nbsp;representation<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0<br>
&nbsp;<br>
Parameters<br>
----------<br>
csgraph&nbsp;:&nbsp;csr_matrix,&nbsp;csc_matrix,&nbsp;or&nbsp;lil_matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;Sparse&nbsp;representation&nbsp;of&nbsp;a&nbsp;graph.<br>
null_value&nbsp;:&nbsp;float,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;value&nbsp;used&nbsp;to&nbsp;indicate&nbsp;null&nbsp;edges&nbsp;in&nbsp;the&nbsp;dense&nbsp;representation.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Default&nbsp;is&nbsp;0.<br>
&nbsp;<br>
Returns<br>
-------<br>
graph&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;dense&nbsp;representation&nbsp;of&nbsp;the&nbsp;sparse&nbsp;graph.<br>
&nbsp;<br>
Notes<br>
-----<br>
For&nbsp;normal&nbsp;sparse&nbsp;graph&nbsp;representations,&nbsp;calling&nbsp;csgraph_to_dense&nbsp;with<br>
null_value=0&nbsp;produces&nbsp;an&nbsp;equivalent&nbsp;result&nbsp;to&nbsp;using&nbsp;dense&nbsp;format<br>
conversions&nbsp;in&nbsp;the&nbsp;main&nbsp;sparse&nbsp;package.&nbsp;&nbsp;When&nbsp;the&nbsp;sparse&nbsp;representations<br>
have&nbsp;repeated&nbsp;values,&nbsp;however,&nbsp;the&nbsp;results&nbsp;will&nbsp;differ.&nbsp;&nbsp;The&nbsp;tools&nbsp;in<br>
scipy.sparse&nbsp;will&nbsp;add&nbsp;repeating&nbsp;values&nbsp;to&nbsp;obtain&nbsp;a&nbsp;final&nbsp;value.&nbsp;&nbsp;This<br>
function&nbsp;will&nbsp;select&nbsp;the&nbsp;minimum&nbsp;among&nbsp;repeating&nbsp;values&nbsp;to&nbsp;obtain&nbsp;a<br>
final&nbsp;value.&nbsp;&nbsp;For&nbsp;example,&nbsp;here&nbsp;we'll&nbsp;create&nbsp;a&nbsp;two-node&nbsp;directed&nbsp;sparse<br>
graph&nbsp;with&nbsp;multiple&nbsp;edges&nbsp;from&nbsp;node&nbsp;0&nbsp;to&nbsp;node&nbsp;1,&nbsp;of&nbsp;weights&nbsp;2&nbsp;and&nbsp;3.<br>
This&nbsp;illustrates&nbsp;the&nbsp;difference&nbsp;in&nbsp;behavior:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.sparse&nbsp;import&nbsp;csr_matrix,&nbsp;csgraph<br>
&gt;&gt;&gt;&nbsp;data&nbsp;=&nbsp;np.array([2,&nbsp;3])<br>
&gt;&gt;&gt;&nbsp;indices&nbsp;=&nbsp;np.array([1,&nbsp;1])<br>
&gt;&gt;&gt;&nbsp;indptr&nbsp;=&nbsp;np.array([0,&nbsp;2,&nbsp;2])<br>
&gt;&gt;&gt;&nbsp;M&nbsp;=&nbsp;csr_matrix((data,&nbsp;indices,&nbsp;indptr),&nbsp;shape=(2,&nbsp;2))<br>
&gt;&gt;&gt;&nbsp;M.toarray()<br>
array([[0,&nbsp;5],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0]])<br>
&gt;&gt;&gt;&nbsp;csgraph.<a href="#-csgraph_to_dense">csgraph_to_dense</a>(M)<br>
array([[0.,&nbsp;2.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0.,&nbsp;0.]])<br>
&nbsp;<br>
The&nbsp;reason&nbsp;for&nbsp;this&nbsp;difference&nbsp;is&nbsp;to&nbsp;allow&nbsp;a&nbsp;compressed&nbsp;sparse&nbsp;graph&nbsp;to<br>
represent&nbsp;multiple&nbsp;edges&nbsp;between&nbsp;any&nbsp;two&nbsp;nodes.&nbsp;&nbsp;As&nbsp;most&nbsp;sparse&nbsp;graph<br>
algorithms&nbsp;are&nbsp;concerned&nbsp;with&nbsp;the&nbsp;single&nbsp;lowest-cost&nbsp;edge&nbsp;between&nbsp;any<br>
two&nbsp;nodes,&nbsp;the&nbsp;default&nbsp;scipy.sparse&nbsp;behavior&nbsp;of&nbsp;summming&nbsp;multiple&nbsp;weights<br>
does&nbsp;not&nbsp;make&nbsp;sense&nbsp;in&nbsp;this&nbsp;context.<br>
&nbsp;<br>
The&nbsp;other&nbsp;reason&nbsp;for&nbsp;using&nbsp;this&nbsp;routine&nbsp;is&nbsp;to&nbsp;allow&nbsp;for&nbsp;graphs&nbsp;with<br>
zero-weight&nbsp;edges.&nbsp;&nbsp;Let's&nbsp;look&nbsp;at&nbsp;the&nbsp;example&nbsp;of&nbsp;a&nbsp;two-node&nbsp;directed<br>
graph,&nbsp;connected&nbsp;by&nbsp;an&nbsp;edge&nbsp;of&nbsp;weight&nbsp;zero:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.sparse&nbsp;import&nbsp;csr_matrix,&nbsp;csgraph<br>
&gt;&gt;&gt;&nbsp;data&nbsp;=&nbsp;np.array([0.0])<br>
&gt;&gt;&gt;&nbsp;indices&nbsp;=&nbsp;np.array([1])<br>
&gt;&gt;&gt;&nbsp;indptr&nbsp;=&nbsp;np.array([0,&nbsp;1,&nbsp;1])<br>
&gt;&gt;&gt;&nbsp;M&nbsp;=&nbsp;csr_matrix((data,&nbsp;indices,&nbsp;indptr),&nbsp;shape=(2,&nbsp;2))<br>
&gt;&gt;&gt;&nbsp;M.toarray()<br>
array([[0,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0]])<br>
&gt;&gt;&gt;&nbsp;csgraph.<a href="#-csgraph_to_dense">csgraph_to_dense</a>(M,&nbsp;np.inf)<br>
array([[&nbsp;inf,&nbsp;&nbsp;&nbsp;0.],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;inf,&nbsp;&nbsp;inf]])<br>
&nbsp;<br>
In&nbsp;the&nbsp;first&nbsp;case,&nbsp;the&nbsp;zero-weight&nbsp;edge&nbsp;gets&nbsp;lost&nbsp;in&nbsp;the&nbsp;dense<br>
representation.&nbsp;&nbsp;In&nbsp;the&nbsp;second&nbsp;case,&nbsp;we&nbsp;can&nbsp;choose&nbsp;a&nbsp;different&nbsp;null&nbsp;value<br>
and&nbsp;see&nbsp;the&nbsp;true&nbsp;form&nbsp;of&nbsp;the&nbsp;graph.</tt></dd></dl>
 <dl><dt><a name="-csgraph_to_masked"><strong>csgraph_to_masked</strong></a>(...)</dt><dd><tt><a href="#-csgraph_to_masked">csgraph_to_masked</a>(csgraph)<br>
&nbsp;<br>
Convert&nbsp;a&nbsp;sparse&nbsp;graph&nbsp;representation&nbsp;to&nbsp;a&nbsp;masked&nbsp;array&nbsp;representation<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0<br>
&nbsp;<br>
Parameters<br>
----------<br>
csgraph&nbsp;:&nbsp;csr_matrix,&nbsp;csc_matrix,&nbsp;or&nbsp;lil_matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;Sparse&nbsp;representation&nbsp;of&nbsp;a&nbsp;graph.<br>
&nbsp;<br>
Returns<br>
-------<br>
graph&nbsp;:&nbsp;MaskedArray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;masked&nbsp;dense&nbsp;representation&nbsp;of&nbsp;the&nbsp;sparse&nbsp;graph.</tt></dd></dl>
 <dl><dt><a name="-depth_first_order"><strong>depth_first_order</strong></a>(...)</dt><dd><tt><a href="#-depth_first_order">depth_first_order</a>(csgraph,&nbsp;i_start,&nbsp;directed=True,&nbsp;return_predecessors=True)<br>
&nbsp;<br>
Return&nbsp;a&nbsp;depth-first&nbsp;ordering&nbsp;starting&nbsp;with&nbsp;specified&nbsp;node.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;a&nbsp;depth-first&nbsp;order&nbsp;is&nbsp;not&nbsp;unique.&nbsp;&nbsp;Furthermore,&nbsp;for&nbsp;graphs<br>
with&nbsp;cycles,&nbsp;the&nbsp;tree&nbsp;generated&nbsp;by&nbsp;a&nbsp;depth-first&nbsp;search&nbsp;is&nbsp;not<br>
unique&nbsp;either.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0<br>
&nbsp;<br>
Parameters<br>
----------<br>
csgraph&nbsp;:&nbsp;array_like&nbsp;or&nbsp;sparse&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;compressed&nbsp;sparse&nbsp;graph.&nbsp;&nbsp;The&nbsp;input&nbsp;csgraph&nbsp;will&nbsp;be<br>
&nbsp;&nbsp;&nbsp;&nbsp;converted&nbsp;to&nbsp;csr&nbsp;format&nbsp;for&nbsp;the&nbsp;calculation.<br>
i_start&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;index&nbsp;of&nbsp;starting&nbsp;node.<br>
directed&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True&nbsp;(default),&nbsp;then&nbsp;operate&nbsp;on&nbsp;a&nbsp;directed&nbsp;graph:&nbsp;only<br>
&nbsp;&nbsp;&nbsp;&nbsp;move&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j&nbsp;along&nbsp;paths&nbsp;csgraph[i,&nbsp;j].<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;False,&nbsp;then&nbsp;find&nbsp;the&nbsp;shortest&nbsp;path&nbsp;on&nbsp;an&nbsp;undirected&nbsp;graph:&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;algorithm&nbsp;can&nbsp;progress&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;j&nbsp;along&nbsp;csgraph[i,&nbsp;j]&nbsp;or<br>
&nbsp;&nbsp;&nbsp;&nbsp;csgraph[j,&nbsp;i].<br>
return_predecessors&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True&nbsp;(default),&nbsp;then&nbsp;return&nbsp;the&nbsp;predecesor&nbsp;array&nbsp;(see&nbsp;below).<br>
&nbsp;<br>
Returns<br>
-------<br>
node_array&nbsp;:&nbsp;ndarray,&nbsp;one&nbsp;dimension<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;breadth-first&nbsp;list&nbsp;of&nbsp;nodes,&nbsp;starting&nbsp;with&nbsp;specified&nbsp;node.&nbsp;&nbsp;The<br>
&nbsp;&nbsp;&nbsp;&nbsp;length&nbsp;of&nbsp;node_array&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes&nbsp;reachable&nbsp;from&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;specified&nbsp;node.<br>
predecessors&nbsp;:&nbsp;ndarray,&nbsp;one&nbsp;dimension<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returned&nbsp;only&nbsp;if&nbsp;return_predecessors&nbsp;is&nbsp;True.<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;length-N&nbsp;list&nbsp;of&nbsp;predecessors&nbsp;of&nbsp;each&nbsp;node&nbsp;in&nbsp;a&nbsp;breadth-first<br>
&nbsp;&nbsp;&nbsp;&nbsp;tree.&nbsp;&nbsp;If&nbsp;node&nbsp;i&nbsp;is&nbsp;in&nbsp;the&nbsp;tree,&nbsp;then&nbsp;its&nbsp;parent&nbsp;is&nbsp;given&nbsp;by<br>
&nbsp;&nbsp;&nbsp;&nbsp;predecessors[i].&nbsp;If&nbsp;node&nbsp;i&nbsp;is&nbsp;not&nbsp;in&nbsp;the&nbsp;tree&nbsp;(and&nbsp;for&nbsp;the&nbsp;parent<br>
&nbsp;&nbsp;&nbsp;&nbsp;node)&nbsp;then&nbsp;predecessors[i]&nbsp;=&nbsp;-9999.</tt></dd></dl>
 <dl><dt><a name="-depth_first_tree"><strong>depth_first_tree</strong></a>(...)</dt><dd><tt><a href="#-depth_first_tree">depth_first_tree</a>(csgraph,&nbsp;i_start,&nbsp;directed=True)<br>
&nbsp;<br>
Return&nbsp;a&nbsp;tree&nbsp;generated&nbsp;by&nbsp;a&nbsp;depth-first&nbsp;search.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;a&nbsp;tree&nbsp;generated&nbsp;by&nbsp;a&nbsp;depth-first&nbsp;search&nbsp;is&nbsp;not&nbsp;unique:<br>
it&nbsp;depends&nbsp;on&nbsp;the&nbsp;order&nbsp;that&nbsp;the&nbsp;children&nbsp;of&nbsp;each&nbsp;node&nbsp;are&nbsp;searched.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0<br>
&nbsp;<br>
Parameters<br>
----------<br>
csgraph&nbsp;:&nbsp;array_like&nbsp;or&nbsp;sparse&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;matrix&nbsp;representing&nbsp;the&nbsp;compressed&nbsp;sparse&nbsp;graph.&nbsp;&nbsp;The&nbsp;input<br>
&nbsp;&nbsp;&nbsp;&nbsp;csgraph&nbsp;will&nbsp;be&nbsp;converted&nbsp;to&nbsp;csr&nbsp;format&nbsp;for&nbsp;the&nbsp;calculation.<br>
i_start&nbsp;:&nbsp;int<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;index&nbsp;of&nbsp;starting&nbsp;node.<br>
directed&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True&nbsp;(default),&nbsp;then&nbsp;operate&nbsp;on&nbsp;a&nbsp;directed&nbsp;graph:&nbsp;only<br>
&nbsp;&nbsp;&nbsp;&nbsp;move&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j&nbsp;along&nbsp;paths&nbsp;csgraph[i,&nbsp;j].<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;False,&nbsp;then&nbsp;find&nbsp;the&nbsp;shortest&nbsp;path&nbsp;on&nbsp;an&nbsp;undirected&nbsp;graph:&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;algorithm&nbsp;can&nbsp;progress&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;j&nbsp;along&nbsp;csgraph[i,&nbsp;j]&nbsp;or<br>
&nbsp;&nbsp;&nbsp;&nbsp;csgraph[j,&nbsp;i].<br>
&nbsp;<br>
Returns<br>
-------<br>
cstree&nbsp;:&nbsp;csr&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;directed&nbsp;compressed-sparse&nbsp;representation&nbsp;of&nbsp;the&nbsp;depth-<br>
&nbsp;&nbsp;&nbsp;&nbsp;first&nbsp;tree&nbsp;drawn&nbsp;from&nbsp;csgraph,&nbsp;starting&nbsp;at&nbsp;the&nbsp;specified&nbsp;node.<br>
&nbsp;<br>
Examples<br>
--------<br>
The&nbsp;following&nbsp;example&nbsp;shows&nbsp;the&nbsp;computation&nbsp;of&nbsp;a&nbsp;depth-first&nbsp;tree<br>
over&nbsp;a&nbsp;simple&nbsp;four-component&nbsp;graph,&nbsp;starting&nbsp;at&nbsp;node&nbsp;0::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input&nbsp;graph&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;depth&nbsp;first&nbsp;tree&nbsp;from&nbsp;(0)<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>
&nbsp;&nbsp;&nbsp;&nbsp;(3)---5---(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;&nbsp;/<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)<br>
&nbsp;<br>
In&nbsp;compressed&nbsp;sparse&nbsp;representation,&nbsp;the&nbsp;solution&nbsp;looks&nbsp;like&nbsp;this:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.sparse&nbsp;import&nbsp;csr_matrix<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.sparse.csgraph&nbsp;import&nbsp;depth_first_tree<br>
&gt;&gt;&gt;&nbsp;X&nbsp;=&nbsp;csr_matrix([[0,&nbsp;8,&nbsp;0,&nbsp;3],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;2,&nbsp;5],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;0,&nbsp;6],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;0,&nbsp;0]])<br>
&gt;&gt;&gt;&nbsp;Tcsr&nbsp;=&nbsp;<a href="#-depth_first_tree">depth_first_tree</a>(X,&nbsp;0,&nbsp;directed=False)<br>
&gt;&gt;&gt;&nbsp;Tcsr.toarray().astype(int)<br>
array([[0,&nbsp;8,&nbsp;0,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;2,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;0,&nbsp;6],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;0,&nbsp;0]])<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;resulting&nbsp;graph&nbsp;is&nbsp;a&nbsp;Directed&nbsp;Acyclic&nbsp;Graph&nbsp;which&nbsp;spans<br>
the&nbsp;graph.&nbsp;&nbsp;Unlike&nbsp;a&nbsp;breadth-first&nbsp;tree,&nbsp;a&nbsp;depth-first&nbsp;tree&nbsp;of&nbsp;a&nbsp;given<br>
graph&nbsp;is&nbsp;not&nbsp;unique&nbsp;if&nbsp;the&nbsp;graph&nbsp;contains&nbsp;cycles.&nbsp;&nbsp;If&nbsp;the&nbsp;above&nbsp;solution<br>
had&nbsp;begun&nbsp;with&nbsp;the&nbsp;edge&nbsp;connecting&nbsp;nodes&nbsp;0&nbsp;and&nbsp;3,&nbsp;the&nbsp;result&nbsp;would&nbsp;have<br>
been&nbsp;different.</tt></dd></dl>
 <dl><dt><a name="-dijkstra"><strong>dijkstra</strong></a>(...)</dt><dd><tt><a href="#-dijkstra">dijkstra</a>(csgraph,&nbsp;directed=True,&nbsp;indices=None,&nbsp;return_predecessors=False,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unweighted=False,&nbsp;limit=np.inf)<br>
&nbsp;<br>
Dijkstra&nbsp;algorithm&nbsp;using&nbsp;Fibonacci&nbsp;Heaps<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0<br>
&nbsp;<br>
Parameters<br>
----------<br>
csgraph&nbsp;:&nbsp;array,&nbsp;matrix,&nbsp;or&nbsp;sparse&nbsp;matrix,&nbsp;2&nbsp;dimensions<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;array&nbsp;of&nbsp;non-negative&nbsp;distances&nbsp;representing&nbsp;the&nbsp;input&nbsp;graph.<br>
directed&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True&nbsp;(default),&nbsp;then&nbsp;find&nbsp;the&nbsp;shortest&nbsp;path&nbsp;on&nbsp;a&nbsp;directed&nbsp;graph:<br>
&nbsp;&nbsp;&nbsp;&nbsp;only&nbsp;move&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j&nbsp;along&nbsp;paths&nbsp;csgraph[i,&nbsp;j].<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;False,&nbsp;then&nbsp;find&nbsp;the&nbsp;shortest&nbsp;path&nbsp;on&nbsp;an&nbsp;undirected&nbsp;graph:&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;algorithm&nbsp;can&nbsp;progress&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;j&nbsp;along&nbsp;csgraph[i,&nbsp;j]&nbsp;or<br>
&nbsp;&nbsp;&nbsp;&nbsp;csgraph[j,&nbsp;i]<br>
indices&nbsp;:&nbsp;array_like&nbsp;or&nbsp;int,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;specified,&nbsp;only&nbsp;compute&nbsp;the&nbsp;paths&nbsp;for&nbsp;the&nbsp;points&nbsp;at&nbsp;the&nbsp;given<br>
&nbsp;&nbsp;&nbsp;&nbsp;indices.<br>
return_predecessors&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;return&nbsp;the&nbsp;size&nbsp;(N,&nbsp;N)&nbsp;predecesor&nbsp;matrix<br>
unweighted&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;then&nbsp;find&nbsp;unweighted&nbsp;distances.&nbsp;&nbsp;That&nbsp;is,&nbsp;rather&nbsp;than&nbsp;finding<br>
&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;path&nbsp;between&nbsp;each&nbsp;point&nbsp;such&nbsp;that&nbsp;the&nbsp;sum&nbsp;of&nbsp;weights&nbsp;is&nbsp;minimized,<br>
&nbsp;&nbsp;&nbsp;&nbsp;find&nbsp;the&nbsp;path&nbsp;such&nbsp;that&nbsp;the&nbsp;number&nbsp;of&nbsp;edges&nbsp;is&nbsp;minimized.<br>
limit&nbsp;:&nbsp;float,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;maximum&nbsp;distance&nbsp;to&nbsp;calculate,&nbsp;must&nbsp;be&nbsp;&gt;=&nbsp;0.&nbsp;Using&nbsp;a&nbsp;smaller&nbsp;limit<br>
&nbsp;&nbsp;&nbsp;&nbsp;will&nbsp;decrease&nbsp;computation&nbsp;time&nbsp;by&nbsp;aborting&nbsp;calculations&nbsp;between&nbsp;pairs<br>
&nbsp;&nbsp;&nbsp;&nbsp;that&nbsp;are&nbsp;separated&nbsp;by&nbsp;a&nbsp;distance&nbsp;&gt;&nbsp;limit.&nbsp;For&nbsp;such&nbsp;pairs,&nbsp;the&nbsp;distance<br>
&nbsp;&nbsp;&nbsp;&nbsp;will&nbsp;be&nbsp;equal&nbsp;to&nbsp;np.inf&nbsp;(i.e.,&nbsp;not&nbsp;connected).<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;..&nbsp;versionadded::&nbsp;0.14.0<br>
&nbsp;<br>
Returns<br>
-------<br>
dist_matrix&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;matrix&nbsp;of&nbsp;distances&nbsp;between&nbsp;graph&nbsp;nodes.&nbsp;dist_matrix[i,j]<br>
&nbsp;&nbsp;&nbsp;&nbsp;gives&nbsp;the&nbsp;shortest&nbsp;distance&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j&nbsp;along&nbsp;the&nbsp;graph.<br>
&nbsp;<br>
predecessors&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returned&nbsp;only&nbsp;if&nbsp;return_predecessors&nbsp;==&nbsp;True.<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;matrix&nbsp;of&nbsp;predecessors,&nbsp;which&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;reconstruct<br>
&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;shortest&nbsp;paths.&nbsp;&nbsp;Row&nbsp;i&nbsp;of&nbsp;the&nbsp;predecessor&nbsp;matrix&nbsp;contains<br>
&nbsp;&nbsp;&nbsp;&nbsp;information&nbsp;on&nbsp;the&nbsp;shortest&nbsp;paths&nbsp;from&nbsp;point&nbsp;i:&nbsp;each&nbsp;entry<br>
&nbsp;&nbsp;&nbsp;&nbsp;predecessors[i,&nbsp;j]&nbsp;gives&nbsp;the&nbsp;index&nbsp;of&nbsp;the&nbsp;previous&nbsp;node&nbsp;in&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j.&nbsp;&nbsp;If&nbsp;no&nbsp;path&nbsp;exists&nbsp;between&nbsp;point<br>
&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;and&nbsp;j,&nbsp;then&nbsp;predecessors[i,&nbsp;j]&nbsp;=&nbsp;-9999<br>
&nbsp;<br>
Notes<br>
-----<br>
As&nbsp;currently&nbsp;implemented,&nbsp;Dijkstra's&nbsp;algorithm&nbsp;does&nbsp;not&nbsp;work&nbsp;for<br>
graphs&nbsp;with&nbsp;direction-dependent&nbsp;distances&nbsp;when&nbsp;directed&nbsp;==&nbsp;False.<br>
i.e.,&nbsp;if&nbsp;csgraph[i,j]&nbsp;and&nbsp;csgraph[j,i]&nbsp;are&nbsp;not&nbsp;equal&nbsp;and<br>
both&nbsp;are&nbsp;nonzero,&nbsp;setting&nbsp;directed=False&nbsp;will&nbsp;not&nbsp;yield&nbsp;the&nbsp;correct<br>
result.<br>
&nbsp;<br>
Also,&nbsp;this&nbsp;routine&nbsp;does&nbsp;not&nbsp;work&nbsp;for&nbsp;graphs&nbsp;with&nbsp;negative<br>
distances.&nbsp;&nbsp;Negative&nbsp;distances&nbsp;can&nbsp;lead&nbsp;to&nbsp;infinite&nbsp;cycles&nbsp;that&nbsp;must<br>
be&nbsp;handled&nbsp;by&nbsp;specialized&nbsp;algorithms&nbsp;such&nbsp;as&nbsp;Bellman-Ford's&nbsp;algorithm<br>
or&nbsp;Johnson's&nbsp;algorithm.</tt></dd></dl>
 <dl><dt><a name="-floyd_warshall"><strong>floyd_warshall</strong></a>(...)</dt><dd><tt><a href="#-floyd_warshall">floyd_warshall</a>(csgraph,&nbsp;directed=True,&nbsp;return_predecessors=False,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unweighted=False,&nbsp;overwrite=False)<br>
&nbsp;<br>
Compute&nbsp;the&nbsp;shortest&nbsp;path&nbsp;lengths&nbsp;using&nbsp;the&nbsp;Floyd-Warshall&nbsp;algorithm<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0<br>
&nbsp;<br>
Parameters<br>
----------<br>
csgraph&nbsp;:&nbsp;array,&nbsp;matrix,&nbsp;or&nbsp;sparse&nbsp;matrix,&nbsp;2&nbsp;dimensions<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;array&nbsp;of&nbsp;distances&nbsp;representing&nbsp;the&nbsp;input&nbsp;graph.<br>
directed&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True&nbsp;(default),&nbsp;then&nbsp;find&nbsp;the&nbsp;shortest&nbsp;path&nbsp;on&nbsp;a&nbsp;directed&nbsp;graph:<br>
&nbsp;&nbsp;&nbsp;&nbsp;only&nbsp;move&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j&nbsp;along&nbsp;paths&nbsp;csgraph[i,&nbsp;j].<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;False,&nbsp;then&nbsp;find&nbsp;the&nbsp;shortest&nbsp;path&nbsp;on&nbsp;an&nbsp;undirected&nbsp;graph:&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;algorithm&nbsp;can&nbsp;progress&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;j&nbsp;along&nbsp;csgraph[i,&nbsp;j]&nbsp;or<br>
&nbsp;&nbsp;&nbsp;&nbsp;csgraph[j,&nbsp;i]<br>
return_predecessors&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;return&nbsp;the&nbsp;size&nbsp;(N,&nbsp;N)&nbsp;predecesor&nbsp;matrix<br>
unweighted&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;then&nbsp;find&nbsp;unweighted&nbsp;distances.&nbsp;&nbsp;That&nbsp;is,&nbsp;rather&nbsp;than&nbsp;finding<br>
&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;path&nbsp;between&nbsp;each&nbsp;point&nbsp;such&nbsp;that&nbsp;the&nbsp;sum&nbsp;of&nbsp;weights&nbsp;is&nbsp;minimized,<br>
&nbsp;&nbsp;&nbsp;&nbsp;find&nbsp;the&nbsp;path&nbsp;such&nbsp;that&nbsp;the&nbsp;number&nbsp;of&nbsp;edges&nbsp;is&nbsp;minimized.<br>
overwrite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;overwrite&nbsp;csgraph&nbsp;with&nbsp;the&nbsp;result.&nbsp;&nbsp;This&nbsp;applies&nbsp;only&nbsp;if<br>
&nbsp;&nbsp;&nbsp;&nbsp;csgraph&nbsp;is&nbsp;a&nbsp;dense,&nbsp;c-ordered&nbsp;array&nbsp;with&nbsp;dtype=float64.<br>
&nbsp;<br>
Returns<br>
-------<br>
dist_matrix&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;matrix&nbsp;of&nbsp;distances&nbsp;between&nbsp;graph&nbsp;nodes.&nbsp;dist_matrix[i,j]<br>
&nbsp;&nbsp;&nbsp;&nbsp;gives&nbsp;the&nbsp;shortest&nbsp;distance&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j&nbsp;along&nbsp;the&nbsp;graph.<br>
&nbsp;<br>
predecessors&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returned&nbsp;only&nbsp;if&nbsp;return_predecessors&nbsp;==&nbsp;True.<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;matrix&nbsp;of&nbsp;predecessors,&nbsp;which&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;reconstruct<br>
&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;shortest&nbsp;paths.&nbsp;&nbsp;Row&nbsp;i&nbsp;of&nbsp;the&nbsp;predecessor&nbsp;matrix&nbsp;contains<br>
&nbsp;&nbsp;&nbsp;&nbsp;information&nbsp;on&nbsp;the&nbsp;shortest&nbsp;paths&nbsp;from&nbsp;point&nbsp;i:&nbsp;each&nbsp;entry<br>
&nbsp;&nbsp;&nbsp;&nbsp;predecessors[i,&nbsp;j]&nbsp;gives&nbsp;the&nbsp;index&nbsp;of&nbsp;the&nbsp;previous&nbsp;node&nbsp;in&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j.&nbsp;&nbsp;If&nbsp;no&nbsp;path&nbsp;exists&nbsp;between&nbsp;point<br>
&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;and&nbsp;j,&nbsp;then&nbsp;predecessors[i,&nbsp;j]&nbsp;=&nbsp;-9999<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#NegativeCycleError">NegativeCycleError</a>:<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;there&nbsp;are&nbsp;negative&nbsp;cycles&nbsp;in&nbsp;the&nbsp;graph</tt></dd></dl>
 <dl><dt><a name="-johnson"><strong>johnson</strong></a>(...)</dt><dd><tt><a href="#-johnson">johnson</a>(csgraph,&nbsp;directed=True,&nbsp;indices=None,&nbsp;return_predecessors=False,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unweighted=False)<br>
&nbsp;<br>
Compute&nbsp;the&nbsp;shortest&nbsp;path&nbsp;lengths&nbsp;using&nbsp;Johnson's&nbsp;algorithm.<br>
&nbsp;<br>
Johnson's&nbsp;algorithm&nbsp;combines&nbsp;the&nbsp;Bellman-Ford&nbsp;algorithm&nbsp;and&nbsp;Dijkstra's<br>
algorithm&nbsp;to&nbsp;quickly&nbsp;find&nbsp;shortest&nbsp;paths&nbsp;in&nbsp;a&nbsp;way&nbsp;that&nbsp;is&nbsp;robust&nbsp;to<br>
the&nbsp;presence&nbsp;of&nbsp;negative&nbsp;cycles.&nbsp;&nbsp;If&nbsp;a&nbsp;negative&nbsp;cycle&nbsp;is&nbsp;detected,<br>
an&nbsp;error&nbsp;is&nbsp;raised.&nbsp;&nbsp;For&nbsp;graphs&nbsp;without&nbsp;negative&nbsp;edge&nbsp;weights,<br>
<a href="#-dijkstra">dijkstra</a>()&nbsp;may&nbsp;be&nbsp;faster.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0<br>
&nbsp;<br>
Parameters<br>
----------<br>
csgraph&nbsp;:&nbsp;array,&nbsp;matrix,&nbsp;or&nbsp;sparse&nbsp;matrix,&nbsp;2&nbsp;dimensions<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;array&nbsp;of&nbsp;distances&nbsp;representing&nbsp;the&nbsp;input&nbsp;graph.<br>
directed&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True&nbsp;(default),&nbsp;then&nbsp;find&nbsp;the&nbsp;shortest&nbsp;path&nbsp;on&nbsp;a&nbsp;directed&nbsp;graph:<br>
&nbsp;&nbsp;&nbsp;&nbsp;only&nbsp;move&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j&nbsp;along&nbsp;paths&nbsp;csgraph[i,&nbsp;j].<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;False,&nbsp;then&nbsp;find&nbsp;the&nbsp;shortest&nbsp;path&nbsp;on&nbsp;an&nbsp;undirected&nbsp;graph:&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;algorithm&nbsp;can&nbsp;progress&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;j&nbsp;along&nbsp;csgraph[i,&nbsp;j]&nbsp;or<br>
&nbsp;&nbsp;&nbsp;&nbsp;csgraph[j,&nbsp;i]<br>
indices&nbsp;:&nbsp;array_like&nbsp;or&nbsp;int,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;specified,&nbsp;only&nbsp;compute&nbsp;the&nbsp;paths&nbsp;for&nbsp;the&nbsp;points&nbsp;at&nbsp;the&nbsp;given<br>
&nbsp;&nbsp;&nbsp;&nbsp;indices.<br>
return_predecessors&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;return&nbsp;the&nbsp;size&nbsp;(N,&nbsp;N)&nbsp;predecesor&nbsp;matrix<br>
unweighted&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;then&nbsp;find&nbsp;unweighted&nbsp;distances.&nbsp;&nbsp;That&nbsp;is,&nbsp;rather&nbsp;than&nbsp;finding<br>
&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;path&nbsp;between&nbsp;each&nbsp;point&nbsp;such&nbsp;that&nbsp;the&nbsp;sum&nbsp;of&nbsp;weights&nbsp;is&nbsp;minimized,<br>
&nbsp;&nbsp;&nbsp;&nbsp;find&nbsp;the&nbsp;path&nbsp;such&nbsp;that&nbsp;the&nbsp;number&nbsp;of&nbsp;edges&nbsp;is&nbsp;minimized.<br>
&nbsp;<br>
Returns<br>
-------<br>
dist_matrix&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;matrix&nbsp;of&nbsp;distances&nbsp;between&nbsp;graph&nbsp;nodes.&nbsp;dist_matrix[i,j]<br>
&nbsp;&nbsp;&nbsp;&nbsp;gives&nbsp;the&nbsp;shortest&nbsp;distance&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j&nbsp;along&nbsp;the&nbsp;graph.<br>
&nbsp;<br>
predecessors&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returned&nbsp;only&nbsp;if&nbsp;return_predecessors&nbsp;==&nbsp;True.<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;matrix&nbsp;of&nbsp;predecessors,&nbsp;which&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;reconstruct<br>
&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;shortest&nbsp;paths.&nbsp;&nbsp;Row&nbsp;i&nbsp;of&nbsp;the&nbsp;predecessor&nbsp;matrix&nbsp;contains<br>
&nbsp;&nbsp;&nbsp;&nbsp;information&nbsp;on&nbsp;the&nbsp;shortest&nbsp;paths&nbsp;from&nbsp;point&nbsp;i:&nbsp;each&nbsp;entry<br>
&nbsp;&nbsp;&nbsp;&nbsp;predecessors[i,&nbsp;j]&nbsp;gives&nbsp;the&nbsp;index&nbsp;of&nbsp;the&nbsp;previous&nbsp;node&nbsp;in&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j.&nbsp;&nbsp;If&nbsp;no&nbsp;path&nbsp;exists&nbsp;between&nbsp;point<br>
&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;and&nbsp;j,&nbsp;then&nbsp;predecessors[i,&nbsp;j]&nbsp;=&nbsp;-9999<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#NegativeCycleError">NegativeCycleError</a>:<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;there&nbsp;are&nbsp;negative&nbsp;cycles&nbsp;in&nbsp;the&nbsp;graph<br>
&nbsp;<br>
Notes<br>
-----<br>
This&nbsp;routine&nbsp;is&nbsp;specially&nbsp;designed&nbsp;for&nbsp;graphs&nbsp;with&nbsp;negative&nbsp;edge&nbsp;weights.<br>
If&nbsp;all&nbsp;edge&nbsp;weights&nbsp;are&nbsp;positive,&nbsp;then&nbsp;Dijkstra's&nbsp;algorithm&nbsp;is&nbsp;a&nbsp;better<br>
choice.</tt></dd></dl>
 <dl><dt><a name="-laplacian"><strong>laplacian</strong></a>(csgraph, normed<font color="#909090">=False</font>, return_diag<font color="#909090">=False</font>, use_out_degree<font color="#909090">=False</font>)</dt><dd><tt>Return&nbsp;the&nbsp;Laplacian&nbsp;matrix&nbsp;of&nbsp;a&nbsp;directed&nbsp;graph.<br>
&nbsp;<br>
Parameters<br>
----------<br>
csgraph&nbsp;:&nbsp;array_like&nbsp;or&nbsp;sparse&nbsp;matrix,&nbsp;2&nbsp;dimensions<br>
&nbsp;&nbsp;&nbsp;&nbsp;compressed-sparse&nbsp;graph,&nbsp;with&nbsp;shape&nbsp;(N,&nbsp;N).<br>
normed&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;then&nbsp;compute&nbsp;normalized&nbsp;Laplacian.<br>
return_diag&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;then&nbsp;also&nbsp;return&nbsp;an&nbsp;array&nbsp;related&nbsp;to&nbsp;vertex&nbsp;degrees.<br>
use_out_degree&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;then&nbsp;use&nbsp;out-degree&nbsp;instead&nbsp;of&nbsp;in-degree.<br>
&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;distinction&nbsp;matters&nbsp;only&nbsp;if&nbsp;the&nbsp;graph&nbsp;is&nbsp;asymmetric.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Default:&nbsp;False.<br>
&nbsp;<br>
Returns<br>
-------<br>
lap&nbsp;:&nbsp;ndarray&nbsp;or&nbsp;sparse&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;laplacian&nbsp;matrix&nbsp;of&nbsp;csgraph.&nbsp;It&nbsp;will&nbsp;be&nbsp;a&nbsp;numpy&nbsp;array&nbsp;(dense)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;the&nbsp;input&nbsp;was&nbsp;dense,&nbsp;or&nbsp;a&nbsp;sparse&nbsp;matrix&nbsp;otherwise.<br>
diag&nbsp;:&nbsp;ndarray,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;length-N&nbsp;diagonal&nbsp;of&nbsp;the&nbsp;Laplacian&nbsp;matrix.<br>
&nbsp;&nbsp;&nbsp;&nbsp;For&nbsp;the&nbsp;normalized&nbsp;Laplacian,&nbsp;this&nbsp;is&nbsp;the&nbsp;array&nbsp;of&nbsp;square&nbsp;roots<br>
&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;vertex&nbsp;degrees&nbsp;or&nbsp;1&nbsp;if&nbsp;the&nbsp;degree&nbsp;is&nbsp;zero.<br>
&nbsp;<br>
Notes<br>
-----<br>
The&nbsp;Laplacian&nbsp;matrix&nbsp;of&nbsp;a&nbsp;graph&nbsp;is&nbsp;sometimes&nbsp;referred&nbsp;to&nbsp;as&nbsp;the<br>
"Kirchoff&nbsp;matrix"&nbsp;or&nbsp;the&nbsp;"admittance&nbsp;matrix",&nbsp;and&nbsp;is&nbsp;useful&nbsp;in&nbsp;many<br>
parts&nbsp;of&nbsp;spectral&nbsp;graph&nbsp;theory.&nbsp;&nbsp;In&nbsp;particular,&nbsp;the&nbsp;eigen-decomposition<br>
of&nbsp;the&nbsp;laplacian&nbsp;matrix&nbsp;can&nbsp;give&nbsp;insight&nbsp;into&nbsp;many&nbsp;properties&nbsp;of&nbsp;the&nbsp;graph.<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.sparse&nbsp;import&nbsp;csgraph<br>
&gt;&gt;&gt;&nbsp;G&nbsp;=&nbsp;np.arange(5)&nbsp;*&nbsp;np.arange(5)[:,&nbsp;np.newaxis]<br>
&gt;&gt;&gt;&nbsp;G<br>
array([[&nbsp;0,&nbsp;&nbsp;0,&nbsp;&nbsp;0,&nbsp;&nbsp;0,&nbsp;&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0,&nbsp;&nbsp;1,&nbsp;&nbsp;2,&nbsp;&nbsp;3,&nbsp;&nbsp;4],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0,&nbsp;&nbsp;2,&nbsp;&nbsp;4,&nbsp;&nbsp;6,&nbsp;&nbsp;8],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0,&nbsp;&nbsp;3,&nbsp;&nbsp;6,&nbsp;&nbsp;9,&nbsp;12],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0,&nbsp;&nbsp;4,&nbsp;&nbsp;8,&nbsp;12,&nbsp;16]])<br>
&gt;&gt;&gt;&nbsp;csgraph.<a href="#-laplacian">laplacian</a>(G,&nbsp;normed=False)<br>
array([[&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;9,&nbsp;&nbsp;-2,&nbsp;&nbsp;-3,&nbsp;&nbsp;-4],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0,&nbsp;&nbsp;-2,&nbsp;&nbsp;16,&nbsp;&nbsp;-6,&nbsp;&nbsp;-8],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0,&nbsp;&nbsp;-3,&nbsp;&nbsp;-6,&nbsp;&nbsp;21,&nbsp;-12],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;&nbsp;0,&nbsp;&nbsp;-4,&nbsp;&nbsp;-8,&nbsp;-12,&nbsp;&nbsp;24]])</tt></dd></dl>
 <dl><dt><a name="-maximum_bipartite_matching"><strong>maximum_bipartite_matching</strong></a>(...)</dt><dd><tt>Returns&nbsp;an&nbsp;array&nbsp;of&nbsp;row&nbsp;or&nbsp;column&nbsp;permutations&nbsp;that&nbsp;makes<br>
the&nbsp;diagonal&nbsp;of&nbsp;a&nbsp;nonsingular&nbsp;square&nbsp;CSC&nbsp;sparse&nbsp;matrix&nbsp;zero&nbsp;free.&nbsp;&nbsp;<br>
&nbsp;<br>
Such&nbsp;a&nbsp;permutation&nbsp;is&nbsp;always&nbsp;possible&nbsp;provided&nbsp;that&nbsp;the&nbsp;matrix&nbsp;<br>
is&nbsp;nonsingular.&nbsp;This&nbsp;function&nbsp;looks&nbsp;at&nbsp;the&nbsp;structure&nbsp;of&nbsp;the&nbsp;matrix&nbsp;<br>
only.&nbsp;The&nbsp;input&nbsp;matrix&nbsp;will&nbsp;be&nbsp;converted&nbsp;to&nbsp;CSC&nbsp;matrix&nbsp;format&nbsp;if<br>
necessary.<br>
&nbsp;<br>
Parameters<br>
----------<br>
graph&nbsp;:&nbsp;sparse&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;Input&nbsp;sparse&nbsp;in&nbsp;CSC&nbsp;format<br>
perm_type&nbsp;:&nbsp;str,&nbsp;{'row',&nbsp;'column'}<br>
&nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;of&nbsp;permutation&nbsp;to&nbsp;generate.<br>
&nbsp;<br>
Returns<br>
-------<br>
perm&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Array&nbsp;of&nbsp;row&nbsp;or&nbsp;column&nbsp;permutations.<br>
&nbsp;<br>
Notes<br>
-----<br>
This&nbsp;function&nbsp;relies&nbsp;on&nbsp;a&nbsp;maximum&nbsp;cardinality&nbsp;bipartite&nbsp;matching&nbsp;<br>
algorithm&nbsp;based&nbsp;on&nbsp;a&nbsp;breadth-first&nbsp;search&nbsp;(BFS)&nbsp;of&nbsp;the&nbsp;underlying&nbsp;<br>
graph.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.15.0<br>
&nbsp;<br>
References<br>
----------<br>
I.&nbsp;S.&nbsp;Duff,&nbsp;K.&nbsp;Kaya,&nbsp;and&nbsp;B.&nbsp;Ucar,&nbsp;"Design,&nbsp;Implementation,&nbsp;and&nbsp;<br>
Analysis&nbsp;of&nbsp;Maximum&nbsp;Transversal&nbsp;Algorithms",&nbsp;ACM&nbsp;Trans.&nbsp;Math.&nbsp;Softw.<br>
38,&nbsp;no.&nbsp;2,&nbsp;(2011).</tt></dd></dl>
 <dl><dt><a name="-minimum_spanning_tree"><strong>minimum_spanning_tree</strong></a>(...)</dt><dd><tt><a href="#-minimum_spanning_tree">minimum_spanning_tree</a>(csgraph,&nbsp;overwrite=False)<br>
&nbsp;<br>
Return&nbsp;a&nbsp;minimum&nbsp;spanning&nbsp;tree&nbsp;of&nbsp;an&nbsp;undirected&nbsp;graph<br>
&nbsp;<br>
A&nbsp;minimum&nbsp;spanning&nbsp;tree&nbsp;is&nbsp;a&nbsp;graph&nbsp;consisting&nbsp;of&nbsp;the&nbsp;subset&nbsp;of&nbsp;edges<br>
which&nbsp;together&nbsp;connect&nbsp;all&nbsp;connected&nbsp;nodes,&nbsp;while&nbsp;minimizing&nbsp;the&nbsp;total<br>
sum&nbsp;of&nbsp;weights&nbsp;on&nbsp;the&nbsp;edges.&nbsp;&nbsp;This&nbsp;is&nbsp;computed&nbsp;using&nbsp;the&nbsp;Kruskal&nbsp;algorithm.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0<br>
&nbsp;<br>
Parameters<br>
----------<br>
csgraph&nbsp;:&nbsp;array_like&nbsp;or&nbsp;sparse&nbsp;matrix,&nbsp;2&nbsp;dimensions<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;matrix&nbsp;representing&nbsp;an&nbsp;undirected&nbsp;graph&nbsp;over&nbsp;N&nbsp;nodes<br>
&nbsp;&nbsp;&nbsp;&nbsp;(see&nbsp;notes&nbsp;below).<br>
overwrite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;true,&nbsp;then&nbsp;parts&nbsp;of&nbsp;the&nbsp;input&nbsp;graph&nbsp;will&nbsp;be&nbsp;overwritten&nbsp;for<br>
&nbsp;&nbsp;&nbsp;&nbsp;efficiency.<br>
&nbsp;<br>
Returns<br>
-------<br>
span_tree&nbsp;:&nbsp;csr&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;compressed-sparse&nbsp;representation&nbsp;of&nbsp;the&nbsp;undirected&nbsp;minimum<br>
&nbsp;&nbsp;&nbsp;&nbsp;spanning&nbsp;tree&nbsp;over&nbsp;the&nbsp;input&nbsp;(see&nbsp;notes&nbsp;below).<br>
&nbsp;<br>
Notes<br>
-----<br>
This&nbsp;routine&nbsp;uses&nbsp;undirected&nbsp;graphs&nbsp;as&nbsp;input&nbsp;and&nbsp;output.&nbsp;&nbsp;That&nbsp;is,&nbsp;if<br>
graph[i,&nbsp;j]&nbsp;and&nbsp;graph[j,&nbsp;i]&nbsp;are&nbsp;both&nbsp;zero,&nbsp;then&nbsp;nodes&nbsp;i&nbsp;and&nbsp;j&nbsp;do&nbsp;not<br>
have&nbsp;an&nbsp;edge&nbsp;connecting&nbsp;them.&nbsp;&nbsp;If&nbsp;either&nbsp;is&nbsp;nonzero,&nbsp;then&nbsp;the&nbsp;two&nbsp;are<br>
connected&nbsp;by&nbsp;the&nbsp;minimum&nbsp;nonzero&nbsp;value&nbsp;of&nbsp;the&nbsp;two.<br>
&nbsp;<br>
Examples<br>
--------<br>
The&nbsp;following&nbsp;example&nbsp;shows&nbsp;the&nbsp;computation&nbsp;of&nbsp;a&nbsp;minimum&nbsp;spanning&nbsp;tree<br>
over&nbsp;a&nbsp;simple&nbsp;four-component&nbsp;graph::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input&nbsp;graph&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minimum&nbsp;spanning&nbsp;tree<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/<br>
&nbsp;&nbsp;&nbsp;&nbsp;(3)---5---(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3)---5---(1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)<br>
&nbsp;<br>
It&nbsp;is&nbsp;easy&nbsp;to&nbsp;see&nbsp;from&nbsp;inspection&nbsp;that&nbsp;the&nbsp;minimum&nbsp;spanning&nbsp;tree&nbsp;involves<br>
removing&nbsp;the&nbsp;edges&nbsp;with&nbsp;weights&nbsp;8&nbsp;and&nbsp;6.&nbsp;&nbsp;In&nbsp;compressed&nbsp;sparse<br>
representation,&nbsp;the&nbsp;solution&nbsp;looks&nbsp;like&nbsp;this:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.sparse&nbsp;import&nbsp;csr_matrix<br>
&gt;&gt;&gt;&nbsp;from&nbsp;scipy.sparse.csgraph&nbsp;import&nbsp;minimum_spanning_tree<br>
&gt;&gt;&gt;&nbsp;X&nbsp;=&nbsp;csr_matrix([[0,&nbsp;8,&nbsp;0,&nbsp;3],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;2,&nbsp;5],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;0,&nbsp;6],<br>
...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;0,&nbsp;0]])<br>
&gt;&gt;&gt;&nbsp;Tcsr&nbsp;=&nbsp;<a href="#-minimum_spanning_tree">minimum_spanning_tree</a>(X)<br>
&gt;&gt;&gt;&nbsp;Tcsr.toarray().astype(int)<br>
array([[0,&nbsp;0,&nbsp;0,&nbsp;3],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;2,&nbsp;5],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;0,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;0,&nbsp;0,&nbsp;0]])</tt></dd></dl>
 <dl><dt><a name="-reconstruct_path"><strong>reconstruct_path</strong></a>(...)</dt><dd><tt><a href="#-reconstruct_path">reconstruct_path</a>(csgraph,&nbsp;predecessors,&nbsp;directed=True)<br>
&nbsp;<br>
Construct&nbsp;a&nbsp;tree&nbsp;from&nbsp;a&nbsp;graph&nbsp;and&nbsp;a&nbsp;predecessor&nbsp;list.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0<br>
&nbsp;<br>
Parameters<br>
----------<br>
csgraph&nbsp;:&nbsp;array_like&nbsp;or&nbsp;sparse&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;matrix&nbsp;representing&nbsp;the&nbsp;directed&nbsp;or&nbsp;undirected&nbsp;graph<br>
&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;which&nbsp;the&nbsp;predecessors&nbsp;are&nbsp;drawn.<br>
predecessors&nbsp;:&nbsp;array_like,&nbsp;one&nbsp;dimension<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;length-N&nbsp;array&nbsp;of&nbsp;indices&nbsp;of&nbsp;predecessors&nbsp;for&nbsp;the&nbsp;tree.&nbsp;&nbsp;The<br>
&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;of&nbsp;the&nbsp;parent&nbsp;of&nbsp;node&nbsp;i&nbsp;is&nbsp;given&nbsp;by&nbsp;predecessors[i].<br>
directed&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True&nbsp;(default),&nbsp;then&nbsp;operate&nbsp;on&nbsp;a&nbsp;directed&nbsp;graph:&nbsp;only&nbsp;move&nbsp;from<br>
&nbsp;&nbsp;&nbsp;&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j&nbsp;along&nbsp;paths&nbsp;csgraph[i,&nbsp;j].<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;False,&nbsp;then&nbsp;operate&nbsp;on&nbsp;an&nbsp;undirected&nbsp;graph:&nbsp;the&nbsp;algorithm&nbsp;can<br>
&nbsp;&nbsp;&nbsp;&nbsp;progress&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;j&nbsp;along&nbsp;csgraph[i,&nbsp;j]&nbsp;or&nbsp;csgraph[j,&nbsp;i].<br>
&nbsp;<br>
Returns<br>
-------<br>
cstree&nbsp;:&nbsp;csr&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;directed&nbsp;compressed-sparse&nbsp;representation&nbsp;of&nbsp;the&nbsp;tree&nbsp;drawn<br>
&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;csgraph&nbsp;which&nbsp;is&nbsp;encoded&nbsp;by&nbsp;the&nbsp;predecessor&nbsp;list.</tt></dd></dl>
 <dl><dt><a name="-reverse_cuthill_mckee"><strong>reverse_cuthill_mckee</strong></a>(...)</dt><dd><tt>Returns&nbsp;the&nbsp;permutation&nbsp;array&nbsp;that&nbsp;orders&nbsp;a&nbsp;sparse&nbsp;CSR&nbsp;or&nbsp;CSC&nbsp;matrix<br>
in&nbsp;Reverse-Cuthill&nbsp;McKee&nbsp;ordering.&nbsp;&nbsp;<br>
&nbsp;<br>
It&nbsp;is&nbsp;assumed&nbsp;by&nbsp;default,&nbsp;``symmetric_mode=False``,&nbsp;that&nbsp;the&nbsp;input&nbsp;matrix&nbsp;<br>
is&nbsp;not&nbsp;symmetric&nbsp;and&nbsp;works&nbsp;on&nbsp;the&nbsp;matrix&nbsp;``A+A.T``.&nbsp;If&nbsp;you&nbsp;are&nbsp;<br>
guaranteed&nbsp;that&nbsp;the&nbsp;matrix&nbsp;is&nbsp;symmetric&nbsp;in&nbsp;structure&nbsp;(values&nbsp;of&nbsp;matrix&nbsp;<br>
elements&nbsp;do&nbsp;not&nbsp;matter)&nbsp;then&nbsp;set&nbsp;``symmetric_mode=True``.<br>
&nbsp;<br>
Parameters<br>
----------<br>
graph&nbsp;:&nbsp;sparse&nbsp;matrix<br>
&nbsp;&nbsp;&nbsp;&nbsp;Input&nbsp;sparse&nbsp;in&nbsp;CSC&nbsp;or&nbsp;CSR&nbsp;sparse&nbsp;matrix&nbsp;format.<br>
symmetric_mode&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Is&nbsp;input&nbsp;matrix&nbsp;guaranteed&nbsp;to&nbsp;be&nbsp;symmetric.<br>
&nbsp;<br>
Returns<br>
-------<br>
perm&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Array&nbsp;of&nbsp;permuted&nbsp;row&nbsp;and&nbsp;column&nbsp;indices.<br>
&nbsp;<br>
Notes<br>
-----<br>
..&nbsp;versionadded::&nbsp;0.15.0<br>
&nbsp;<br>
References<br>
----------<br>
E.&nbsp;Cuthill&nbsp;and&nbsp;J.&nbsp;McKee,&nbsp;"Reducing&nbsp;the&nbsp;Bandwidth&nbsp;of&nbsp;Sparse&nbsp;Symmetric&nbsp;Matrices",<br>
ACM&nbsp;'69&nbsp;Proceedings&nbsp;of&nbsp;the&nbsp;1969&nbsp;24th&nbsp;national&nbsp;conference,&nbsp;(1969).</tt></dd></dl>
 <dl><dt><a name="-shortest_path"><strong>shortest_path</strong></a>(...)</dt><dd><tt><a href="#-shortest_path">shortest_path</a>(csgraph,&nbsp;method='auto',&nbsp;directed=True,&nbsp;return_predecessors=False,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unweighted=False,&nbsp;overwrite=False,&nbsp;indices=None)<br>
&nbsp;<br>
Perform&nbsp;a&nbsp;shortest-path&nbsp;graph&nbsp;search&nbsp;on&nbsp;a&nbsp;positive&nbsp;directed&nbsp;or<br>
undirected&nbsp;graph.<br>
&nbsp;<br>
..&nbsp;versionadded::&nbsp;0.11.0<br>
&nbsp;<br>
Parameters<br>
----------<br>
csgraph&nbsp;:&nbsp;array,&nbsp;matrix,&nbsp;or&nbsp;sparse&nbsp;matrix,&nbsp;2&nbsp;dimensions<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;array&nbsp;of&nbsp;distances&nbsp;representing&nbsp;the&nbsp;input&nbsp;graph.<br>
method&nbsp;:&nbsp;string&nbsp;['auto'|'FW'|'D'],&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;Algorithm&nbsp;to&nbsp;use&nbsp;for&nbsp;shortest&nbsp;paths.&nbsp;&nbsp;Options&nbsp;are:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'auto'&nbsp;--&nbsp;(default)&nbsp;select&nbsp;the&nbsp;best&nbsp;among&nbsp;'FW',&nbsp;'D',&nbsp;'BF',&nbsp;or&nbsp;'J'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;based&nbsp;on&nbsp;the&nbsp;input&nbsp;data.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'FW'&nbsp;&nbsp;&nbsp;--&nbsp;Floyd-Warshall&nbsp;algorithm.&nbsp;&nbsp;Computational&nbsp;cost&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;approximately&nbsp;``O[N^3]``.&nbsp;&nbsp;The&nbsp;input&nbsp;csgraph&nbsp;will&nbsp;be<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;converted&nbsp;to&nbsp;a&nbsp;dense&nbsp;representation.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'D'&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;Dijkstra's&nbsp;algorithm&nbsp;with&nbsp;Fibonacci&nbsp;heaps.&nbsp;&nbsp;Computational<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cost&nbsp;is&nbsp;approximately&nbsp;``O[N(N*k&nbsp;+&nbsp;N*log(N))]``,&nbsp;where<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;``k``&nbsp;is&nbsp;the&nbsp;average&nbsp;number&nbsp;of&nbsp;connected&nbsp;edges&nbsp;per&nbsp;node.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;input&nbsp;csgraph&nbsp;will&nbsp;be&nbsp;converted&nbsp;to&nbsp;a&nbsp;csr<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;representation.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'BF'&nbsp;&nbsp;&nbsp;--&nbsp;Bellman-Ford&nbsp;algorithm.&nbsp;&nbsp;This&nbsp;algorithm&nbsp;can&nbsp;be&nbsp;used&nbsp;when<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weights&nbsp;are&nbsp;negative.&nbsp;&nbsp;If&nbsp;a&nbsp;negative&nbsp;cycle&nbsp;is&nbsp;encountered,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;an&nbsp;error&nbsp;will&nbsp;be&nbsp;raised.&nbsp;&nbsp;Computational&nbsp;cost&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;approximately&nbsp;``O[N(N^2&nbsp;k)]``,&nbsp;where&nbsp;``k``&nbsp;is&nbsp;the&nbsp;average<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number&nbsp;of&nbsp;connected&nbsp;edges&nbsp;per&nbsp;node.&nbsp;The&nbsp;input&nbsp;csgraph&nbsp;will<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;be&nbsp;converted&nbsp;to&nbsp;a&nbsp;csr&nbsp;representation.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'J'&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;Johnson's&nbsp;algorithm.&nbsp;&nbsp;Like&nbsp;the&nbsp;Bellman-Ford&nbsp;algorithm,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Johnson's&nbsp;algorithm&nbsp;is&nbsp;designed&nbsp;for&nbsp;use&nbsp;when&nbsp;the&nbsp;weights<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are&nbsp;negative.&nbsp;&nbsp;It&nbsp;combines&nbsp;the&nbsp;Bellman-Ford&nbsp;algorithm<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;Dijkstra's&nbsp;algorithm&nbsp;for&nbsp;faster&nbsp;computation.<br>
&nbsp;<br>
directed&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True&nbsp;(default),&nbsp;then&nbsp;find&nbsp;the&nbsp;shortest&nbsp;path&nbsp;on&nbsp;a&nbsp;directed&nbsp;graph:<br>
&nbsp;&nbsp;&nbsp;&nbsp;only&nbsp;move&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j&nbsp;along&nbsp;paths&nbsp;csgraph[i,&nbsp;j].<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;False,&nbsp;then&nbsp;find&nbsp;the&nbsp;shortest&nbsp;path&nbsp;on&nbsp;an&nbsp;undirected&nbsp;graph:&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;algorithm&nbsp;can&nbsp;progress&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;j&nbsp;along&nbsp;csgraph[i,&nbsp;j]&nbsp;or<br>
&nbsp;&nbsp;&nbsp;&nbsp;csgraph[j,&nbsp;i]<br>
return_predecessors&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;return&nbsp;the&nbsp;size&nbsp;(N,&nbsp;N)&nbsp;predecesor&nbsp;matrix<br>
unweighted&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;then&nbsp;find&nbsp;unweighted&nbsp;distances.&nbsp;&nbsp;That&nbsp;is,&nbsp;rather&nbsp;than&nbsp;finding<br>
&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;path&nbsp;between&nbsp;each&nbsp;point&nbsp;such&nbsp;that&nbsp;the&nbsp;sum&nbsp;of&nbsp;weights&nbsp;is&nbsp;minimized,<br>
&nbsp;&nbsp;&nbsp;&nbsp;find&nbsp;the&nbsp;path&nbsp;such&nbsp;that&nbsp;the&nbsp;number&nbsp;of&nbsp;edges&nbsp;is&nbsp;minimized.<br>
overwrite&nbsp;:&nbsp;bool,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;True,&nbsp;overwrite&nbsp;csgraph&nbsp;with&nbsp;the&nbsp;result.&nbsp;&nbsp;This&nbsp;applies&nbsp;only&nbsp;if<br>
&nbsp;&nbsp;&nbsp;&nbsp;method&nbsp;==&nbsp;'FW'&nbsp;and&nbsp;csgraph&nbsp;is&nbsp;a&nbsp;dense,&nbsp;c-ordered&nbsp;array&nbsp;with<br>
&nbsp;&nbsp;&nbsp;&nbsp;dtype=float64.<br>
indices&nbsp;:&nbsp;array_like&nbsp;or&nbsp;int,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;specified,&nbsp;only&nbsp;compute&nbsp;the&nbsp;paths&nbsp;for&nbsp;the&nbsp;points&nbsp;at&nbsp;the&nbsp;given<br>
&nbsp;&nbsp;&nbsp;&nbsp;indices.&nbsp;Incompatible&nbsp;with&nbsp;method&nbsp;==&nbsp;'FW'.<br>
&nbsp;<br>
Returns<br>
-------<br>
dist_matrix&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;matrix&nbsp;of&nbsp;distances&nbsp;between&nbsp;graph&nbsp;nodes.&nbsp;dist_matrix[i,j]<br>
&nbsp;&nbsp;&nbsp;&nbsp;gives&nbsp;the&nbsp;shortest&nbsp;distance&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j&nbsp;along&nbsp;the&nbsp;graph.<br>
&nbsp;<br>
predecessors&nbsp;:&nbsp;ndarray<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returned&nbsp;only&nbsp;if&nbsp;return_predecessors&nbsp;==&nbsp;True.<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;N&nbsp;x&nbsp;N&nbsp;matrix&nbsp;of&nbsp;predecessors,&nbsp;which&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;reconstruct<br>
&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;shortest&nbsp;paths.&nbsp;&nbsp;Row&nbsp;i&nbsp;of&nbsp;the&nbsp;predecessor&nbsp;matrix&nbsp;contains<br>
&nbsp;&nbsp;&nbsp;&nbsp;information&nbsp;on&nbsp;the&nbsp;shortest&nbsp;paths&nbsp;from&nbsp;point&nbsp;i:&nbsp;each&nbsp;entry<br>
&nbsp;&nbsp;&nbsp;&nbsp;predecessors[i,&nbsp;j]&nbsp;gives&nbsp;the&nbsp;index&nbsp;of&nbsp;the&nbsp;previous&nbsp;node&nbsp;in&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;from&nbsp;point&nbsp;i&nbsp;to&nbsp;point&nbsp;j.&nbsp;&nbsp;If&nbsp;no&nbsp;path&nbsp;exists&nbsp;between&nbsp;point<br>
&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;and&nbsp;j,&nbsp;then&nbsp;predecessors[i,&nbsp;j]&nbsp;=&nbsp;-9999<br>
&nbsp;<br>
Raises<br>
------<br>
<a href="#NegativeCycleError">NegativeCycleError</a>:<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;there&nbsp;are&nbsp;negative&nbsp;cycles&nbsp;in&nbsp;the&nbsp;graph<br>
&nbsp;<br>
Notes<br>
-----<br>
As&nbsp;currently&nbsp;implemented,&nbsp;Dijkstra's&nbsp;algorithm&nbsp;and&nbsp;Johnson's&nbsp;algorithm<br>
do&nbsp;not&nbsp;work&nbsp;for&nbsp;graphs&nbsp;with&nbsp;direction-dependent&nbsp;distances&nbsp;when<br>
directed&nbsp;==&nbsp;False.&nbsp;&nbsp;i.e.,&nbsp;if&nbsp;csgraph[i,j]&nbsp;and&nbsp;csgraph[j,i]&nbsp;are&nbsp;non-equal<br>
edges,&nbsp;method='D'&nbsp;may&nbsp;yield&nbsp;an&nbsp;incorrect&nbsp;result.</tt></dd></dl>
</td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#55aa55">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Data</strong></big></font></td></tr>
    
<tr><td bgcolor="#55aa55"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><strong>__all__</strong> = ['cs_graph_components', 'connected_components', 'laplacian', 'shortest_path', 'floyd_warshall', 'dijkstra', 'bellman_ford', 'johnson', 'breadth_first_order', 'depth_first_order', 'breadth_first_tree', 'depth_first_tree', 'minimum_spanning_tree', 'reverse_cuthill_mckee', 'maximum_bipartite_matching', 'construct_dist_matrix', 'reconstruct_path', 'csgraph_masked_from_dense', 'csgraph_from_dense', 'csgraph_from_masked', ...]<br>
<strong>__docformat__</strong> = 'restructuredtext en'<br>
<strong>__warningregistry__</strong> = {('numpy.dtype size changed, may indicate binary incompatibility. Expected 96, got 88', &lt;type 'exceptions.RuntimeWarning'&gt;, 165): True, ('numpy.dtype size changed, may indicate binary incompatibility. Expected 96, got 88', &lt;type 'exceptions.RuntimeWarning'&gt;, 167): True, ('numpy.dtype size changed, may indicate binary incompatibility. Expected 96, got 88', &lt;type 'exceptions.RuntimeWarning'&gt;, 169): True, ('numpy.dtype size changed, may indicate binary incompatibility. Expected 96, got 88', &lt;type 'exceptions.RuntimeWarning'&gt;, 170): True, ('numpy.ufunc size changed, may indicate binary incompatibility. Expected 192, got 176', &lt;type 'exceptions.RuntimeWarning'&gt;, 165): True, ('numpy.ufunc size changed, may indicate binary incompatibility. Expected 192, got 176', &lt;type 'exceptions.RuntimeWarning'&gt;, 167): True, ('numpy.ufunc size changed, may indicate binary incompatibility. Expected 192, got 176', &lt;type 'exceptions.RuntimeWarning'&gt;, 169): True, ('numpy.ufunc size changed, may indicate binary incompatibility. Expected 192, got 176', &lt;type 'exceptions.RuntimeWarning'&gt;, 170): True}</td></tr></table>
</body></html>